<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开发一个本地化的 RAG 智能体</title>
      <link href="/2025/07/12/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E5%8C%96%E7%9A%84RAG%E6%99%BA%E8%83%BD%E4%BD%93/"/>
      <url>/2025/07/12/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E5%8C%96%E7%9A%84RAG%E6%99%BA%E8%83%BD%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/ai-head-pic.png" alt=""></p><blockquote><p>2025 年被称为“Agentic AI 元年”。</p><p>2025 年才过去一半，Agentic AI 已经快速从研究阶段走向工程化、从单体走向多 Agent 协作、从云端走向本地端/系统级落地。同时，“数字劳动力”也悄然被 AI 智能体引入现实。</p><p>AI 智能体（AI Agent）让 AI 能够像人类一样完成任务、像团队一样协同工作、像助理一样主动服务。它正在重新定义各行各业的工作和协作方式，重塑世界的运转方式。我认为，在未来 “人类定义目标，智能体执行路径” 这种全新的协作范式，将会成为常规操作。</p><p>AI 智能体为什么有这么大的影响力？它的本质是什么？相信大家很轻易就能获取“答案”，但是，就像不能同时戴两块手表一样，面对众说纷纭，哪一个才是对的？如何在 AI 面前保持清醒而准确的判断力，这将是未来的一大课题（Emm… 扯远了，回归正题）。</p><p>我打算通过开发一个智能体，来对 AI 智能体背后的逻辑和运行机制探索一二。</p><p>Let’s do it！</p></blockquote><a id="more"></a><h1 id="一、一些概念"><a href="#一、一些概念" class="headerlink" title="一、一些概念"></a>一、一些概念</h1><p>首先，我们需要明确一些概念。</p><h2 id="什么是智能体"><a href="#什么是智能体" class="headerlink" title="什么是智能体"></a>什么是智能体</h2><p>根据人工智能领域的经典教材和权威文献《Artificial Intelligence: A Modern Approach》， 智能体（Agent）的定义如下：</p><blockquote><p>An agent is anything that can be viewed as perceiving its environment through sensors and acting upon that environment through actuators.</p></blockquote><p>简单讲，智能体（Agent）就是一个能自主感知环境、基于目标做出行动决策的系统。</p><h2 id="什么是-AI-智能体"><a href="#什么是-AI-智能体" class="headerlink" title="什么是 AI 智能体"></a>什么是 AI 智能体</h2><p>AI 智能体，是基于人工智能技术，例如大语言模型（LLM）、强化学习（RL）、规划推理、工具调用（Tool Use）等，具备自主感知环境、理解上下文、制定计划、调用外部工具、连续行动、与环境和用户互动等能力的系统。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p>自主感知（Perception）<br>可主动接收环境输入，如用户指令、上下文、文档、数据流。不被动等待，能感知外界变化或反馈。</p><blockquote><p>例如：用户上传 PDF，Agent 自动识别结构并提取摘要。</p></blockquote></li><li><p>目标导向（Goal-Driven）<br>不像传统模型只处理单条输入，智能体围绕一个明确的「目标」开展任务流程，动态推进多步操作。</p><blockquote><p>例如：目标是“生成一份调研报告”，它会分阶段查资料、写摘要、整合输出。</p></blockquote></li><li><p>思维链条（Reasoning / Planning）<br>具备多轮推理、任务规划能力，能决定“下一步做什么” 。</p><blockquote><p>相关技术： ReAct、Tree-of-Thought、Plan-and-Execute 等。</p></blockquote></li><li><p>工具调用（Tool Use）<br>可灵活调用外部函数、API、数据库、搜索引擎、代码解释器等工具。</p><blockquote><p>这一特征是 AI 智能体从语言模型向“行动体”进化的关键。</p></blockquote></li><li><p>记忆系统（Memory）<br>通过短期/长期记忆机制维护上下文状态，使对话更连贯，行为更智能。</p><blockquote><p>例如：可记录用户偏好、过往任务、事件状态等。</p></blockquote></li><li><p>多 Agent 协作（Multi-Agent Collaboration）<br>多个智能体之间可以分工协作、对话协调，构成 Agent Graph、团队式工作流，解决更复杂任务。</p><blockquote><p>例如：一个知识采集 Agent + 写作 Agent + 审核 Agent 联合生成报告。</p></blockquote></li><li><p>反思与自我优化（Self-Reflection）<br>执行完任务后能自检过程和结果，发现错误并修正，或优化下一轮行为。</p><blockquote><p>例如：AutoGPT 的任务循环中，会根据执行结果判断是否偏离目标，进行修正。</p></blockquote></li><li><p>持续运行与自治（Autonomy &amp; Looping）<br>支持连续运行、自主决策，减少人工干预，甚至可以触发自己的下一次运行（如 AutoGen、CrewAI、OpenDevin 等）。</p><blockquote><p>例如：每天定时自动收集行业资讯、总结趋势并发送报告。</p></blockquote></li></ol><h2 id="什么是-RAG"><a href="#什么是-RAG" class="headerlink" title="什么是 RAG"></a>什么是 RAG</h2><p>RAG（Retrieval-Augmented Generation，检索增强生成），是一种将外部知识库检索与大语言模型生成能力结合的 AI 技术架构，用于解决语言模型上下文长度有限、知识截止时间固定、生成幻觉（hallucination）的问题。</p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>先检索，后生成。</p><p>在模型生成答案前，先从外部知识库或文档库中检索相关内容，再将这些内容连同用户问题一起送入语言模型，辅助生成更可靠、更符合事实的回复。</p><p>RAG 适合知识密集型应用场景。</p><h3 id="RAG-系统标准架构"><a href="#RAG-系统标准架构" class="headerlink" title="RAG 系统标准架构"></a>RAG 系统标准架构</h3><p>核心流程：用户问题 → 解析意图 → 检索相关知识 → 融合知识与语言模型 → 给出回答</p><p><img src="/images/RAG-sys-structure.png" alt=""></p><h2 id="什么是-RAG-智能体"><a href="#什么是-RAG-智能体" class="headerlink" title="什么是 RAG 智能体"></a>什么是 RAG 智能体</h2><p>RAG 智能体是现代 AI 智能体体系中的一种知识密集型、多模态增强型智能体形态。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>它不仅具备自主决策、环境感知、工具调用等能力，还集成了检索增强生成（RAG）机制。它在执行任务时，能够：</p><ul><li>自主检索外部知识库</li><li>融合检索内容和上下文问题进行推理生成</li><li>根据目标规划行动</li><li>调用多工具协作完成复杂任务</li></ul><h3 id="RAG-智能体标准架构"><a href="#RAG-智能体标准架构" class="headerlink" title="RAG 智能体标准架构"></a>RAG 智能体标准架构</h3><p><img src="/images/RAG-agent-structure.png" alt=""></p><h1 id="二、搭建-RAG-智能体的途径"><a href="#二、搭建-RAG-智能体的途径" class="headerlink" title="二、搭建 RAG 智能体的途径"></a>二、搭建 RAG 智能体的途径</h1><h2 id="途径一：No-Low-Code-平台搭建"><a href="#途径一：No-Low-Code-平台搭建" class="headerlink" title="途径一：No/Low Code 平台搭建"></a>途径一：No/Low Code 平台搭建</h2><p>利用已有的线上平台，如国内的 <a href="https://www.coze.cn/" target="_blank" rel="noopener">扣子</a>、<a href="https://chatglm.cn/glms?lang=zh" target="_blank" rel="noopener">智普清言</a> 等，可以免费创建和配置 RAG 智能体应用，有一定免费资源额度，超出需支付费用（例如扣子智能体，按照资源点计费）。适用于无开发经验者，想快速体验智能体功能者，以及通用、简单的小场景。</p><h2 id="途径二：开发实现"><a href="#途径二：开发实现" class="headerlink" title="途径二：开发实现"></a>途径二：开发实现</h2><ul><li><p>方式一：利用大模型开放 API，线上调用<br>可以独立部署，但是需要联网使用（未开源的大模型的 openAPI 需要按 token 收费）。适用于对性能、回答质量要求较高，或者需求复杂、数据敏感等场景。</p></li><li><p>方式二：利用开源模型，本地化离线调用<br>可以独立部署，并且无需联网，离线可用。适用于个人兴趣研究、对性能无特定要求、预算有限或者行业敏感等场景。</p></li></ul><h1 id="三、开发一个本地化的-RAG-智能体"><a href="#三、开发一个本地化的-RAG-智能体" class="headerlink" title="三、开发一个本地化的 RAG 智能体"></a>三、开发一个本地化的 RAG 智能体</h1><p>下面我将从零开始一步一步开发一个离线可用的 RAG 智能体。里面包含了一些值得记录的踩坑填坑过程，或许也能帮助大家更好地理解和尝试开发。</p><h2 id="功能清单"><a href="#功能清单" class="headerlink" title="功能清单"></a>功能清单</h2><p>✅ 使用本地模型<br>✅ 支持从文档中提取知识<br>✅ 支持文档上传、自动构建向量库、多知识库切换<br>✅ 支持向量化检索（RAG）<br>✅ 支持 Agent 工具调用<br>✅ 支持对话记忆（Memory）<br>✅ 支持历史问答的记录、导出<br>✅ 支持展示思考过程、停止思考<br>✅ 友好的 UI 界面</p><p>麻雀虽小五脏俱全。</p><h2 id="开发基本步骤"><a href="#开发基本步骤" class="headerlink" title="开发基本步骤"></a>开发基本步骤</h2><p>AI 智能体应用开发与其他应用开发步骤没有什么太大区别。</p><p><img src="/images/dev-flow.png" alt=""></p><p>需求已经明确（见功能清单），下面我们从技术选型开始。</p><h2 id="Step-1-技术选型"><a href="#Step-1-技术选型" class="headerlink" title="Step 1: 技术选型"></a>Step 1: 技术选型</h2><p>合理的技术选型是你的智能体是否能达到你的预期的关键。</p><h3 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h3><p><strong>选型：<a href="https://www.python.org/" target="_blank" rel="noopener">Python</a></strong></p><p>这个不用多说，整个 AI 生态几乎都是 Python 写的。 </p><h3 id="智能体框架"><a href="#智能体框架" class="headerlink" title="智能体框架"></a>智能体框架</h3><p><strong>选型：<a href="https://www.langchain.com/" target="_blank" rel="noopener">LangChain</a></strong></p><p>要开发 RAG 智能体，少不了要进行检索文档、调用大模型、调用工具等操作，这些操作都是最基础的标准动作，已经有开源的框架库帮我们封装好了，不需要我们从头来写。LangChain 在众多开源的智能体框架中，工具链最全，文档完善，社区活跃，生态最大，而且上手难度适中。如果没有特别的要求，LangChain 是不二选择。</p><p>注意：从 LangChain v0.1.0+ 开始，为了代码解耦、模块独立性更强，大量原来内置在 langchain 的组件被拆分到了新的包。一般来说，本地化部署，至少还需搭配 langchain-community 一起使用。</p><h3 id="文本切分器（Text-Splitter）"><a href="#文本切分器（Text-Splitter）" class="headerlink" title="文本切分器（Text Splitter）"></a>文本切分器（Text Splitter）</h3><p><strong>选型：RecursiveCharacterTextSplitter</strong></p><p>文本切分器是构建 RAG 系统时的关键组件，用于把长文本分割成适合向量化与检索的短文本块（chunks）。一个优秀的文本切分器不仅影响检索效果，还能显著提高回答质量。LangChain 框架里就集成了很多个文本分割器工具，本项目选择 RecursiveCharacterTextSplitter，可以按层级字符递归分割，且保留语义。</p><p>以下是 LangChain 里集成的文本切分器工具的简单对比：</p><table><thead><tr><th>名称</th><th>分割依据</th><th>特点</th></tr></thead><tbody><tr><td><strong>RecursiveCharacterTextSplitter</strong></td><td>层级字符（句/段）</td><td>中英兼容，保留语义，支持递归分割，最常用</td></tr><tr><td><strong>MarkdownTextSplitter</strong></td><td>标题/段落结构</td><td>只支持Markdown格式适合文档，保留语义</td></tr><tr><td><strong>SpacyTextSplitter</strong></td><td>句子级分割</td><td>推荐英文，语义好但依赖大模型</td></tr><tr><td><strong>NLTKTextSplitter</strong></td><td>句子级分割</td><td>推荐英文，保留语义，较轻量</td></tr><tr><td><strong>TokenTextSplitter</strong></td><td>Token 数</td><td>中英兼容，不保留语义</td></tr><tr><td><strong>CharacterTextSplitter</strong></td><td>固定字符数</td><td>中英兼容，不保留语义，最基础最简单的切割方式</td></tr></tbody></table><h3 id="文本嵌入模型（Embedding）"><a href="#文本嵌入模型（Embedding）" class="headerlink" title="文本嵌入模型（Embedding）"></a>文本嵌入模型（Embedding）</h3><p><strong>选型：HuggingFaceEmbeddings + bge-small-en</strong></p><p>嵌入模型用于把文本转成语义向量，让机器可以理解、比较和检索语言内容，是现代语义搜索和 RAG 系统的基础核心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">嵌入模型 = 语义理解引擎 + 数学向量编码器</span><br></pre></td></tr></table></figure></p><p>其中，向量化编码可将文本内容转成一个固定长度的向量，这些向量位于一个高维空间中，在这个高维空间中，相似内容向量靠得近，不相关内容向量距离远。</p><p>由于我们要本地化离线开发，相比线上调用，要多考虑一个维度：平衡本地硬盘资源和模型性能效果，选择方向很明确：开源 + 体积尽可能小 + 性能尽可能高。</p><p>几款主流文本嵌入模型：</p><table><thead><tr><th>模型名称</th><th>嵌入维度</th><th>参数量</th><th>模型体积（≈）</th><th>所属机构</th></tr></thead><tbody><tr><td><strong><a href="https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2" target="_blank" rel="noopener">MiniLM-L6-v2</a></strong></td><td>384</td><td>~22M</td><td>90.9MB</td><td>Microsoft</td></tr><tr><td><strong><a href="https://huggingface.co/BAAI/bge-small-zh/tree/main" target="_blank" rel="noopener">bge-small-zh</a></strong></td><td>384</td><td>~30M</td><td>95.8MB</td><td>BBAI</td></tr><tr><td><strong><a href="https://huggingface.co/BAAI/bge-small-en/tree/main" target="_blank" rel="noopener">bge-small-en</a></strong></td><td>384</td><td>~30M</td><td>130MB</td><td>BBAI</td></tr><tr><td><strong><a href="https://huggingface.co/intfloat/e5-small/tree/main" target="_blank" rel="noopener">E5-small</a></strong></td><td>384</td><td>~40M</td><td>134MB</td><td>Microsoft</td></tr><tr><td><strong><a href="https://huggingface.co/thenlper/gte-small/tree/main" target="_blank" rel="noopener">GTE-small</a></strong></td><td>384</td><td>~45M</td><td>67MB</td><td>Alibaba</td></tr><tr><td><strong><a href="https://huggingface.co/BAAI/bge-base-zh/tree/main" target="_blank" rel="noopener">bge-base-zh</a></strong></td><td>768</td><td>~110M</td><td>409MB</td><td>BBAI</td></tr><tr><td><strong><a href="https://huggingface.co/BAAI/bge-base-en/tree/main" target="_blank" rel="noopener">bge-base-en</a></strong></td><td>768</td><td>~110M</td><td>438MB</td><td>BBAI</td></tr><tr><td><strong><a href="https://huggingface.co/intfloat/e5-base/tree/main" target="_blank" rel="noopener">E5-base</a></strong></td><td>768</td><td>~110M</td><td>438MB</td><td>Microsoft</td></tr><tr><td><strong><a href="https://huggingface.co/thenlper/gte-base/tree/main" target="_blank" rel="noopener">GTE-base</a></strong></td><td>768</td><td>~110M</td><td>219MB</td><td>Alibaba</td></tr><tr><td><strong><a href="https://huggingface.co/BAAI/bge-large-zh/tree/main" target="_blank" rel="noopener">bge-large-zh</a></strong></td><td>1024</td><td>~320M</td><td>1.3GB</td><td>BBAI</td></tr><tr><td><strong><a href="https://huggingface.co/BAAI/bge-large-en/tree/main" target="_blank" rel="noopener">bge-large-en</a></strong></td><td>1024</td><td>~320M</td><td>1.34GB</td><td>BBAI</td></tr><tr><td><strong><a href="https://huggingface.co/intfloat/e5-large/tree/main" target="_blank" rel="noopener">E5-large</a></strong></td><td>1024</td><td>~330M</td><td>1.34GB</td><td>Microsoft</td></tr><tr><td><strong><a href="https://huggingface.co/thenlper/gte-large/tree/main" target="_blank" rel="noopener">GTE-large</a></strong></td><td>1024</td><td>~434M</td><td>670MB</td><td>Alibaba</td></tr><tr><td><strong><a href="https://huggingface.co/Muennighoff/SGPT-5.8B-weightedmean-msmarco-specb-bitfit/tree/main" target="_blank" rel="noopener">SGPT-5.8B</a></strong></td><td>1024</td><td>~5.8B</td><td>23.5GB</td><td>UKPLab</td></tr></tbody></table><p>本项目选择 bge-small-en（为什么没选 bge-small-zh 后面会讲到），小模型中语义效果最平衡。</p><p>bge-small-en 是 BBAI 开源的 BGE 系列模型中的体积较小的一款。BGE 系列模型托管在 <a href="huggingface.co">Hugging Face</a> 平台，Hugging Face 是 AI 领域最活跃的社区之一，以开放协作闻名。</p><p>想要调用 bge-small-en 模型，可以直接使用 LangChain 框架内置的 Embedding 接口封装器 —— HuggingFaceEmbeddings。</p><p>注意：LangChain 的 HuggingFaceEmbeddings 实际上是对 sentence-transformers 库的高阶封装，HuggingFaceEmbeddings 包的使用依赖 sentence-transformers 库，安装依赖时需要同时安装 sentence-transformers。</p><h3 id="向量数据库（Vector-Database）"><a href="#向量数据库（Vector-Database）" class="headerlink" title="向量数据库（Vector Database）"></a>向量数据库（Vector Database）</h3><p><strong>选型：faiss-cpu</strong></p><p>向量数据库是专门用于存储和高效检索向量（如文本或图像的嵌入向量）的数据库系统，是大模型和 AI 应用背后的“语义记忆库”。</p><p>本项目选择 Facebook AI Research 团队（FAIR）开源的 <a href="https://faiss.ai/" target="_blank" rel="noopener">FAISS</a>（Facebook AI Similarity Search）。除此之外，Chroma Org 公司的开源向量数据库 ChromaDB 也是不错的选择。 </p><p>FAISS 有两个可选择的版本：</p><ul><li>faiss-gpu，利用 NVIDIA GPU 进行加速，需安装 CUDA</li><li>faiss-cpu，是 FAISS 库的 CPU-only 版本，适用于 CPU 环境，兼容性好</li></ul><p>对于 FAISS 的数据库操作，LangChain 框架也内置了对应的接口封装器 —— FAISS。</p><h3 id="本地大模型（LLM）"><a href="#本地大模型（LLM）" class="headerlink" title="本地大模型（LLM）"></a>本地大模型（LLM）</h3><p><strong>选型：<a href="https://ollama.com" target="_blank" rel="noopener">Ollama</a> + phi3-mini</strong></p><p>我们的 LLM 是要本地化调用的，所以需要一个模型引擎来启动本地 LLM 服务。开源社区有不少大语言模型引擎，当中最火的是 Ollama。Ollama 可以让你像运行 Docker 一样在本机调用语言模型。除此之外，它还有以下优点：</p><ol><li>内置模型仓库（model registry），支持一键 pull 模型</li><li>兼容 OpenAI API 格式（即很多用 openai.ChatCompletion 写的应用，改一下 API 地址就能跑 Ollama 上的模型）</li><li>Ollama 生态也很不错，目前已支持175个主流大模型。<blockquote><p>完整的支持模型列表：<a href="https://ollama.com/library" target="_blank" rel="noopener">https://ollama.com/library</a></p></blockquote></li></ol><p>与 Embedding 模型选型一样，LLM 模型同样需要权衡本地硬盘资源和模型性能。</p><p>以下为部分 Ollama 支持的主流开源 LLM 模型：</p><table><thead><tr><th>模型名称</th><th>参数量</th><th>模型体积（量化后）</th><th>所属公司/团队</th></tr></thead><tbody><tr><td><strong>LLaMA 3 (8B)</strong></td><td>8B</td><td>~4–6 GB</td><td>Meta (Facebook)</td></tr><tr><td><strong>LLaMA 3 (70B)</strong></td><td>70B</td><td>~30–40 GB</td><td>Meta</td></tr><tr><td><strong>Mistral (7B)</strong></td><td>7B</td><td>~4–5 GB</td><td>Mistral AI</td></tr><tr><td><strong>Mixtral (MoE 8x7B)</strong></td><td>12.9B</td><td>~12 GB</td><td>Mistral AI</td></tr><tr><td><strong>Phi-3 Mini</strong></td><td>3.8B</td><td>~1.8 GB</td><td>Microsoft</td></tr><tr><td><strong>Phi-3 Medium</strong></td><td>14B</td><td>~5–6 GB</td><td>Microsoft</td></tr><tr><td><strong>Gemma (2B)</strong></td><td>2B</td><td>~1.5–2 GB</td><td>Google DeepMind</td></tr><tr><td><strong>Gemma (7B)</strong></td><td>7B</td><td>~5–6 GB</td><td>Google</td></tr></tbody></table><p>本项目选择体积相对较小的 <a href="https://ollama.com/library/phi3" target="_blank" rel="noopener">phi3-mini</a>，它是微软推出的轻量级开源大模型，属于 <a href="https://huggingface.co/collections/microsoft/" target="_blank" rel="noopener">Phi 系列模型</a>。定位：轻量级、高性能，适用于移动端和边缘设备。</p><p>这是 Phi-3 系列模型在“模型质量 vs 参数规模”维度上的性能表现：<br>Phi-3-mini（3.8B）质量表现 70，比 LLaMA-3-8B-In 评分高，体积还更小。</p><p><img src="/images/phi3-mini.png" alt=""></p><blockquote><p>横轴（X 轴）：模型大小（Size），单位是 参数量（以 B = Billion = 十亿计）<br>纵轴（Y 轴）：模型质量（Quality），来自 MMLU（多任务语言理解） Benchmark，数值越高表示模型表现越好</p></blockquote><p>Phi 系列模型技术特点：</p><ul><li>基于 Transformer 架构，参数量较小（Phi-3-mini 约38亿参数）。</li><li>强调 高效推理 和 低资源消耗，适合本地部署。</li></ul><h3 id="WEB-框架"><a href="#WEB-框架" class="headerlink" title="WEB 框架"></a>WEB 框架</h3><p><strong>选型：<a href="https://streamlit.io/" target="_blank" rel="noopener">Streamlit</a></strong></p><p>为了把精力集中放在 AI 智能体的逻辑上，本项目前端界面和交互选择使用 Streamlit 框架。Streamlit 的定位是零前端，快速原型，面向数据科学和 AI/ML 工程师的开源 Python 框架。只需几行 Python 代码即可实现展示图表、添加交互控件、部署应用等功能，用于快速构建交互式 Web 应用非常方便，上手也简单。</p><p>下面是几款 Python Web 框架对比：</p><table><thead><tr><th>框架</th><th>语言</th><th>特点</th><th>适合人群</th></tr></thead><tbody><tr><td><strong>Streamlit</strong></td><td>Python</td><td>零前端，快速原型，交互控件丰富</td><td>数据科学、AI 开发者</td></tr><tr><td><strong>Flask</strong></td><td>Python</td><td>极简 Web 框架，适合小型项目</td><td>Python 工程师</td></tr><tr><td><strong>Django</strong></td><td>Python</td><td>功能全面，适合大中型系统</td><td>后端开发者</td></tr><tr><td><strong>Dash</strong></td><td>Python</td><td>类似 Streamlit，适合数据可视化</td><td>数据分析</td></tr><tr><td><strong>NiceGUI</strong></td><td>Python</td><td>基于 Vue3 + TailwindCSS + Python</td><td>全栈视觉化</td></tr><tr><td><strong>Panel</strong></td><td>Python</td><td>强可视化能力，适合科学计算</td><td>科研 &amp; 工程领域</td></tr></tbody></table><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>问答链：RetrievalQA 组件</li><li>Agent 工具：Tool 组件</li><li>对话记忆：ConversationBufferMemory 组件</li></ul><p>这些功能组件都已经在 LangChain 中集成。</p><h2 id="Step-2-Python-环境搭建"><a href="#Step-2-Python-环境搭建" class="headerlink" title="Step 2: Python 环境搭建"></a>Step 2: Python 环境搭建</h2><blockquote><p>如果已经有本地 Python 运行环境，跳过此步。</p></blockquote><p>Mac 电脑的 Python 环境搭建步骤（Windows 电脑的请自己查一下搞定）：</p><ul><li>安装 Homebrew（Mac和Linux的包管理器，默认不自带）</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><ul><li>安装 pyenv（Python版本管理器）</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><ul><li>安装 Python</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install x.x.x <span class="comment"># Python 版本，例如 3.13、3.11</span></span><br></pre></td></tr></table></figure><blockquote><p>推荐大家安装 3.11 版本，不推荐太高的版本，坑多，别问我怎么知道的，都是泪😭。</p></blockquote><ul><li>配置 pyenv 环境变量（仅首次）<br>将以下代码加入 ~/.zshrc 或 ~/.bash_profile：</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$HOME</span>/.pyenv/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv init --path)</span>"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv init -)</span>"</span></span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc   <span class="comment"># 或 source ~/.bash_profile</span></span><br></pre></td></tr></table></figure><ul><li>设置当前项目用的 Python 版本</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 项目目录</span><br><span class="line">pyenv <span class="built_in">local</span> x.x.x <span class="comment"># Python 版本，例如 3.13、3.11</span></span><br></pre></td></tr></table></figure><ul><li>创建虚拟环境（可选，推荐）</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 项目目录</span><br><span class="line">python3 -m venv .venv</span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br></pre></td></tr></table></figure><p>激活后，终端前缀会出现 “venv”，表示你当前在这个虚拟环境里。在这个环境里可以直接用 “python” 和 “pip” 命令，而不需要用 “python3” 和 “pip3”。</p><p>至此，你的 Mac 的 Python 环境就 ready 了。</p><h2 id="Step-3-项目依赖安装"><a href="#Step-3-项目依赖安装" class="headerlink" title="Step 3: 项目依赖安装"></a>Step 3: 项目依赖安装</h2><h3 id="三方库安装"><a href="#三方库安装" class="headerlink" title="三方库安装"></a>三方库安装</h3><p>有人会说，直接告诉我项目依赖清单，然后 pip install -r 不就好了，为什么三方库安装还要拿出来单独说？</p><p>因为，<strong>项目依赖的安装，大概是我在整个项目中遇到挫折（坑）最多的一步。</strong></p><h3 id="坑1：安装-faiss-cpu"><a href="#坑1：安装-faiss-cpu" class="headerlink" title="坑1：安装 faiss-cpu"></a>坑1：安装 faiss-cpu</h3><p>首先，经过上面的技术选型，项目核心依赖的三方库也就确定了：langchain、faiss-cpu、streamlit、langchain-community、sentence-transformers。很简单，pip install 一个一个安装，结果到 faiss-cpu，卡壳了。</p><p>首先是提示缺少 swig：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: <span class="built_in">command</span> <span class="string">'swig'</span> failed: No such file or directory</span><br></pre></td></tr></table></figure><p>查了下，因为 faiss 本身是 C++ 实现，安装时首先会通过 swig 生成 Python 扩展作为 Python 和 C++ 之间的桥接，现在缺少 swig 这个工具。这个好办，安上便是：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install swig</span><br></pre></td></tr></table></figure><p>继续安装 faiss-cpu，换来一堆更大的报错，提示编译缺少 C++ 头文件（截取2行做代表） ：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> faiss/faiss/python/swigfaiss.i:952: Error: Unable to find <span class="string">'faiss/MatrixStats.h'</span></span><br><span class="line">error: <span class="built_in">command</span> <span class="string">'/usr/local/bin/swig'</span> failed with <span class="built_in">exit</span> code 1</span><br></pre></td></tr></table></figure><p>当 pip 没有成功拉取到 wheel 文件时（可能网络超时、无对应版本的 wheel 等原因），会自动 fallback 到源代码仓库，拉取 tar.gz 源码包来构建安装。但是 pip 只下载了 Python 绑定部分，源码不完整，缺少 C++ 头文件，于是编译报错。如果要继续编译，就要想办法下载完整源文件，可能还要再安装 cmake 等编译工具，然后再尝试。。。好像一条不归路。我们还是不要在 mac 上编译 faiss 源码了，依赖复杂，坑多。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>换个思路，pip 拉源码编译，是因为没有获取到预编译 wheel，那我是不是可以手动下载官方编译好的 faiss-cpu wheel 文件，让 pip 直接读取本地 wheel 来安装，绕过本地编译。</p><p>为了下载更快，特地找了清华源镜像地址：<br><a href="https://pypi.tuna.tsinghua.edu.cn/simple/faiss-cpu/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/faiss-cpu/</a><br>注意 wheel 文件要跟本地的 Python 版本对应，比如我是 3.13，就要是 cp313：</p><p><img src="/images/faiss-cpu.png" alt=""></p><p>把它下载好放在项目目录下，执行命令</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --no-deps ./faiss_cpu-1.10.0-cp313-cp313-macosx_10_14_x86_64.whl</span><br></pre></td></tr></table></figure><p>丝滑安装。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><p>faiss-cpu 不要直接 pip 安装，建议先手动下载本地 Python 对应版本的 wheel 文件再 pip 安装。</p><h3 id="坑2-安装-sentence-transformers"><a href="#坑2-安装-sentence-transformers" class="headerlink" title="坑2: 安装 sentence-transformers"></a>坑2: 安装 sentence-transformers</h3><p>同样，直接安装一堆报错：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Cannot install sentence-transformers==0.1.0, </span><br><span class="line">...</span><br><span class="line">sentence-transformers==4.1.0 and sentence-transformers==5.0.0 because these package versions have conflicting dependencies.</span><br><span class="line">The conflict is caused by:</span><br><span class="line">    sentence-transformers 5.0.0 depends on torch&gt;=1.11.0</span><br><span class="line">    ...</span><br><span class="line">    sentence-transformers 0.1.0 depends on torch&gt;=1.0.1</span><br></pre></td></tr></table></figure><p>提示依赖包 torch 版本冲突，看了下，本地没有 torch。好办，pip 安装，but：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade torch --index-url https://download.pytorch.org/whl/cpu</span><br><span class="line"></span><br><span class="line">Looking <span class="keyword">in</span> indexes: https://download.pytorch.org/whl/cpu</span><br><span class="line">ERROR: Could not find a version that satisfies the requirement torch (from versions: none)</span><br><span class="line">ERROR: No matching distribution found <span class="keyword">for</span> torch</span><br></pre></td></tr></table></figure><p>为了避免网络超时，我还特意指定了 cpu-only 的 wheel 包地址，结果还是提示找不到 torch。打开 wheel 包地址进去搜索，还真是没有 cp313 macos x86 版本。最高支持 Python 3.11。。。</p><h4 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h4><p>降版本。先是本地 Python 从3.13 降到 3.11（用 pyenv 倒也还方便），然后是重新安装前面所有的依赖，faiss-cpu 则重新下载 cp311 版本，为了不再出幺蛾子，torch 我也直接下载了 cp311 的 wheel 文件（体积不小，有 150 M）。</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 pyenv 下载并切换 3.11 版本 </span></span><br><span class="line">pyenv install 3.11</span><br><span class="line">pyenv <span class="built_in">local</span> 3.11.13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并激活虚拟环境</span></span><br><span class="line">python3 -m venv .venv</span><br><span class="line"><span class="built_in">source</span> ./.venv/bin/activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新安装依赖</span></span><br><span class="line">pip install langchain streamlit langchain-community</span><br><span class="line">pip install --no-deps ./faiss_cpu-1.10.0-cp311-cp311-macosx_10_14_x86_64.whl</span><br><span class="line">pip install --no-deps ./torch-2.2.2-cp311-none-macosx_10_9_x86_64.whl</span><br></pre></td></tr></table></figure><p>这回挺顺利。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ol><li>很多主流 AI 库还没出 Python 3.13 及以上 的官方 wheel，pip 就自动 fallback 到源码装，而 faiss 源码依赖超多，Mac 上编译麻烦得很，容易各种编译失败。所以建议大家本地 Python 安装 3.11 版本，各方面生态都支持的比较好。还有遇到源码编译报错的包，推荐手动下载 wheel 安装。</li><li>LangChain 的文本嵌入模块 HuggingFaceEmbeddings 会有层层依赖，安装时容易受挫，别怕，都给你梳理好了：HuggingFaceEmbeddings 依赖 sentence-transformers，sentence-transformers 依赖 torch，（torch 依赖 numpy，运行时才会暴露）。</li></ol><p>陆续又增加了些依赖包，最终：</p><table><thead><tr><th>包名</th><th>用途</th></tr></thead><tbody><tr><td>langchain</td><td>Agent 框架，核心库</td></tr><tr><td>faiss-cpu</td><td>本地向量库</td></tr><tr><td>streamlit</td><td>构建前端聊天界面</td></tr><tr><td>langchain-community</td><td>LangChain 社区版扩展（内置 FAISS、Huggingface Embedding 等）</td></tr><tr><td>sentence-transformers</td><td>HuggingFaceEmbeddings 的底层依赖，必须安装</td></tr><tr><td>torch</td><td>sentence-transformers 底层依赖，必须安装</td></tr><tr><td>numpy</td><td>数值计算基础库，torch 的依赖，需注意版本对应</td></tr></tbody></table><h3 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h3><h4 id="Embedding-模型"><a href="#Embedding-模型" class="headerlink" title="Embedding 模型"></a>Embedding 模型</h4><p>bge-small-en 托管在 Hugging Face 平台上，<a href="https://huggingface.co/BAAI/bge-small-en" target="_blank" rel="noopener">传送门</a></p><p><img src="/images/bge-small-en.png" alt=""></p><p>把 main 分支下的文件全部下载下来，放到项目目录下。</p><h4 id="坑3：-bin-模型权重文件的加载对-torch-版本有要求"><a href="#坑3：-bin-模型权重文件的加载对-torch-版本有要求" class="headerlink" title="坑3：.bin 模型权重文件的加载对 torch 版本有要求"></a>坑3：.bin 模型权重文件的加载对 torch 版本有要求</h4><p>这是后面运行时的报错，因为问题与模型和 torch 密切相关，也一并放在模型这里讲了<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Due to a serious vulnerability issue <span class="keyword">in</span> torch.load, even with weights_only=True, we now require users to upgrade torch to at least v2.6 <span class="keyword">in</span> order to use the <span class="keyword">function</span>. This version restriction does not apply when loading files with safetensors.</span><br><span class="line">See the vulnerability report here https://nvd.nist.gov/vuln/detail/CVE-2025-32434</span><br></pre></td></tr></table></figure></p><p>从 transformers v4.43+ 开始，因 CVE-2025-32434 漏洞，凡是用 torch.load 加载 .bin 模型权重文件（pytorch_model.bin）都会强制要求 torch&gt;=2.6，否则直接 ValueError。</p><h5 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h5><p>要么升 torch 版本，要么模型权重文件换成 safetensors 格式。因为 safetensors 是安全格式，不受这个漏洞限制，也不依赖 torch.load，加载速度也快很多。前文已经提过，torch 目前只能安装 2.2.2 版本，所以只有换 safetensors 格式。起先我是下载的 bge-small-zh，但是 zh 模型文件里没有 .safetensors 权重文件，这才换成了 bge-small-en。</p><blockquote><p>还记得前面嵌入模型提到的选型为什么选 en 而不是 zh 吗，答案在这里。</p></blockquote><h4 id="LLM-模型"><a href="#LLM-模型" class="headerlink" title="LLM 模型"></a>LLM 模型</h4><p>Phi3-mini 也托管在 Hugging Face 平台上，<a href="https://huggingface.co/microsoft/Phi-3-mini-4k-instruct/tree/main" target="_blank" rel="noopener">传送门</a>。可以像刚才的嵌入模型一样手动下载，也可以用 ollama 来下载和管理LLM 模型（推荐）。</p><h5 id="安装-Ollama-deamon-版"><a href="#安装-Ollama-deamon-版" class="headerlink" title="安装 Ollama deamon 版"></a>安装 Ollama deamon 版</h5><p>官网下载地址：<a href="https://ollama.com/download" target="_blank" rel="noopener">https://ollama.com/download</a></p><p><img src="/images/ollama-deamon-install.png" alt=""></p><p>首次运行 Ollama app，会安装内置的 CLI。安装完后，通过命令 <code>open -a ollama</code> 或者双击 Ollama app 的图标，启动 Ollama deamon。</p><p>启动后，Ollama 会常驻在这里：</p><p><img src="/images/ollama-deamon.png" alt=""></p><p>拉取 phi3-mini：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama pull phi3:mini</span><br></pre></td></tr></table></figure><p><img src="/images/phi3-mini-downloaded.png" alt=""></p><p>有2.2G，下载可能比较久，需耐心等待，我当时断断续续下载了2天才下载下来。Ollama pull 的模型默认会存储在 <code>～/.ollama/models/blobs</code> 这个路径。</p><p>现在，你可以直接在命令行里与本地大模型对话，或者写 Python / HTTP 调用，还可以输入 prompt，实时调用本地模型。通过命令行可快速手动测试模型效果，看看本地模型回的快不快。</p><p><img src="/images/ollama-run-phi3-mini.png" alt=""></p><p>还挺快的。</p><h2 id="Step-4-核心逻辑与关键代码"><a href="#Step-4-核心逻辑与关键代码" class="headerlink" title="Step 4: 核心逻辑与关键代码"></a>Step 4: 核心逻辑与关键代码</h2><h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><p>创建知识库 -&gt; 初始化 agent -&gt; 定义用户界面 -&gt; 对话交互</p><h3 id="1-创建知识库"><a href="#1-创建知识库" class="headerlink" title="1. 创建知识库"></a>1. 创建知识库</h3><h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><p><img src="/images/logic-create-knowledge-lib.png" alt=""></p><h4 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传文档 &amp; 创建新知识库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地模型路径</span></span><br><span class="line">EMBEDDING_MODEL = <span class="string">"./models/bge-small-en"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># HuggingFaceEmbeddings 加载本地 Emedding 模型</span></span><br><span class="line"><span class="meta">@st.cache_resource</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_embeddings</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HuggingFaceEmbeddings(model_name=EMBEDDING_MODEL)</span><br><span class="line"></span><br><span class="line">embeddings = load_embeddings()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建存放向量库的目录</span></span><br><span class="line">VECTOR_DIR = <span class="string">"vectorstores"</span></span><br><span class="line">os.makedirs(VECTOR_DIR, exist_ok=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存向量数据库到本地</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_vectorstore</span><span class="params">(store, db_name)</span>:</span></span><br><span class="line">    path = os.path.join(VECTOR_DIR, db_name)</span><br><span class="line">    store.save_local(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># UI 界面</span></span><br><span class="line">st.sidebar.subheader(<span class="string">"📤 上传文档构建知识库"</span>)</span><br><span class="line">uploaded_file = st.sidebar.file_uploader(<span class="string">"选择文档（.txt）"</span>, type=[<span class="string">"txt"</span>])</span><br><span class="line">db_name_input = st.sidebar.text_input(<span class="string">"知识库名称"</span>, value=<span class="string">"default"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击上传</span></span><br><span class="line"><span class="keyword">if</span> st.sidebar.button(<span class="string">"📚 创建知识库"</span>) <span class="keyword">and</span> uploaded_file:</span><br><span class="line">    <span class="keyword">with</span> st.spinner(<span class="string">"处理中..."</span>):</span><br><span class="line">        loader = TextLoader(os.path.join(<span class="string">'docs'</span>, uploaded_file.name), encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">        <span class="comment"># 读取文档并写入本地</span></span><br><span class="line">        <span class="keyword">with</span> open(os.path.join(<span class="string">'docs'</span>, uploaded_file.name), <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(uploaded_file.read().decode(<span class="string">"utf-8"</span>))</span><br><span class="line">       <span class="comment"># 加载文档</span></span><br><span class="line">        documents = loader.load()</span><br><span class="line">        <span class="comment"># 文档切分</span></span><br><span class="line">        text_splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">            chunk_size=<span class="number">500</span>, chunk_overlap=<span class="number">50</span>)</span><br><span class="line">        docs = text_splitter.split_documents(documents)</span><br><span class="line">        <span class="comment"># 向量化 &amp;&amp; 存储向量数据</span></span><br><span class="line">        vectorstore = FAISS.from_documents(docs, embeddings)</span><br><span class="line">        save_vectorstore(vectorstore, db_name_input)</span><br><span class="line">        <span class="comment"># 成功提示</span></span><br><span class="line">        st.success(<span class="string">f"知识库 '<span class="subst">&#123;db_name_input&#125;</span>' 创建完成！"</span>)</span><br></pre></td></tr></table></figure><h3 id="2-初始化-Agent-实例"><a href="#2-初始化-Agent-实例" class="headerlink" title="2. 初始化 Agent 实例"></a>2. 初始化 Agent 实例</h3><h4 id="代码逻辑-1"><a href="#代码逻辑-1" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><p><img src="/images/logic-init-agent.png" alt=""></p><h4 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 Agent 实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地 LLM 模型路径</span></span><br><span class="line">LLM_MODEL = <span class="string">"phi3:mini"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ollama 加载本地 LLM 模型</span></span><br><span class="line"><span class="meta">@st.cache_resource</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_llm</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Ollama(model=LLM_MODEL)</span><br><span class="line"></span><br><span class="line">llm = load_llm()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 知识库选择</span></span><br><span class="line">st.sidebar.subheader(<span class="string">"📁 选择知识库"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载对应知识库向量数据库</span></span><br><span class="line">vectorstores = [d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(</span><br><span class="line">    VECTOR_DIR) <span class="keyword">if</span> os.path.isdir(os.path.join(VECTOR_DIR, d))]</span><br><span class="line">selected_db = st.sidebar.selectbox(<span class="string">"当前使用知识库："</span>, vectorstores)</span><br><span class="line">vectorstore = load_vectorstore(selected_db)</span><br><span class="line"><span class="comment"># 获取检索器</span></span><br><span class="line">retriever = vectorstore.as_retriever()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 RAG 问答链</span></span><br><span class="line">rag_chain = RetrievalQA.from_chain_type(llm=llm, retriever=retriever)</span><br><span class="line"><span class="comment"># Agent 记忆</span></span><br><span class="line">memory = ConversationBufferMemory(memory_key=<span class="string">"chat_history"</span>)</span><br><span class="line"><span class="comment"># Agent 工具</span></span><br><span class="line">tools = [</span><br><span class="line">    Tool(name=<span class="string">"RAG QA"</span>, func=rag_chain.run, description=<span class="string">"用于查询知识库的工具"</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 Agent</span></span><br><span class="line">agent = initialize_agent(</span><br><span class="line">    tools=tools,</span><br><span class="line">    llm=llm,</span><br><span class="line">    agent=<span class="string">"chat-zero-shot-react-description"</span>,</span><br><span class="line">    verbose=<span class="keyword">True</span>,</span><br><span class="line">    memory=memory</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="3-对话问答"><a href="#3-对话问答" class="headerlink" title="3. 对话问答"></a>3. 对话问答</h3><h4 id="代码逻辑-2"><a href="#代码逻辑-2" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><p><img src="/images/logic-qa.png" alt=""></p><h4 id="关键代码-2"><a href="#关键代码-2" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对话问答</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化状态</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"stop_thinking"</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.stop_thinking = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"qa_history"</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.qa_history = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户提问区</span></span><br><span class="line">query = st.text_area(<span class="string">"请输入问题："</span>, <span class="string">"根据文档内容，总结一下产品的核心优势有哪些？"</span>)</span><br><span class="line">col1, col2, col3 = st.columns(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">with</span> col1:</span><br><span class="line">    submit_clicked = st.button(<span class="string">"🧠 提交"</span>)</span><br><span class="line"><span class="keyword">with</span> col2:</span><br><span class="line">    stop_clicked = st.button(<span class="string">"⛔ 停止思考"</span>)</span><br><span class="line"><span class="keyword">with</span> col3:</span><br><span class="line">    export_clicked = st.button(<span class="string">"📥 导出历史记录"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> stop_clicked:</span><br><span class="line">    st.session_state.stop_thinking = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> submit_clicked:</span><br><span class="line">    st.session_state.stop_thinking = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示思考过程与回答</span></span><br><span class="line"><span class="keyword">if</span> submit_clicked:</span><br><span class="line">    <span class="keyword">with</span> st.spinner(<span class="string">"智能体思考中..."</span>):</span><br><span class="line">        <span class="keyword">if</span> st.session_state.stop_thinking:</span><br><span class="line">            st.warning(<span class="string">"已取消思考"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            old_stdout = sys.stdout</span><br><span class="line">            sys.stdout = mystdout = StringIO()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                response = agent.invoke(query)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                sys.stdout = old_stdout</span><br><span class="line"></span><br><span class="line">            thought = mystdout.getvalue()</span><br><span class="line">            <span class="keyword">with</span> st.expander(<span class="string">"🤖 思考过程"</span>):</span><br><span class="line">                st.code(thought)</span><br><span class="line">            st.success(response)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 保存历史问答</span></span><br><span class="line">            st.session_state.qa_history.append(</span><br><span class="line">                &#123;<span class="string">"question"</span>: query, <span class="string">"answer"</span>: response&#125;)</span><br></pre></td></tr></table></figure><p>最终的目录结构</p><p><img src="/images/project-directory-structure-final.png" alt=""></p><h2 id="Step-5-运行效果"><a href="#Step-5-运行效果" class="headerlink" title="Step 5: 运行效果"></a>Step 5: 运行效果</h2><p>执行命令运行：<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamlit run myAgent.py</span><br></pre></td></tr></table></figure></p><h3 id="坑4-numpy-版本不匹配"><a href="#坑4-numpy-版本不匹配" class="headerlink" title="坑4: numpy 版本不匹配"></a>坑4: numpy 版本不匹配</h3><p>运行之后，前端界面报错</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Numpy is not available</span><br></pre></td></tr></table></figure><p>PyTorch 没能正确检测到 numpy。查了下，在 PyTorch + SentenceTransformers 中，tensor.numpy() 需要 numpy 库。我在安装 sentence-transformers 时，自动安装了 numpy-2.3.1。但 numpy 2.x 和 torch 2.x 不完全兼容，会导致 torch 部分 numpy 接口失效。</p><h4 id="解决办法-3"><a href="#解决办法-3" class="headerlink" title="解决办法"></a>解决办法</h4><p>把 numpy 降到 2.x 以下版本。</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="string">"numpy&lt;2"</span> --force-reinstall</span><br></pre></td></tr></table></figure><p>再次运行，成功了！</p><h4 id="界面效果"><a href="#界面效果" class="headerlink" title="界面效果"></a>界面效果</h4><p><img src="/images/agent-ui1.png" alt=""></p><p>展开思考过程：</p><p><img src="/images/agent-ui2.png" alt=""></p><p>断网，再试一次，依然没问题。</p><p>自此，一个迷你版的本地离线可用的 RAG 智能体诞生了🎉。虽然迷你，虽然还很基础，但正如开头所说，麻雀虽小五脏俱全。</p><h2 id="改进空间"><a href="#改进空间" class="headerlink" title="改进空间"></a>改进空间</h2><p>这个智能体还很初级，功能性能各方面都没来得及好好考虑，存在许多缺陷和不足。要想这个智能体能实际派上用场，还有很多地方需要进一步完善，比如：</p><ul><li>性能问题，文档体积稍大，智能体思考的时间就非常长，需要好好研究优化</li><li>目前输出是英文，下一步可以改成中文，换成中文模型</li><li>目前知识库支持的文件格式比较少，下一步可以支持更多的文件格式</li><li>目前智能体只能检索一个文件，下一步可以支持多个文件</li><li>目前自主调用工具协作这块还只是皮毛，后期可以深入探究如何增强其能动性</li><li>等等</li></ul><p>待我慢慢研究。</p><h2 id="温馨提醒"><a href="#温馨提醒" class="headerlink" title="温馨提醒"></a>温馨提醒</h2><p>要玩本地化，得准备充足的硬盘资源。这是我本地安装运行前后<br>硬盘占用情况，尽管已经在选型上控制模型大小了，还是吃了 8G 的空间。</p><p><img src="/images/disk-storage.png" alt=""></p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>内容回顾，通过这篇文章，你可以：</p><ol><li>深刻认识什么是 RAG 智能体</li><li>深度理解 RAG 背后的逻辑和架构</li><li>了解智能体开发如何技术选型</li><li>初步掌握智能体的开发</li><li>尝试上手，开发一个属于自己的 RAG AI 智能体</li></ol><p>我们已经进入了一个全新的时代，AI 正在真实地改变着我们的工作、学习和交流的模式。在传统时代，要做好一件事情，你需要花很长时间掌握或者熟悉相关技术和生态。但在 AI 时代，你可以边做边学，在 AI 的帮助下，零基础甚至也可以做得大差不差。所以，think bigger，拥抱 AI，正视 AI。</p><p>不如，就从打造一个属于自己的智能体开始吧。</p><p>–<br>Good luck！</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 智能体 </tag>
            
            <tag> RAG </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI、大模型、大语言模型</title>
      <link href="/2025/05/19/Ai%E3%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E3%80%81%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
      <url>/2025/05/19/Ai%E3%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E3%80%81%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/Ai.JPG" alt="ai.png"></p><blockquote><p>ChatGPT 的横空出世与 DeepSeek 的迅速崛起，将人工智能再次推至科技浪潮之巅。科技公司、企业与创业者纷纷入局，不仅仅是想要抓住技术的红利，也有出于被时代淘汰的担忧。全民 AI 时代随之到来，大模型成为热门话题。</p><p>然而，当我们在谈论 AI 时，可能互相谈论的不是同一个东西。在互联网碎片化信息和媒体过度营销的影响下，不少人对 AI 产生认知偏差，认为：AI 就是 ChatGPT、AI 就是 DeepSeek，AI 应用就是提示词工程，AI 是新的科技革命，AI 现在无所不能，只要接入 AI 马上就可以替代员工从而降本增效……但事实上，ChatGPT 和 DeepSeek 只是大语言模型技术的两个应用产品，AI 的领域也远不止文本处理、推理和生成，提示词只是目前与文本类 AI 最有效的交流方式，AI 的研究在上个世纪就开始了，大模型很强大但也有它的缺陷，完全替代人为时尚早。过度营销也是一种营销策略，它可以制造认知泡沫，培养行业“韭菜”，然后在你懵懵懂懂但又想分一杯羹的时候收割一把。</p><p>我在探索 AI 过程中强烈意识到，要想应用好大模型技术，必须先从底层全面了解它是什么，怎么来的，底层依赖哪些技术，能做什么，不能做什么，当前主流大模型产品在 AI 应用领域处于什么位置。否则只会在层出不穷的大模型产品中迷失方向，沦为行业“韭菜”。于是花了一些时间翻查资料，整理后有了本文。本文可以帮助你了解到底什么是大语言模型，什么是大模型，什么是 AI，它们之间到底是什么关系，人工智能到底在研究什么，AI 背后依赖哪些技术，了解这些有助于你厘清概念、消除误解、和警惕幻觉，进一步戳破认知泡沫、有的放矢地去探索大模型应用的边界、更好地应用好大模型工具去创造价值。</p><p><em>PS: 如有错漏之处请留言告诉我</em> :)</p></blockquote><a id="more"></a><h1 id="一、AI"><a href="#一、AI" class="headerlink" title="一、AI"></a>一、AI</h1><h2 id="什么是-AI"><a href="#什么是-AI" class="headerlink" title="什么是 AI"></a>什么是 AI</h2><p>AI：Artificial Intelligence，人工智能。人工智能是一个广泛的研究领域，旨在使机器能够模拟人类的智能行为，包括学习、推理、解决问题、感知环境、语言理解和生成等。</p><h2 id="AI-核心研究领域"><a href="#AI-核心研究领域" class="headerlink" title="AI 核心研究领域"></a>AI 核心研究领域</h2><h3 id="1-机器学习（Machine-Learning）"><a href="#1-机器学习（Machine-Learning）" class="headerlink" title="1. 机器学习（Machine Learning）"></a>1. 机器学习（Machine Learning）</h3><p><strong>目标</strong>：让计算机从数据中自动学习规律，实现预测或决策。</p><p><strong>分支</strong>：</p><ul><li>监督学习（如分类、回归，应用于图像识别、垃圾邮件过滤）。</li><li>无监督学习（如聚类、降维，用于数据挖掘、用户分群）。</li><li>强化学习（通过奖励机制优化行为，应用于机器人控制、游戏 AI、自动驾驶）。</li></ul><p><strong>关键技术</strong>：深度学习（Deep Learning，如卷积神经网络 CNN、循环神经网络 RNN）、生成对抗网络（GAN）、迁移学习等。</p><h3 id="2-自然语言处理（NLP-Natural-Language-Processing）"><a href="#2-自然语言处理（NLP-Natural-Language-Processing）" class="headerlink" title="2. 自然语言处理（NLP, Natural Language Processing）"></a>2. 自然语言处理（NLP, Natural Language Processing）</h3><p><strong>目标</strong>：实现人机间自然语言的理解与交互。</p><p><strong>研究方向</strong>：</p><ul><li>语言理解：分词、句法分析、语义角色标注。</li><li>语言生成：机器翻译、文本摘要、对话系统（如 ChatGPT）。</li><li>应用场景：智能客服、机器翻译、情感分析、知识图谱构建。</li></ul><h3 id="3-计算机视觉（CV-Computer-Vision）"><a href="#3-计算机视觉（CV-Computer-Vision）" class="headerlink" title="3. 计算机视觉（CV, Computer Vision）"></a>3. 计算机视觉（CV, Computer Vision）</h3><p><strong>目标</strong>：使计算机具备 “看” 和理解图像 / 视频的能力。</p><p><strong>核心任务</strong>：</p><ul><li>图像分类（如 ResNet 模型识别物体）。</li><li>目标检测与分割（YOLO 系列、Mask R-CNN）。</li><li>视频理解（动作识别、视频生成，如 Stable Diffusion）。</li></ul><p><strong>应用</strong>：自动驾驶、医学影像诊断、安防监控、AR/VR。</p><h3 id="4-机器人学（Robotics）"><a href="#4-机器人学（Robotics）" class="headerlink" title="4. 机器人学（Robotics）"></a>4. 机器人学（Robotics）</h3><p><strong>目标</strong>：设计具备感知、决策和执行能力的智能机器人。</p><p><strong>分支</strong>：</p><ul><li>感知机器人：通过传感器（视觉、触觉）感知环境（如波士顿动力机器人）。</li><li>自主机器人：路径规划、SLAM（同步定位与地图构建）、多机器人协作。</li><li>交叉领域：人机交互、仿生机器人、医疗机器人。</li></ul><h3 id="5-知识表示与推理（Knowledge-Representation-and-Reasoning）"><a href="#5-知识表示与推理（Knowledge-Representation-and-Reasoning）" class="headerlink" title="5. 知识表示与推理（Knowledge Representation and Reasoning）"></a>5. 知识表示与推理（Knowledge Representation and Reasoning）</h3><p><strong>目标</strong>：将人类知识结构化，支持机器推理和决策。</p><p><strong>方法</strong>：</p><ul><li>逻辑表示（如一阶谓词逻辑、描述逻辑）。</li><li>语义网络与知识图谱（如 Google 知识图谱、医疗知识图谱）。</li></ul><p><strong>应用</strong>：专家系统（如医疗诊断系统）、自动定理证明、常识推理。</p><h3 id="6-伦理与社会影响（AI-Ethics-and-Society）"><a href="#6-伦理与社会影响（AI-Ethics-and-Society）" class="headerlink" title="6. 伦理与社会影响（AI Ethics and Society）"></a>6. 伦理与社会影响（AI Ethics and Society）</h3><p><strong>目标</strong>：研究 AI 的社会、法律和伦理问题，确保技术可控。</p><p><strong>核心议题</strong>：</p><ul><li>公平性：算法偏见（如招聘歧视、人脸识别偏差）。</li><li>可解释性（XAI）：深度学习模型的透明性与可解释性。</li><li>隐私保护：数据安全与合规（如 GDPR 对 AI 的影响）。</li><li>就业与经济影响：自动化对劳动力市场的冲击与转型。</li></ul><h2 id="AI-三大流派"><a href="#AI-三大流派" class="headerlink" title="AI 三大流派"></a>AI 三大流派</h2><h3 id="1-符号主义（Symbolism）"><a href="#1-符号主义（Symbolism）" class="headerlink" title="1. 符号主义（Symbolism）"></a>1. 符号主义（Symbolism）</h3><p>又称逻辑主义、心理学派或计算机学派，认为人工智能源于数理逻辑。其基本假设是物理符号系统假设，即人类认知和思维的基本单元是符号，认知过程是符号运算。符号主义奠定了人工智能基于逻辑推理的基础，在早期取得了显著成果，但在处理常识和不确定性问题上遇到困难。</p><h3 id="2-连接主义（Connectionism）"><a href="#2-连接主义（Connectionism）" class="headerlink" title="2. 连接主义（Connectionism）"></a>2. 连接主义（Connectionism）</h3><p>核心思想是通过模拟生物神经网络的结构和工作机制来实现智能。从仿生学角度出发，通过对神经网络的研究实现了深度学习的突破，在众多领域展现出强大的能力。连接主义认为，智能的本质是分布式信息处理和自适应学习，而非符号主义（Symbolism）所强调的规则逻辑或行为主义（Behaviorism）的<code>刺激 - 反应</code>模式。</p><h3 id="3-行为主义（Symbolism）"><a href="#3-行为主义（Symbolism）" class="headerlink" title="3. 行为主义（Symbolism）"></a>3. 行为主义（Symbolism）</h3><p>行为主义认为人工智能可以用控制论的理论基础进行实现。其思想根源可以追溯到早期对动物和人类行为的研究，强调智能体与环境的交互作用。控制论的发展为行为主义提供了理论支持，使得研究者们开始从行为控制的角度探索人工智能的实现方式。 在机器人领域，行为主义得到了广泛应用。</p><h4 id="表1"><a href="#表1" class="headerlink" title="表1"></a>表1</h4><table><thead><tr><th>学派</th><th>核心假设</th><th>代表技术</th><th>典型应用</th></tr></thead><tbody><tr><td><strong>符号主义</strong></td><td>智能源于逻辑推理与符号系统</td><td>专家系统、逻辑编程</td><td>知识图谱、定理证明</td></tr><tr><td><strong>连接主义</strong></td><td>智能源于神经网络的连接机制</td><td>深度学习、神经网络</td><td>图像识别、自然语言处理</td></tr><tr><td><strong>行为主义</strong></td><td>智能源于自适应行为与环境交互</td><td>强化学习、进化算法</td><td>机器人控制、游戏 AI（如 AlphaGo）</td></tr></tbody></table><h2 id="AI-发展历程"><a href="#AI-发展历程" class="headerlink" title="AI 发展历程"></a>AI 发展历程</h2><h3 id="1、孕育期（1940s-1956-年）：从数理逻辑到智能设想"><a href="#1、孕育期（1940s-1956-年）：从数理逻辑到智能设想" class="headerlink" title="1、孕育期（1940s-1956 年）：从数理逻辑到智能设想"></a>1、孕育期（1940s-1956 年）：从数理逻辑到智能设想</h3><p><strong>核心特征</strong>：理论奠基与思想萌芽</p><ul><li>1936 年，图灵提出 “图灵机” 模型，奠定计算机可计算性理论基础；1943 年，McCulloch 和 Pitts 提出人工神经元模型，模拟生物神经网络的逻辑单元。</li><li>1948 年，维纳《控制论》提出 “机器与生物的信息处理共性”，为智能系统提供哲学启发。</li><li>1950 年，图灵发表《计算机器与智能》，提出 “图灵测试”，成为判断机器智能的标准；同年，香农设计国际象棋程序，开启机器博弈研究。</li><li>1955 年，纽厄尔和西蒙开发 “逻辑理论家”（LT）程序，证明《数学原理》中的 38 条定理，首次展现符号系统的推理能力。</li></ul><h3 id="2、诞生与黄金年代（1956-1974-年）：符号主义主导的乐观主义"><a href="#2、诞生与黄金年代（1956-1974-年）：符号主义主导的乐观主义" class="headerlink" title="2、诞生与黄金年代（1956-1974 年）：符号主义主导的乐观主义"></a>2、诞生与黄金年代（1956-1974 年）：符号主义主导的乐观主义</h3><p>1956 年，达特茅斯会议，麦卡锡、明斯基等学者首次提出 “人工智能” 术语，确立研究目标：用机器模拟人类学习、推理和问题解决能力。美国国防部高级研究计划局（DARPA）等机构大幅资助，公众期待 “20 年内机器能完成人类所有智力工作”，但忽视了复杂问题（如常识推理、自然语言理解）的难度。</p><p><strong>核心特征</strong>：学科正式诞生，符号逻辑与专家系统兴起</p><p><strong>关键技术方向</strong>：</p><ul><li>符号主义（逻辑学派）：认为智能源于符号逻辑推理，代表成果包括：<ul><li>1959 年，塞缪尔开发跳棋程序，通过机器学习超越人类水平。</li><li>1965 年，鲁宾逊提出归结原理，为自动定理证明奠定基础。</li><li>1965 年，费根鲍姆开发首个专家系统 DENDRAL（化学质谱分析），标志 “知识工程” 诞生。</li></ul></li><li>连接主义（神经网络学派）：<ul><li>早期探索受限于计算能力，代表性工作为 1958 年罗森布拉特提出 “感知机”，但 1969 年明斯基《感知机》一书指出其理论局限性，导致该方向陷入停滞。</li></ul></li></ul><h3 id="3、第一次寒冬（1974-1980-年）：期望破灭与资金退潮"><a href="#3、第一次寒冬（1974-1980-年）：期望破灭与资金退潮" class="headerlink" title="3、第一次寒冬（1974-1980 年）：期望破灭与资金退潮"></a>3、第一次寒冬（1974-1980 年）：期望破灭与资金退潮</h3><p><strong>核心特征</strong>：理论瓶颈与产业挫折</p><ul><li>符号系统在 “常识推理”（如理解 “椅子是用来坐的”）和 “组合爆炸” 问题上举步维艰。</li><li>神经网络因计算能力不足和理论缺陷（如无法训练多层网络）被边缘化。</li><li>机器翻译早期成果（如 1954 年 IBM 的英俄翻译演示）暴露语义理解不足，美国政府 1966 年发布《ALPAC 报告》否定机器翻译可行性，导致项目大规模撤资。</li><li>资金缩减：DARPA 取消对通用问题求解器（GPS）等项目的资助，英国政府 1973 年《莱特希尔报告》批评人工智能 “夸大承诺”，学界进入低潮。</li></ul><h3 id="4、专家系统与知识工程复兴（1980-1987-年）：符号主义的第二次浪潮"><a href="#4、专家系统与知识工程复兴（1980-1987-年）：符号主义的第二次浪潮" class="headerlink" title="4、专家系统与知识工程复兴（1980-1987 年）：符号主义的第二次浪潮"></a>4、专家系统与知识工程复兴（1980-1987 年）：符号主义的第二次浪潮</h3><p><strong>背景</strong>：微处理器的进步，计算机性能有所提升</p><p><strong>核心特征</strong>：限定领域的实用化突破，专家系统商业化</p><ul><li>1976 年，Shortliffe 开发医疗诊断系统 MYCIN，准确率超人类专家。</li><li>1980 年，DEC 公司的 XCON 系统用于计算机配置，每年节省数千万美元。</li><li>日本 1981 年启动 “第五代计算机计划”，目标是开发基于逻辑程序设计的智能计算机，虽未完全成功，但推动了硬件与软件协同发展。</li><li>知识表示革命：框架理论（Minsky, 1974）、语义网络等技术被用于结构化知识建模，“知识工程师” 成为新兴职业。</li><li>局限性显现：专家系统依赖人工编码知识，难以扩展至复杂场景，且缺乏学习能力，被批评为 “昂贵的手工制品”。</li></ul><h3 id="5、第二次寒冬（1987-1997-年）：符号系统的崩塌与统计学习崛起"><a href="#5、第二次寒冬（1987-1997-年）：符号系统的崩塌与统计学习崛起" class="headerlink" title="5、第二次寒冬（1987-1997 年）：符号系统的崩塌与统计学习崛起"></a>5、第二次寒冬（1987-1997 年）：符号系统的崩塌与统计学习崛起</h3><p><strong>背景</strong>：计算机性能进一步提升，数据量增长</p><p><strong>核心特征</strong>：符号主义衰退，数据驱动方法悄然兴起</p><p><strong>符号系统的困境：</strong></p><ul><li>1987 年，Lisp 机器市场崩溃（Symbolics 等公司破产），标志符号主义商业路径失败；</li><li>逻辑 - based 系统（如 Cyc 项目）试图构建人类常识知识库，但工程规模远超预期。</li></ul><p><strong>统计学习的曙光：</strong></p><ul><li>1986 年，Rumelhart 等重新提出反向传播算法（BP 算法），解决多层神经网络训练问题，掀起连接主义复兴。</li><li>1995 年，Vapnik 提出支持向量机（SVM），在小数据场景下表现优于神经网络，成为机器学习主流。</li><li>自然语言处理领域，Chomsky 的句法理论遭遇挑战，统计机器翻译（如 IBM 的 Candide 项目）凭借大规模语料库展现实用性。</li><li>标志性事件：1997 年，IBM 深蓝击败国际象棋世界冠军卡斯帕罗夫，虽依赖暴力搜索而非真正智能，但证明 “有限领域可计算性” 的价值。</li></ul><h3 id="6、深度学习革命（1998-2018-年）：从感知到认知的跨越"><a href="#6、深度学习革命（1998-2018-年）：从感知到认知的跨越" class="headerlink" title="6、深度学习革命（1998-2018 年）：从感知到认知的跨越"></a>6、深度学习革命（1998-2018 年）：从感知到认知的跨越</h3><p><strong>背景</strong>：互联网普及，计算机性能大幅提高，大数据算力提升</p><p><strong>核心特征</strong>：神经网络卷土重来，大数据与算力驱动突破</p><p><strong>技术突破：</strong></p><ul><li>1998 年，LeCun 提出卷积神经网络（CNN），应用于手写数字识别（MNIST 数据集），奠定计算机视觉基础。</li><li>2006 年，Hinton 提出 “深度信念网络”（DBN），通过逐层预训练解决深层网络优化难题，“深度学习” 成为独立领域。</li><li>2013 年，Word2Vec（Mikolov）将词语映射为向量空间，开启自然语言处理的分布式表示时代。</li><li>2017 年，Vaswani 等提出 Transformer 架构，通过自注意力机制解决长序列依赖问题，成为大语言模型的基石。</li><li>2018 年，BERT（Google）和 GPT（OpenAI）开启预训练模型时代，通用语言理解能力显著提升。</li></ul><p><strong>产业爆发：</strong></p><ul><li>2012 年，AlexNet（Hinton 团队）在 ImageNet 图像识别中准确率远超传统方法，引发视觉领域全面转向深度学习。</li><li>2016 年，AlphaGo 击败围棋世界冠军李世石，展示强化学习与神经网络的结合威力。</li><li>2018 年，BERT（Google）和 GPT（OpenAI）开启预训练模型时代，通用语言理解能力显著提升。</li></ul><h3 id="7、大模型与通用智能探索（2019-年至今）：从专用到通用的跃迁"><a href="#7、大模型与通用智能探索（2019-年至今）：从专用到通用的跃迁" class="headerlink" title="7、大模型与通用智能探索（2019 年至今）：从专用到通用的跃迁"></a>7、大模型与通用智能探索（2019 年至今）：从专用到通用的跃迁</h3><p><strong>核心特征</strong>：超大规模预训练模型涌现，多模态与具身智能成为新方向</p><p><strong>大语言模型（LLM）的统治力：</strong></p><ul><li>2020 年，GPT-3（1750 亿参数）通过 “少样本学习” 展现通用任务能力，引发 “提示工程” 新范式。</li><li>2023 年，GPT-4、Claude 2、LLaMA 等模型突破逻辑推理、代码生成、多语言理解等能力，ChatGPT 用户量两个月破亿，标志 AI 进入消费级应用阶段。</li><li>2025 年，DeepSeek R1 发布，采用 MoE 架构，训练成本仅为 GPT-4 的 1/70，推理成本降低至 1/30，推动 AI 大规模商用。</li></ul><p><strong>多模态与具身智能：</strong></p><ul><li>模型融合文本、图像、语音、视频等多模态数据，如 DALL・E（文本生成图像）、Sora（文本生成视频）。</li><li>具身智能（Embodied AI）探索机器人与环境互动，如 Google 的 SayCan、DeepMind 的 RoboCat，试图解决 “感知 - 决策 - 行动” 闭环。</li></ul><p><strong>社会与伦理挑战：</strong></p><p>生成式 AI 引发内容安全（深度伪造）、偏见公平、隐私泄露等争议，各国加速制定 AI 治理政策（如欧盟《AI 法案》）。</p><h3 id="螺旋上升的智能进化史"><a href="#螺旋上升的智能进化史" class="headerlink" title="螺旋上升的智能进化史"></a>螺旋上升的智能进化史</h3><p>人工智能的发展始终遵循 “期望 - 泡沫 - 低谷 - 突破” 的循环，从早期符号逻辑的 “自上而下” 范式，到深度学习的 “自下而上” 数据驱动，再到大模型试图融合知识与统计的 “第三条道路”，每一次转折都伴随着方法论的革新。如今，我们站在 “通用人工智能（AGI）” 的门槛前，尽管距离人类水平智能仍有鸿沟，但大模型已掀开了 “机器辅助人类认知” 的新篇章。未来的关键挑战将集中于可解释性、常识推理、能源效率和伦理治理，这些议题不仅是技术问题，更需要跨学科的智慧与全球协作。</p><h1 id="二、大模型"><a href="#二、大模型" class="headerlink" title="二、大模型"></a>二、大模型</h1><h2 id="什么是大模型"><a href="#什么是大模型" class="headerlink" title="什么是大模型"></a>什么是大模型</h2><p>大模型（Large Models） 是指通过海量数据训练、拥有庞大参数规模（通常预训练模型参数规模超十亿），并具备强大泛化能力和复杂任务处理能力的人工智能模型。其核心特点是通过深度学习架构（如 Transformer）和大规模预训练，实现对自然语言、图像、语音等多模态数据的理解与生成。</p><h2 id="大模型与-AI-的关系"><a href="#大模型与-AI-的关系" class="headerlink" title="大模型与 AI 的关系"></a>大模型与 AI 的关系</h2><p>大模型属于人工智能中机器学习和深度学习的范畴，是机器学习技术的高阶形态，一种基于大规模数据和强大计算能力构建的复杂模型架构，通过学习海量的数据来捕捉数据中的模式和规律，从而实现对各种任务的处理和优化，如自然语言处理（NLP）、图像识别 （CV）、语音识别等，深度融合并推动 NLP、CV、机器人学等应用领域的发展。</p><h2 id="大模型与传统-AI-的区别"><a href="#大模型与传统-AI-的区别" class="headerlink" title="大模型与传统 AI 的区别"></a>大模型与传统 AI 的区别</h2><h3 id="表2"><a href="#表2" class="headerlink" title="表2"></a>表2</h3><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">大模型</th><th style="text-align:left">传统 AI</th></tr></thead><tbody><tr><td style="text-align:left"><strong>数据依赖</strong></td><td style="text-align:left">依赖海量通用数据（少样本或零样本）</td><td style="text-align:left">依赖特定任务标注数据</td></tr><tr><td style="text-align:left"><strong>能力边界</strong></td><td style="text-align:left">跨领域泛化（文本、图像、代码等）</td><td style="text-align:left">单一任务（如图像分类）</td></tr><tr><td style="text-align:left"><strong>开发模式</strong></td><td style="text-align:left">预训练 + 提示词工程</td><td style="text-align:left">工设计特征 + 模型调参</td></tr><tr><td style="text-align:left"><strong>迭代方式</strong></td><td style="text-align:left">通用能力升级驱动多任务提升</td><td style="text-align:left">逐个任务优化</td></tr></tbody></table><h2 id="大模型技术架构对比"><a href="#大模型技术架构对比" class="headerlink" title="大模型技术架构对比"></a>大模型技术架构对比</h2><h3 id="表3"><a href="#表3" class="headerlink" title="表3"></a>表3</h3><table><thead><tr><th>架构类型</th><th>代表模型/技术</th><th>核心优势</th><th>典型应用场景</th></tr></thead><tbody><tr><td><strong>Transformer</strong></td><td>GPT-4、ViT</td><td>多任务通用性强</td><td>文本生成、图像分类</td></tr><tr><td><strong>MoE</strong></td><td>DeepSeek-R1</td><td>高性价比推理</td><td>企业级服务、高频交易</td></tr><tr><td><strong>扩散模型</strong></td><td>Stable Diffusion 3</td><td>高保真生成</td><td>艺术创作、影视特效</td></tr><tr><td><strong>稀疏激活</strong></td><td>Mixture of Depths</td><td>资源动态分配</td><td>边缘设备、长文本处理</td></tr><tr><td><strong>多模态融合</strong></td><td>Gemini</td><td>跨模态协同推理</td><td>智能客服、医疗影像</td></tr><tr><td><strong>具身智能</strong></td><td>Tesla Optimus</td><td>物理世界交互</td><td>机器人控制、自动驾驶</td></tr></tbody></table><h2 id="主流大模型产品对比分析"><a href="#主流大模型产品对比分析" class="headerlink" title="主流大模型产品对比分析"></a>主流大模型产品对比分析</h2><h3 id="表4"><a href="#表4" class="headerlink" title="表4"></a>表4</h3><table><thead><tr><th>模型名称</th><th>公司/机构</th><th>技术架构</th><th>模态支持</th><th>典型应用场景</th><th>幻觉控制策略</th><th>开源策略</th><th>参数量级</th></tr></thead><tbody><tr><td><strong>ChatGPT</strong></td><td>OpenAI</td><td>Transformer</td><td>文本 → 多模态扩展</td><td>对话、代码生成</td><td>RLHF + 自训练纠错</td><td>闭源</td><td>重量级（千亿）</td></tr><tr><td><strong>DeepSeek</strong></td><td>深度求索</td><td>MoE</td><td>文本</td><td>对话、企业推理、数学问题解决、代码生成</td><td>知识验证器+置信度校准</td><td>全开源</td><td>中量级</td></tr><tr><td><strong>文心一言</strong></td><td>百度</td><td>Transformer</td><td>文本</td><td>问答、文本生成</td><td>知识图谱约束 + PPL 筛选</td><td>闭源</td><td>重量级</td></tr><tr><td><strong>通义千问</strong></td><td>阿里巴巴</td><td>Transformer</td><td>多模态</td><td>对话、电商客服、医疗问答</td><td>多模态对齐损失 + 对抗训练</td><td>闭源</td><td>重量级</td></tr><tr><td><strong>混元</strong></td><td>腾讯</td><td>MoE + Transformer</td><td>多模态</td><td>对话、复杂任务处理、3D 生成</td><td>知识蒸馏+多专家辩论框架</td><td>核心全开源+服务半开源+部分闭源</td><td>重量级</td></tr><tr><td><strong>Claude</strong></td><td>Anthropic</td><td>双模式架构</td><td>多模态</td><td>法律文本分析、科研文献</td><td>宪法 AI + 递归验证机制</td><td>闭源</td><td>重量级</td></tr><tr><td><strong>Kimi</strong></td><td>月之暗面</td><td>分离式推理架构</td><td>文本</td><td>文档分析、知识库构建</td><td>长上下文注意力缓存压缩</td><td>闭源</td><td>中量级</td></tr><tr><td><strong>Gemini</strong></td><td>Google</td><td>原生多模态架构</td><td>多模态</td><td>对话、医疗影像诊断、跨媒体生成</td><td>跨模态一致性验证</td><td>闭源</td><td>重量级</td></tr><tr><td><strong>豆包</strong></td><td>字节跳动</td><td>稀疏 MoE</td><td>多模态</td><td>对话、语音交互、智能家居</td><td>语音-文本联合推理阈值过滤</td><td>半开源</td><td>中量级</td></tr><tr><td><strong>Grok</strong></td><td>xAI (Elon Musk)</td><td>混合架构</td><td>文本</td><td>实时数据分析、专业领域问答</td><td>实时知识检索 + 概率截断</td><td>闭源 → 计划开源</td><td>重量级</td></tr><tr><td><strong>LLaMA</strong></td><td>Meta (原 Facebook)</td><td>Transformer</td><td>文本</td><td>学术研究、低成本开发</td><td>采样后处理（Nucleus Sampling）</td><td>全开源</td><td>轻量级-中量级</td></tr><tr><td><strong>讯飞星火</strong></td><td>科大讯飞</td><td>1+N 架构</td><td>文本 → 多模态扩展</td><td>教育辅导、医疗咨询</td><td>领域知识图谱辅助</td><td>闭源</td><td>中量级</td></tr><tr><td><strong>智普 AI（GLM）</strong></td><td>智谱 AI（清华系）</td><td>GLM 架构</td><td>文本</td><td>工业质检、代码辅助</td><td>分层解码约束 + 语义相似度检测</td><td>半开源</td><td>重量级</td></tr><tr><td><strong>百川智能</strong></td><td>百川智能（王小川）</td><td>轻量级蒸馏</td><td>文本</td><td>金融风控、医疗咨询</td><td>轻量级模型蒸馏优化</td><td>半开源</td><td>轻量级</td></tr></tbody></table><h2 id="大模型发展历程"><a href="#大模型发展历程" class="headerlink" title="大模型发展历程"></a>大模型发展历程</h2><p>AI 大模型技术出现于 2017 年左右，其发展历程如下：</p><h3 id="1-技术基础与早期探索（1950s-2016-年）："><a href="#1-技术基础与早期探索（1950s-2016-年）：" class="headerlink" title="1. 技术基础与早期探索（1950s - 2016 年）："></a>1. 技术基础与早期探索（1950s - 2016 年）：</h3><ul><li>1956 年人工智能概念诞生。</li><li>1957 年感知机出现，为早期神经网络雏形。</li><li>1974 年反向传播算法被提出，为神经网络优化提供理论支持。</li><li>1993 年深度学习理论基础开始形成。</li><li>2012 年 AlexNet 在图像识别竞赛中获胜，推动深度学习发展。</li><li>2014 年 Seq2Seq 模型和注意力机制被提出，促进自然语言处理领域发展。这一阶段神经网络基础理论得到发展，但模型规模较小，参数在百万级。</li></ul><h3 id="2-大模型发展期（2017-年-至今）："><a href="#2-大模型发展期（2017-年-至今）：" class="headerlink" title="2. 大模型发展期（2017 年 - 至今）："></a>2. 大模型发展期（2017 年 - 至今）：</h3><ul><li>2017 年：Transformer 架构诞生，引入自注意力机制，解决长程依赖问题，奠定了大模型技术基础。</li><li>2018 年：BERT 和 GPT-1 分别发布，标志着预训练模型时代的正式开启。</li><li>2019 年：OpenAI 发布 GPT-2，参数规模达到 15 亿，生成式模型潜力被广泛认可。</li><li>2020 年：GPT-3 发布，参数规模达到 1750 亿，成为当时最大的语言模型，在零样本学习任务上有巨大性能提升。</li><li>2022 年：ChatGPT 发布，基于 GPT-3.5 架构的对话模型迅速引爆全球，用户数突破 1 亿仅用 2 个月，推动 AI 从“工具”向“助手”转变。</li><li>2023 年：多模态大模型如 GPT-4V、Gemini Pro 等相继推出，AI 进入全新发展阶段，大模型支持的模态更加多样，从单一模态下的单一任务，逐渐发展为支持多种模态下的多种任务。</li><li>2025 年：DeepSeek R1 发布，采用 MoE 架构，训练成本仅为 GPT-4 的 1/70，推理成本降低至 1/30，用户数突破 1 亿仅用了 7 天，推动 AI 大规模商用。</li></ul><h2 id="大模型发展方向"><a href="#大模型发展方向" class="headerlink" title="大模型发展方向"></a>大模型发展方向</h2><h3 id="1-模型轻量化"><a href="#1-模型轻量化" class="headerlink" title="1. 模型轻量化"></a>1. 模型轻量化</h3><p>   通过知识蒸馏（如 TinyBERT）、量化压缩（8bit 训练）等技术，减少模型参数和计算量，提高模型运行效率，使其能在资源受限的设备上运行。</p><h3 id="2-多模态融合"><a href="#2-多模态融合" class="headerlink" title="2. 多模态融合"></a>2. 多模态融合</h3><p>   实现文本、图像、视频、3D 模型等多模态数据的统一表征学习，让模型能更全面地理解和处理复杂信息，更贴近人类的多模态交互方式，拓展人工智能的应用场景。</p><h3 id="3-具身智能"><a href="#3-具身智能" class="headerlink" title="3. 具身智能"></a>3. 具身智能</h3><p>   将大模型与机器人等实体系统相结合，如 Tesla Optimus 机器人结合大模型实现环境交互与决策，使智能体能够在真实世界中感知、行动和学习，完成各种复杂任务。</p><h3 id="4-生物计算"><a href="#4-生物计算" class="headerlink" title="4. 生物计算"></a>4. 生物计算</h3><p>   探索 DNA 存储技术与类脑计算架构的融合，借鉴生物大脑的信息处理机制，为大模型的发展提供新的思路和架构，可能带来计算能力和能效方面的突破。</p><h1 id="三、大语言模型"><a href="#三、大语言模型" class="headerlink" title="三、大语言模型"></a>三、大语言模型</h1><h2 id="什么是大语言模型"><a href="#什么是大语言模型" class="headerlink" title="什么是大语言模型"></a>什么是大语言模型</h2><p>大语言模型（LLM）：基于海量文本数据训练的深度学习模型（如 GPT、LLaMA、BLOOM），学习语言规律、语义关联和世界知识，通过 Transformer 架构实现上下文理解与生成，核心能力包括语义建模、知识推理和长文本处理。</p><p>其他相关概念：</p><ul><li><strong>预训练（Pre-training）</strong>：在通用数据上训练模型基础能力。</li><li><strong>微调（Fine-tuning）</strong>：针对特定任务（如翻译、问答）优化模型参数。</li><li><strong>提示工程（Prompt Engineering）</strong>：通过设计输入指令提升模型输出质量。</li></ul><h2 id="大语言模型的核心能力"><a href="#大语言模型的核心能力" class="headerlink" title="大语言模型的核心能力"></a>大语言模型的核心能力</h2><h3 id="1-自然语言理解（NLU）"><a href="#1-自然语言理解（NLU）" class="headerlink" title="1.  自然语言理解（NLU）"></a>1.  自然语言理解（NLU）</h3><ul><li>解析语法结构、语义角色（如 “谁对谁做了什么”）。</li><li>识别情感倾向（如评论中的正面 / 负面情绪）、实体关系（如 “爱因斯坦 — 科学家”）。</li></ul><h3 id="2-自然语言生成（NLG）"><a href="#2-自然语言生成（NLG）" class="headerlink" title="2.  自然语言生成（NLG）"></a>2.  自然语言生成（NLG）</h3><ul><li>创作连贯文本：小说、新闻、代码、邮件等。</li><li>多风格生成：模仿特定语气（如正式公文、幽默段子）。</li></ul><h3 id="3-推理与问题解决"><a href="#3-推理与问题解决" class="headerlink" title="3.  推理与问题解决"></a>3.  推理与问题解决</h3><ul><li>常识推理：回答 “为什么冬天会下雪” 等日常问题。</li><li>逻辑推理：解决数学题（如 GPT-4 通过 GRE 数学部分测试）、编程调试（如 GitHub Copilot）。</li></ul><h3 id="4-对话交互"><a href="#4-对话交互" class="headerlink" title="4.  对话交互"></a>4.  对话交互</h3><ul><li>上下文记忆：支持多轮对话（如 ChatGPT 支持数百轮历史对话）。</li><li>角色模拟：扮演医生、教师、虚拟助手等特定角色。</li></ul><h2 id="大语言模型与大模型的关系"><a href="#大语言模型与大模型的关系" class="headerlink" title="大语言模型与大模型的关系"></a>大语言模型与大模型的关系</h2><p>大语言模型（LLM）是大模型（LM）的一个重要分支，是以自然语言（文本）为核心处理对象的超大规模人工智能模型。掌握 LLMs 是理解大模型生态的基石，后续可向多模态、具身智能等方向延伸。</p><h2 id="大语言模型与大模型关键技术差异"><a href="#大语言模型与大模型关键技术差异" class="headerlink" title="大语言模型与大模型关键技术差异"></a>大语言模型与大模型关键技术差异</h2><h3 id="表5"><a href="#表5" class="headerlink" title="表5"></a>表5</h3><table><thead><tr><th>维度</th><th>大语言模型</th><th>大模型</th></tr></thead><tbody><tr><td><strong>架构基础</strong></td><td>纯 Transformer 架构为主</td><td>Transformer/CNN/MoE 混合</td></tr><tr><td><strong>训练数据</strong></td><td>纯文本语料库（如 Common Crawl）</td><td>多模态数据集（文本+图像+传感器数据）</td></tr><tr><td><strong>输出形式</strong></td><td>文本/代码</td><td>跨模态内容（如文生视频）</td></tr><tr><td><strong>典型任务</strong></td><td>机器翻译、情感分析</td><td>自动驾驶路径规划、蛋白质结构预测</td></tr></tbody></table><h2 id="如何掌握大语言模型：从工具使用者到价值创造者"><a href="#如何掌握大语言模型：从工具使用者到价值创造者" class="headerlink" title="如何掌握大语言模型：从工具使用者到价值创造者"></a>如何掌握大语言模型：从工具使用者到价值创造者</h2><ul><li>掌握大语言模型：理解 Transformer 架构、注意力机制、Prompt 工程。</li><li>掌握大语言模型的关键在于：先理解其 “能做什么” 和 “不能做什么”，再聚焦具体场景设计解决方案。对于非技术背景者，可从提示工程和 API 调用切入，快速实现效率提升；技术人员则可深入模型微调与底层优化，探索行业专属应用。</li><li>理性看待模型能力：LLM 擅长模式匹配而非真正理解，复杂逻辑推理、高风险、强专业性、伦理敏感或需要深度人类判断的领域，仍需人类介入，避免过度依赖导致决策失误。</li><li>最终，大语言模型的价值不在于 “替代人类”，而在于作为倍增器，放大个体与组织的创造力。持续学习、结合领域知识、保持理性批判思维，才能在这场技术变革中占据主动。</li></ul><p><span style="font-weight: bold;color: #902626"></span></p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>一张图表示人工智能、大模型、大语言模型之间的关系<br><img src="/images/AI、LM、LLM.png" alt="ai2.png"></p><h1 id="推荐论文："><a href="#推荐论文：" class="headerlink" title="推荐论文："></a>推荐论文：</h1><p>[1] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. <a href="https://arxiv.org/pdf/1706.03762" target="_blank" rel="noopener">Attention Is All You Need</a>. arXiv preprint arXiv:1706.03762, 2017.</p><p>[2] Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Brian Ichter, Fei Xia, Ed Chi, Quoc Le, and Denny Zhou. <a href="https://arxiv.org/pdf/2201.11903" target="_blank" rel="noopener">Chain-of-Thought Prompting Elicits Reasoning in Large Language Models</a>. arXiv preprint arXiv:2201.11903, 2022.</p><p>[3] Yue Zhang, Yafu Li, Leyang Cui, Deng Cai, Lemao Liu, Tingchen Fu, Xinting Huang, Enbo Zhao, Yu Zhang, Yulong Chen, Longyue Wang, Anh Tuan Luu, Wei Bi, Freda Shi, and Shuming Shi. <a href="https://arxiv.org/pdf/2309.01219" target="_blank" rel="noopener">Siren’s Song in the AI Ocean- A Survey on Hallucination in Large Language Models</a>. arXiv preprint arXiv:2309.01219, 2023.</p><p><br></p><p>文章同时发表于公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中的正则表达式</title>
      <link href="/2023/03/09/JS%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/03/09/JS%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在计算机语言中，正则表达模式匹配是非常高效的字符串处理方式。我们在进行字符串处理的时候，比如表单校验、url参数获取、文本预编译处理，多端跨端转译等等，都少不了跟正则表达式打交道。但由于正则表达的语法规则比较抽象，如果平常不经常接触，一旦要用，就得好一番查找资料。但是网上的资料很多都太零散，为方便以后高效查看，略系统地整理如下。</p></blockquote><a id="more"></a><h1 id="一、什么是正则表达式"><a href="#一、什么是正则表达式" class="headerlink" title="一、什么是正则表达式"></a>一、什么是正则表达式</h1><p>正则表达式（Regular Expression），是一串特殊的字符串，用来描述一组字符串的规律和规则。正则表达式可用于验证、检索、匹配、替换文本字符串。</p><h1 id="二、正则表达式的简要发展史"><a href="#二、正则表达式的简要发展史" class="headerlink" title="二、正则表达式的简要发展史"></a>二、正则表达式的简要发展史</h1><ul><li>在对人类神经系统的早期研究中，科学家 Warren McCulloch 和 Walter Pitts 研究出了一种用数学方式来描述神经网络的新方法。</li><li>1951年, 数学科学家 Stephen Kleene，在他的《神经网事件的表示法》的论文中，利用称之为正则集合的数学符号来描述上述模型，引入了正则表达式的概念。</li><li>自此以后，正则表达式被广泛地应用到各种 UNIX 或类似于 UNIX 的工具中。</li><li>正则表达式在各种计算机语言和应用领域得到了广大的应用和发展。</li></ul><h1 id="三、正则引擎"><a href="#三、正则引擎" class="headerlink" title="三、正则引擎"></a>三、正则引擎</h1><p>正则引擎可以让正则表达式得以工作。主流的正则引擎分为3类：</p><ul><li>DFA：确定型有穷自动机(Deterministic finite automaton, DFA)</li><li>传统型NFA：非确定型有穷自动机(Non-deterministic finite automaton, NFA)</li><li>POSIX NFA：由于DFA和传统型NFA这两种引擎产生了很多变体，为了规避不必要变体的继续产生，出台了POSIX</li></ul><h1 id="四-、正则表达式语法"><a href="#四-、正则表达式语法" class="headerlink" title="四 、正则表达式语法"></a>四 、正则表达式语法</h1><p>正则表达式语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/pattern/flags</span><br></pre></td></tr></table></figure></p><ul><li>pattern部分由普通字符以及特殊字符（也被称为”元字符”）组成。</li><li>flags部分非必填</li></ul><h2 id="4-1-普通字符"><a href="#4-1-普通字符" class="headerlink" title="4.1 普通字符"></a>4.1 普通字符</h2><p>没有显式指定为元字符的所有可打印和不可打印字符。包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><h2 id="4-2-特殊字符-元字符"><a href="#4-2-特殊字符-元字符" class="headerlink" title="4.2 特殊字符(元字符)"></a>4.2 特殊字符(元字符)</h2><h3 id=""><a href="#" class="headerlink" title="\"></a>\</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">依照下列规则匹配：</span><br><span class="line"></span><br><span class="line">在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 &quot;\&quot; 的 &quot;b&quot; 通常匹配小写字母 &quot;b&quot;，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 &quot;\&quot;，它将不再匹配任何字符，而是表示一个字符边界。</span><br><span class="line"></span><br><span class="line">在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 &quot;转义（Escaping）&quot; 部分。</span><br><span class="line"></span><br><span class="line">如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。/[a-z]\s/i 和 new RegExp(&quot;[a-z]\\s&quot;, &quot;i&quot;) 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（\s 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如 /[a-z]:\\/i 和 new RegExp(&quot;[a-z]:\\\\&quot;,&quot;i&quot;) 会创建相同的表达式，即匹配类似 &quot;C:\&quot; 字符串。</span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="^"></a>^</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。</span><br><span class="line"></span><br><span class="line">例如，/^A/ 并不会匹配 &quot;an A&quot; 中的 &apos;A&apos;，但是会匹配 &quot;An E&quot; 中的 &apos;A&apos;。</span><br><span class="line">当 &apos;^&apos; 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。反向字符集合 一节有详细介绍和示例。</span><br></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title="$"></a>$</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。</span><br><span class="line"></span><br><span class="line">例如，/t$/ 并不会匹配 &quot;eater&quot; 中的 &apos;t&apos;，但是会匹配 &quot;eat&quot; 中的 &apos;t&apos;。</span><br></pre></td></tr></table></figure><h3 id="-3"><a href="#-3" class="headerlink" title="*"></a>*</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配前一个表达式 0 次或多次。等价于 &#123;0,&#125;。</span><br><span class="line"></span><br><span class="line">例如，/bo*/ 会匹配 &quot;A ghost boooooed&quot; 中的 &apos;booooo&apos; 和 &quot;A bird warbled&quot; 中的 &apos;b&apos;，但是在 &quot;A goat grunted&quot; 中不会匹配任何内容。</span><br></pre></td></tr></table></figure><h3 id="-4"><a href="#-4" class="headerlink" title="+"></a>+</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配前面一个表达式 1 次或者多次。等价于 &#123;1,&#125;。</span><br><span class="line"></span><br><span class="line">例如，/a+/ 会匹配 &quot;candy&quot; 中的 &apos;a&apos; 和 &quot;caaaaaaandy&quot; 中所有的 &apos;a&apos;，但是在 &quot;cndy&quot; 中不会匹配任何内容。</span><br></pre></td></tr></table></figure><h3 id="-5"><a href="#-5" class="headerlink" title="?"></a>?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">匹配前面一个表达式 0 次或者 1 次。等价于 &#123;0,1&#125;。</span><br><span class="line"></span><br><span class="line">例如，/e?le?/ 匹配 &quot;angel&quot; 中的 &apos;el&apos;、&quot;angle&quot; 中的 &apos;le&apos; 以及 &quot;oslo&apos; 中的 &apos;l&apos;。</span><br><span class="line"></span><br><span class="line">如果紧跟在任何量词 *、 +、? 或 &#123;&#125; 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 &quot;123abc&quot; 使用 /\d+/ 将会匹配 &quot;123&quot;，而使用 /\d+?/ 则只会匹配到 &quot;1&quot;。</span><br><span class="line"></span><br><span class="line">还用于先行断言中，如本表的 x(?=y) 和 x(?!y) 条目所述。</span><br></pre></td></tr></table></figure><h3 id="-6"><a href="#-6" class="headerlink" title="."></a>.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（小数点）默认匹配除换行符之外的任何单个字符。</span><br><span class="line"></span><br><span class="line">例如，/.n/ 将会匹配 &quot;nay, an apple is on the tree&quot; 中的 &apos;an&apos; 和 &apos;on&apos;，但是不会匹配 &apos;nay&apos;。</span><br><span class="line"></span><br><span class="line">如果 s (&quot;dotAll&quot;) 标志位被设为 true，它也会匹配换行符。</span><br></pre></td></tr></table></figure><h3 id="x"><a href="#x" class="headerlink" title="(x)"></a>(x)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">像下面的例子展示的那样，它会匹配 &apos;x&apos; 并且记住匹配项。其中括号被称为捕获括号。</span><br><span class="line"></span><br><span class="line">模式 /(foo) (bar) \1 \2/ 中的 &apos;(foo)&apos; 和 &apos;(bar)&apos; 匹配并记住字符串 &quot;foo bar foo bar&quot; 中前两个单词。模式中的 \1 和 \2 表示第一个和第二个被捕获括号匹配的子字符串，即 foo 和 bar，匹配了原字符串中的后两个单词。注意 \1、\2、...、\n 是用在正则表达式的匹配环节，详情可以参阅后文的 \n 条目。而在正则表达式的替换环节，则要使用像 $1、$2、...、$n 这样的语法，例如，&apos;bar foo&apos;.replace(/(...) (...)/, &apos;$2 $1&apos;)。$&amp; 表示整个用于匹配的原字符串。</span><br></pre></td></tr></table></figure><h3 id="x-1"><a href="#x-1" class="headerlink" title="(?:x)"></a>(?:x)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配 &apos;x&apos; 但是不记住匹配项。这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。</span><br><span class="line"></span><br><span class="line">看看这个例子 /(?:foo)&#123;1,2&#125;/。如果表达式是 /foo&#123;1,2&#125;/，&#123;1,2&#125; 将只应用于 &apos;foo&apos; 的最后一个字符 &apos;o&apos;。如果使用非捕获括号，则 &#123;1,2&#125; 会应用于整个 &apos;foo&apos; 单词。更多信息，可以参阅下文的 Using parentheses 条目。</span><br></pre></td></tr></table></figure><h3 id="x-y"><a href="#x-y" class="headerlink" title="x(?=y)"></a>x(?=y)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配&apos;x&apos;仅仅当&apos;x&apos;后面跟着&apos;y&apos;.这种叫做先行断言。</span><br><span class="line"></span><br><span class="line">例如，/Jack(?=Sprat)/会匹配到&apos;Jack&apos;仅当它后面跟着&apos;Sprat&apos;。/Jack(?=Sprat|Frost)/匹配‘Jack’仅当它后面跟着&apos;Sprat&apos;或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</span><br></pre></td></tr></table></figure><h3 id="lt-y-x"><a href="#lt-y-x" class="headerlink" title="(?&lt;=y)x"></a>(?&lt;=y)x</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配&apos;x&apos;仅当&apos;x&apos;前面是&apos;y&apos;.这种叫做后行断言。</span><br><span class="line"></span><br><span class="line">例如，/(?&lt;=Jack)Sprat/会匹配到&apos; Sprat &apos;仅仅当它前面是&apos; Jack &apos;。/(?&lt;=Jack|Tom)Sprat/匹配‘Sprat ’仅仅当它前面是&apos;Jack&apos;或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。</span><br></pre></td></tr></table></figure><h3 id="x-y-1"><a href="#x-y-1" class="headerlink" title="x(?!y)"></a>x(?!y)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">仅仅当&apos;x&apos;后面不跟着&apos;y&apos;时匹配&apos;x&apos;，这被称为正向否定查找。</span><br><span class="line"></span><br><span class="line">例如，仅仅当这个数字后面没有跟小数点的时候，/\d+(?!\.)/ 匹配一个数字。正则表达式/\d+(?!\.)/.exec(&quot;3.141&quot;) 匹配‘141’而不是‘3.141’</span><br></pre></td></tr></table></figure><h3 id="lt-y-x-1"><a href="#lt-y-x-1" class="headerlink" title="(?&lt;!y)x"></a>(?&lt;!y)x</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">仅仅当&apos;x&apos;前面不是&apos;y&apos;时匹配&apos;x&apos;，这被称为反向否定查找。</span><br><span class="line"></span><br><span class="line">例如，仅仅当这个数字前面没有负号的时候，/(?&lt;!-)\d+/ 匹配一个数字。</span><br><span class="line">/(?&lt;!-)\d+/.exec(&apos;3&apos;) 匹配到 &quot;3&quot;.</span><br><span class="line">/(?&lt;!-)\d+/.exec(&apos;-3&apos;) 因为这个数字前有负号，所以没有匹配到。</span><br></pre></td></tr></table></figure><h3 id="x-y-2"><a href="#x-y-2" class="headerlink" title="x|y"></a>x|y</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配‘x’或者‘y’。</span><br><span class="line"></span><br><span class="line">例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’</span><br></pre></td></tr></table></figure><h3 id="n"><a href="#n" class="headerlink" title="{n}"></a>{n}</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。</span><br><span class="line"></span><br><span class="line">比如， /a&#123;2&#125;/ 不会匹配“candy”中的&apos;a&apos;,但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个&apos;a&apos;。</span><br></pre></td></tr></table></figure><h3 id="n-1"><a href="#n-1" class="headerlink" title="{n,}"></a>{n,}</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n 是一个正整数，匹配前一个字符至少出现了 n 次。</span><br><span class="line"></span><br><span class="line">例如，/a&#123;2,&#125;/ 匹配 &quot;aa&quot;, &quot;aaaa&quot; 和 &quot;aaaaa&quot; 但是不匹配 &quot;a&quot;。</span><br></pre></td></tr></table></figure><h3 id="n-m"><a href="#n-m" class="headerlink" title="{n,m}"></a>{n,m}</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是 0，这个值被忽略。</span><br><span class="line"></span><br><span class="line">例如，/a&#123;1, 3&#125;/ 并不匹配“cndy”中的任意字符，匹配“candy”中的 a，匹配“caandy”中的前两个 a，也匹配“caaaaaaandy”中的前三个 a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的 a。</span><br></pre></td></tr></table></figure><h3 id="xyz"><a href="#xyz" class="headerlink" title="[xyz]"></a>[xyz]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个字符集合。匹配方括号中的任意字符，包括转义序列。</span><br><span class="line"></span><br><span class="line">你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。</span><br><span class="line"></span><br><span class="line">例如，[abcd] 和 [a-d] 是一样的。他们都匹配&quot;brisket&quot;中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/与字符串“test.i.ng”匹配。</span><br></pre></td></tr></table></figure><h3 id="xyz-1"><a href="#xyz-1" class="headerlink" title="[^xyz]"></a>[^xyz]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。</span><br><span class="line"></span><br><span class="line">你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。</span><br><span class="line">例如，[^abc] 和 [^a-c] 是一样的。他们匹配&quot;brisket&quot;中的‘r’，也匹配“chop”中的‘h’。</span><br></pre></td></tr></table></figure><h3 id="b"><a href="#b" class="headerlink" title="[\b]"></a>[\b]</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配一个退格 (U+0008)。（不要和\b混淆了。）</span><br></pre></td></tr></table></figure><h3 id="b-1"><a href="#b-1" class="headerlink" title="\b"></a>\b</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是 0。（不要和 [\b] 混淆了）</span><br><span class="line"></span><br><span class="line">使用&quot;moon&quot;举例：</span><br><span class="line">/\bm/匹配“moon”中的‘m’；</span><br><span class="line">/oo\b/并不匹配&quot;moon&quot;中的&apos;oo&apos;，因为&apos;oo&apos;被一个“字”字符&apos;n&apos;紧跟着。</span><br><span class="line">/oon\b/匹配&quot;moon&quot;中的&apos;oon&apos;，因为&apos;oon&apos;是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。</span><br><span class="line">/\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。</span><br><span class="line"></span><br><span class="line">备注： JavaScript 的正则表达式引擎将特定的字符集定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="\B"></a>\B</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">匹配一个非单词边界。匹配如下几种情况：</span><br><span class="line"></span><br><span class="line">字符串第一个字符为非“字”字符</span><br><span class="line">字符串最后一个字符为非“字”字符</span><br><span class="line">两个单词字符之间</span><br><span class="line">两个非单词字符之间</span><br><span class="line">空字符串</span><br><span class="line"></span><br><span class="line">例如，/\B../匹配&quot;noonday&quot;中的&apos;oo&apos;, 而/y\B../匹配&quot;possibly yesterday&quot;中的’yes‘</span><br></pre></td></tr></table></figure><h3 id="cX"><a href="#cX" class="headerlink" title="\cX"></a>\cX</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当 X 是处于 A 到 Z 之间的字符的时候，匹配字符串中的一个控制符。</span><br><span class="line"></span><br><span class="line">例如，/\cM/ 匹配字符串中的 control-M (U+000D)。</span><br></pre></td></tr></table></figure><h3 id="d"><a href="#d" class="headerlink" title="\d"></a>\d</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配一个数字。等价于 [0-9]。</span><br><span class="line"></span><br><span class="line">例如， /\d/ 或者 /[0-9]/ 匹配&quot;B2 is the suite number.&quot;中的&apos;2&apos;。</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="\D"></a>\D</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配一个非数字字符。等价于 [^0-9]。</span><br><span class="line"></span><br><span class="line">例如， /\D/ 或者 /[^0-9]/ 匹配&quot;B2 is the suite number.&quot;中的&apos;B&apos; 。</span><br></pre></td></tr></table></figure><h3 id="f"><a href="#f" class="headerlink" title="\f"></a>\f</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配一个换页符 (U+000C)。</span><br></pre></td></tr></table></figure><h3 id="n-2"><a href="#n-2" class="headerlink" title="\n"></a>\n</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配一个换行符 (U+000A)。</span><br></pre></td></tr></table></figure><h3 id="r"><a href="#r" class="headerlink" title="\r"></a>\r</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配一个回车符 (U+000D)。</span><br></pre></td></tr></table></figure><h3 id="s"><a href="#s" class="headerlink" title="\s"></a>\s</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于 [\f\n\r\t\v\u0020\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。</span><br><span class="line"></span><br><span class="line">例如，/\s\w*/ 匹配&quot;foo bar.&quot;中的&apos; bar&apos;。</span><br><span class="line"></span><br><span class="line">经测试，\s不匹配&quot;\u180e&quot;，在当前版本 Chrome(v80.0.3987.122) 和 Firefox(76.0.1) 控制台输入/\s/.test(&quot;\u180e&quot;) 均返回 false。</span><br></pre></td></tr></table></figure><h3 id="S"><a href="#S" class="headerlink" title="\S"></a>\S</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配一个非空白字符。等价于 [^\f\n\r\t\v\u0020\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。</span><br><span class="line"></span><br><span class="line">例如，/\S\w*/ 匹配&quot;foo bar.&quot;中的&apos;foo&apos;。</span><br></pre></td></tr></table></figure><h3 id="t"><a href="#t" class="headerlink" title="\t"></a>\t</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配一个水平制表符 (U+0009)。</span><br></pre></td></tr></table></figure><h3 id="v"><a href="#v" class="headerlink" title="\v"></a>\v</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配一个垂直制表符 (U+000B)。</span><br></pre></td></tr></table></figure><h3 id="w"><a href="#w" class="headerlink" title="\w"></a>\w</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。</span><br><span class="line"></span><br><span class="line">例如，/\w/ 匹配 &quot;apple,&quot; 中的 &apos;a&apos;，&quot;$5.28,&quot;中的 &apos;5&apos; 和 &quot;3D.&quot; 中的 &apos;3&apos;。</span><br></pre></td></tr></table></figure><h3 id="W"><a href="#W" class="headerlink" title="\W"></a>\W</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">匹配一个非单字字符。等价于 [^A-Za-z0-9_]。</span><br><span class="line"></span><br><span class="line">例如，/\W/ 或者 /[^A-Za-z0-9_]/ 匹配 &quot;50%.&quot; 中的 &apos;%&apos;。</span><br></pre></td></tr></table></figure><h3 id="n-3"><a href="#n-3" class="headerlink" title="\n"></a>\n</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串 (捕获的数目以左括号计数)。</span><br><span class="line"></span><br><span class="line">比如 /apple(,)\sorange\1/ 匹配&quot;apple, orange, cherry, peach.&quot;中的&apos;apple, orange,&apos; 。</span><br></pre></td></tr></table></figure><h3 id="0"><a href="#0" class="headerlink" title="\0"></a>\0</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配 NULL（U+0000）字符，不要在这后面跟其他小数，因为 \0&lt;digits&gt; 是一个八进制转义序列。</span><br></pre></td></tr></table></figure><h3 id="xhh"><a href="#xhh" class="headerlink" title="\xhh"></a>\xhh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配一个两位十六进制数（\x00-\xFF）表示的字符。</span><br></pre></td></tr></table></figure><h3 id="uhhhh"><a href="#uhhhh" class="headerlink" title="\uhhhh"></a>\uhhhh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配一个四位十六进制数表示的 UTF-16 代码单元。</span><br></pre></td></tr></table></figure><h3 id="u-hhhh-或-u-hhhhh"><a href="#u-hhhh-或-u-hhhhh" class="headerlink" title="\u{hhhh}或\u{hhhhh}"></a>\u{hhhh}或\u{hhhhh}</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（仅当设置了 u 标志时）匹配一个十六进制数表示的 Unicode 字符。</span><br></pre></td></tr></table></figure><h2 id="4-3-flags"><a href="#4-3-flags" class="headerlink" title="4.3 flags"></a>4.3 flags</h2><p>正则表达式有六个可选参数 (flags) 允许全局和不分大小写搜索等。这些参数既可以单独使用也能以任意顺序一起使用，并且被包含在正则表达式实例中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g全局搜索。</span><br><span class="line">i不区分大小写搜索。</span><br><span class="line">m多行搜索。</span><br><span class="line">s允许 . 匹配换行符。</span><br><span class="line">u使用 unicode 码的模式进行匹配。</span><br><span class="line">y执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始。</span><br></pre></td></tr></table></figure></p><h1 id="JavaScript中正则表达式的使用方法"><a href="#JavaScript中正则表达式的使用方法" class="headerlink" title="JavaScript中正则表达式的使用方法"></a>JavaScript中正则表达式的使用方法</h1><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>在字符串中执行查找匹配，返回一个数组（未匹配到则返回 null）。【RegExp 方法】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myRe = /d(b+)d/g;</span><br><span class="line">var myArray = myRe.exec(&quot;cdbbdbsbz&quot;);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myRe = new RegExp(&quot;d(b+)d&quot;, &quot;g&quot;);</span><br><span class="line">var myArray = myRe.exec(&quot;cdbbdbsbz&quot;);</span><br></pre></td></tr></table></figure><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>在字符串中测试是否匹配，返回 true 或 false。【RegExp 方法】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str=&apos;abcdef&apos;;</span><br><span class="line">var re=/b/; </span><br><span class="line">alert(re.test(str));</span><br></pre></td></tr></table></figure></p><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>在字符串中执行查找匹配，返回一个数组，在未匹配到时会返回 null。【String 方法】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var re = /\w+\s/g;</span><br><span class="line">var str = &quot;fee fi fo fum&quot;;</span><br><span class="line">var myArray = str.match(re);</span><br><span class="line">console.log(myArray);</span><br><span class="line"></span><br><span class="line">// [&quot;fee &quot;, &quot;fi &quot;, &quot;fo &quot;]</span><br></pre></td></tr></table></figure></p><h2 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll"></a>matchAll</h2><p>在字符串中执行查找所有匹配，返回一个迭代器（iterator）。【String 方法】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;hello javascript hello css&apos;;</span><br><span class="line">console.log(...str.matchAll(/hello/g));</span><br><span class="line">// [0: &quot;hello&quot;, groups: undefined, index: 0, input: &quot;hello javascript hello css&quot;]</span><br><span class="line">// [0: &quot;hello&quot;, groups: undefined, index: 17, input: &quot;hello javascript hello css&quot;]</span><br><span class="line"></span><br><span class="line">// 0: &quot;hello&quot;  匹配的字符串，如果有使用分组会在后面依次列出来</span><br><span class="line">// groups: undefined  没有使用命名捕获组会返回undefined，否则会返回包含命名捕获组的对象</span><br><span class="line">// index: 0  匹配的结果在当前字符串位置开始的索引</span><br><span class="line">// input: &quot;hello javascript hello css&quot; 当前字符串</span><br></pre></td></tr></table></figure></p><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p>在字符串中测试匹配，返回匹配到的位置索引，或者在失败时返回 -1。【String 方法】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;abcdef&quot;;</span><br><span class="line">var re=/b/;</span><br><span class="line">alert(str.search(re));</span><br><span class="line">//返回1</span><br><span class="line">var re=/w/;</span><br><span class="line">//返回-1</span><br><span class="line">var re=/B/;</span><br><span class="line">//返回-1</span><br></pre></td></tr></table></figure></p><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p>在字符串中执行查找匹配，并且使用替换字符串替换掉匹配到的子字符串。【String 方法】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var re = /(\w+)\s(\w+)/;</span><br><span class="line">var str = &quot;John Smith&quot;;</span><br><span class="line">var newstr = str.replace(re, &quot;$2, $1&quot;);</span><br><span class="line">console.log(newstr);</span><br></pre></td></tr></table></figure></p><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中。【String 方法】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;How are you doing today?&quot;;</span><br><span class="line">var n=str.split(/a/);</span><br><span class="line">// 返回[&apos;How &apos;, &apos;re you doing tod&apos;, &apos;y?&apos;]</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></li><li><a href="https://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="noopener">https://www.runoob.com/regexp/regexp-syntax.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git如何删除分支上的某次提交</title>
      <link href="/2021/08/01/git%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF%E4%B8%8A%E7%9A%84%E6%9F%90%E6%AC%A1%E6%8F%90%E4%BA%A4/"/>
      <url>/2021/08/01/git%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF%E4%B8%8A%E7%9A%84%E6%9F%90%E6%AC%A1%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上篇文章说到，如果想从其他分支取某（几）个提交来合并，可以使用 cherry-pick 命令，那么如果这个分支想剔除这几个被 cherry-pick 出去的提交呢？这就要用到 git 中另一个强大的命令：rebase。</p></blockquote><a id="more"></a><h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h1><p>rebase 命令可以改写某个提交之后的所有提交记录。</p><h1 id="如何删除分支上某次提交"><a href="#如何删除分支上某次提交" class="headerlink" title="如何删除分支上某次提交"></a>如何删除分支上某次提交</h1><h2 id="1-找到要删除的提交的-commit-hash"><a href="#1-找到要删除的提交的-commit-hash" class="headerlink" title="1. 找到要删除的提交的 commit hash"></a>1. 找到要删除的提交的 commit hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>假设要删除的 commit hash 为 A 和 B， A 早于 B。</p><h2 id="2-执行-rebase-i-“commit-hash”-进入编辑界面"><a href="#2-执行-rebase-i-“commit-hash”-进入编辑界面" class="headerlink" title="2. 执行 rebase -i “commit hash”^ 进入编辑界面"></a>2. 执行 rebase -i “commit hash”^ 进入编辑界面</h2><p>注意后面的^符号不能少，这样就可以看到包括提交A的前面的所有提交。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i A^</span><br></pre></td></tr></table></figure></p><h2 id="3-标记要删除的提交为-drop-或者-d"><a href="#3-标记要删除的提交为-drop-或者-d" class="headerlink" title="3. 标记要删除的提交为 drop 或者 d"></a>3. 标记要删除的提交为 drop 或者 d</h2><p>在 vi 编辑器里，将 A 和 B 的前面的 pick 改为 drop 或者 d。</p><h2 id="4-Esc-wq-退出-vi-编辑界面"><a href="#4-Esc-wq-退出-vi-编辑界面" class="headerlink" title="4. Esc + wq 退出 vi 编辑界面"></a>4. Esc + wq 退出 vi 编辑界面</h2><h2 id="5-执行-rebase-–continue-完成-rebase"><a href="#5-执行-rebase-–continue-完成-rebase" class="headerlink" title="5. 执行 rebase –continue 完成 rebase"></a>5. 执行 rebase –continue 完成 rebase</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><h1 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h1><p>在 <code>git rebase --continue</code> 这个过程中，如果有代码冲突，会暂时中断 rebase，<br>我们处理好冲突后，执行 <code>git add</code> 把处理好的冲突文件添加进来，<br>然后再执行 <code>git rebase --contine</code>，<br>循环往复直到从 A 到最新的提交都 reabase 完。</p><p>最后，可以使用 git log 命令检查一下 A 和 B 是否已经从该分支历史提交中剔除了。</p><p>done。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git之cherry-pick</title>
      <link href="/2021/05/23/Git%E4%B9%8Bcherry-pick/"/>
      <url>/2021/05/23/Git%E4%B9%8Bcherry-pick/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果你在使用 git 进行多人协作的代码管理，合并代码（ git merge ）的操作你一定不陌生。 git merge 会将指定分支的所有提交历史合并到当前所在的分支，它的合并单位是“分支”。但有的时候，我只想取某个分支的某几个提交的内容来合并。</p><p>遇到这种操作需求，我们可以使用 cherry-pick 命令，它是以“提交”为单位的合并，可以帮助你安全快速地达到目的。</p></blockquote><a id="more"></a><h2 id="cherry-pick-命令官方介绍"><a href="#cherry-pick-命令官方介绍" class="headerlink" title="cherry-pick 命令官方介绍"></a>cherry-pick 命令官方介绍</h2><p><a href="https://git-scm.com/docs/git-cherry-pick" target="_blank" rel="noopener">git-cherry-pick</a> 它可以在当前分支应用其他已经存在的 commit 修改，并对每一个合并过来的 commit 产生一个新的提交记录（commit hash）。</p><blockquote><p>cherry-pick - Given one or more existing commits, apply the change each one introduces, recording a new commit for each. </p></blockquote><h2 id="cherry-pick-的使用"><a href="#cherry-pick-的使用" class="headerlink" title="cherry-pick 的使用"></a>cherry-pick 的使用</h2><h3 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h3><p>指定任何本地分支上的某个存在的提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure></p><p>例如代码仓库有两个分支 dev 和 feat：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - e   #dev</span><br><span class="line">     \</span><br><span class="line">      f - g - h - i  #feat</span><br></pre></td></tr></table></figure></p><p>现在要将 feat 分支上的提交 g 应用到 dev 分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git cherry-pick g</span><br></pre></td></tr></table></figure></p><p>代码库的结构将变成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - e - g‘  #dev</span><br><span class="line">     \</span><br><span class="line">      f - g - h - i  #feat</span><br></pre></td></tr></table></figure></p><p>dev 分支后面将会增加一个提交 g’，这个提交的 commit 信息跟 feat 分支的 g 提交默认是一样的（你可以在提交过程中用 -m 选项追加内容，或者在处理冲突之后在 –continue 的时候修改，不过大部分时候，使用默认的就可以），但是会产生一个新的 commitHash。</p><h3 id="2-转移多个提交"><a href="#2-转移多个提交" class="headerlink" title="2. 转移多个提交"></a>2. 转移多个提交</h3><ul><li><p>多个不连续的提交，提交之间用空格相隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commitHash1&gt; &lt;commitHash2&gt;</span><br></pre></td></tr></table></figure></li><li><p>连续的提交（左开右闭），使用<code>..</code>注意中间没有任何空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;start-commitHash&gt;..&lt;end-commitHash&gt;</span><br></pre></td></tr></table></figure></li><li><p>连续的提交（左闭右闭）给第一个提交右侧加上<code>^</code>符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;start-commitHash&gt;^..&lt;end-commitHash&gt;</span><br></pre></td></tr></table></figure></li></ul><p>注：连续的提交命令中，start-commitHash 一定要是 end-commitHash 之前的提交，否则命令将会失败，但不会报错。</p><h3 id="3-转移最顶端的提交"><a href="#3-转移最顶端的提交" class="headerlink" title="3. 转移最顶端的提交"></a>3. 转移最顶端的提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;branchName&gt;</span><br></pre></td></tr></table></figure><p>会将指定分支的最后一次提交应用到当前分支。</p><h3 id="4-转移另一个代码库的提交"><a href="#4-转移另一个代码库的提交" class="headerlink" title="4. 转移另一个代码库的提交"></a>4. 转移另一个代码库的提交</h3><p>其实 cherry-pick 的奥义就是，只要是在一个.git仓库管理下的本地代码，任何提交都可以被应用到任何可访问的本地分支，哪怕是跨代码库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add repo2 git@xxx.git # 添加另一个代码库</span><br><span class="line">git fetch repo2 # 抓取新代码库到本地</span><br><span class="line">git log repo2/master # 查看新代码库master分支的提交记录</span><br><span class="line">git cherry-pick &lt;commitHashInRepo2&gt; # 将新的代码库的某个提交应用到当前分支（跨代码库的合并）</span><br></pre></td></tr></table></figure></p><h3 id="5-冲突处理"><a href="#5-冲突处理" class="headerlink" title="5. 冲突处理"></a>5. 冲突处理</h3><p>如果在cherry-pick的过程中，代码产生了冲突，cherry-pick 会停下来，等待我们的下一步操作决策。</p><ul><li><p>处理冲突。我们可以先将代码冲突在编辑器中处理好，然后回到命令行，使用 –countinue 参数让 cherry-pick 过程继续执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick --countinue</span><br></pre></td></tr></table></figure></li><li><p>放弃合并，代码回到操作前的样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick --abort</span><br></pre></td></tr></table></figure></li><li><p>退出cherry-pick，但是代码不回到操作前的样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cheerry-pick --quit</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-cherry-pick-的一些常用配置项"><a href="#6-cherry-pick-的一些常用配置项" class="headerlink" title="6. cherry-pick 的一些常用配置项"></a>6. cherry-pick 的一些常用配置项</h3><ul><li><p>-n, –no-commit<br>只更新工作区和暂存区。不产生新的提交</p></li><li><p>-x<br>在提交信息末尾追加一行（cherry picked from commit…）方便以后查到这个提交是如何产生的。</p></li><li><p>-m parent-number, –mainline parent-number<br>如果原始分支是一个合并节点，那么  cherry-pick 默认会失败，因为不知道应该采用哪个分支的代码变动。 -m 配置项告诉 git 应该采用哪个分支分变动，parent-number 代表原始提交的父分支编号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick -m 1 &lt;commitHash&gt;</span><br></pre></td></tr></table></figure><p>一般1号父分支是接受变动分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from)。</p></li></ul><h2 id="使用-cherry-pick-的好处"><a href="#使用-cherry-pick-的好处" class="headerlink" title="使用 cherry-pick 的好处"></a>使用 cherry-pick 的好处</h2><p>在一个项目中，经常会遇到这种情况：由于需求的拆分，多人同时在一个分支中开发各自负责的需求，但是在上线前，如果发现某个需求达不到验收要求，要单独延迟发布，这意味着需要我们快速建立另一个发布分支，将目前分支中属于发布需求范围的那部分代码剥离过去。</p><p>很多人面临这样的状况的第一想法可能是进行人肉比对，手动把代码从一个分支拷贝出来，然后粘贴到另一个分支去提交。我的建议是，不管是分支级别还是提交级别，只要需要合并代码，能不手动拷贝就不手动，工作量不小不说，还风险极大，一旦出了问题还不容易排查。</p><p>再次推荐 cherry-pick 这个命令，用来完成不同分支之间的部分合并操作太香了，不仅能提高效率，而且由于它是以 commit 为单位的合并，过程清晰，将来追溯问题更容易。</p><p>– GoodLuck</p><p>参考：<br><a href="https://git-scm.com/docs/git-cherry-pick" target="_blank" rel="noopener">https://git-scm.com/docs/git-cherry-pick</a><br><a href="http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html</a></p><p>文章同步发于公众号「前端手札」，一名WEB技术爱好者的手札，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底弄懂前端模块化（三）</title>
      <link href="/2021/04/07/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2021/04/07/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>—— AMD</p></blockquote><a id="more"></a><h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p><a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition" target="_blank" rel="noopener">AMD</a> (Asynchronous Module Definition) 原本是从 CommonJs 规范中分化出来的几个分支之一，但由于种种原因，AMD 规范一直没有被 CommonJS 社区认同。</p><p>2011年5月 AMD 从 CommonJS 社区独立出去，单独成立了 <a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD 社区</a>。脱离了 CommonJS 社区的 AMD 规范，后来逐渐演化成了 <a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">RequireJS</a> 的附属品，以至于很多人认为AMD是RequireJS的产物。</p><h2 id="规范要求"><a href="#规范要求" class="headerlink" title="规范要求"></a>规范要求</h2><p>简单地说，ADM的规范为：</p><ul><li><p>AMD规范只定义了一个函数 “define”，它是全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure><p><strong>id</strong><br>第一个参数，id，是个字符串。它指的是定义中模块的名字，这个参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。</p><p><strong>dependencies</strong><br>第二个参数，dependencies，是个定义中模块所依赖模块的数组。依赖模块必须根据模块的工厂方法优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中。</p><p><strong>factory</strong><br>第三个参数，factory，为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次，并且该函数按照依赖声明的顺序，接收依赖作为参数。如果是对象，此对象应该为模块的输出值。<br>如果工厂方法返回一个值（对象，函数，或任意强制类型转换为true的值），应该为设置为模块的输出值。</p></li><li><p>AMD规定义了三种特殊的依赖关键字：“require”, “exports” 和 “module”。<br>AMD中可以使用”require”加载模块。同样也可以选择完全不使用“require”。</p></li></ul><blockquote><p>更详细的规范内容可以在<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD 社区网站</a>查看。</p></blockquote><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">require</span>([<span class="string">'a'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(f);</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am a.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> func1;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="主流的实现"><a href="#主流的实现" class="headerlink" title="主流的实现"></a>主流的实现</h2><p>AMD的主流实现有 <a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a>、<a href="https://github.com/cujojs/curl" target="_blank" rel="noopener">curl.js</a> 等。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>是一种在线编译（runtime）模块的方案。</li><li>AMD 优先照顾浏览器的模块加载场景，使用了异步加载和回调的方式。</li><li>使用时需要先在浏览器端注入js脚本加载器，比如require.js。</li><li>AMD可以作为CommonJS模块一个中转的版本只要CommonJS没有被用作同步的require调用。使用同步require调用的CommonJS代码可以被转换为使用回调风格的AMD模块加载器。</li></ul><h2 id="核心实现逻辑"><a href="#核心实现逻辑" class="headerlink" title="核心实现逻辑"></a>核心实现逻辑</h2><ol><li>动态创建script脚本插入HTML</li><li>利用浏览器的加载能力，异步加载模块</li><li>监听每个脚本的load事件</li><li>如果依赖的所有脚本都加载完了，执行回调</li><li>回调中拿到的依赖模块靠define注入</li></ol><p>–</p><p>参考：<br><a href="http://www.commonjs.org/history/" target="_blank" rel="noopener">http://www.commonjs.org/history/</a><br><a href="http://wiki.commonjs.org/wiki/Modules" target="_blank" rel="noopener">http://wiki.commonjs.org/wiki/Modules</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">https://github.com/amdjs/amdjs-api/wiki/AMD</a><br><a href="https://groups.google.com/g/amd-implement" target="_blank" rel="noopener">https://groups.google.com/g/amd-implement</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底弄懂前端模块化（二）</title>
      <link href="/2021/03/29/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/03/29/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>—— CommonJs</p></blockquote><a id="more"></a><blockquote><p><a href="https://champyin.com/2021/03/22/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/">上篇</a>提到，在ES6没有出来之前，Javascript 自身是不支持模块化开发的，不过得益于社区的努力，我们仍然可以享受模块化开发的体验，只是在进行模块化开发时需要遵循特定的模块化规范。</p></blockquote><h1 id="一、什么是模块化规范"><a href="#一、什么是模块化规范" class="headerlink" title="一、什么是模块化规范"></a>一、什么是模块化规范</h1><p>模块化规范，也就是模块定义规范（Module Definition Specification），是对模块代码书写格式和交互(模块间的互相引用)规则的详细描述。</p><p>我们熟知的 CommonJS、AMD、CMD 就是三个比较主流的第三方（即来自社区的）模块化规范。ES6中的模块化是ECMA标准，目前只有部分高版本的浏览器实现了ESmodule的支持，但是这是未来的模块化趋势。</p><h1 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h1><p>CommonJs 原来叫做 ServerJS，是 Mozilla 的工程师在2009年发起的一个项目。这个项目的目的是让浏览器端之外（比如服务器端或者桌面端）使用 JavaScript 语言开发的项目能够通过模块化的方式来开发和协作。</p><p>当 ServerJS 推出的 <a href="http://wiki.commonjs.org/wiki/Modules/1.0" target="_blank" rel="noopener">Modules 1.0 规范</a> 在 Node.js 等环境下取得了很不错的实践后，Mozilla 的工程师们想把 ServerJS 的成功经验进一步推广到浏览器端，于是在2009年下半年，社区改名为 CommonJs。</p><h2 id="规范要求"><a href="#规范要求" class="headerlink" title="规范要求"></a>规范要求</h2><p>简单地说，CommonJs规定：</p><ul><li>一个模块就是一个文件</li><li>每个模块内有两个变量可以使用：require 和 module</li><li>通过<code>require</code>加载模块</li><li>通过<code>module.exports</code>或者<code>exports</code>导出模块（为了方便，Node.js 在实现 CommonJS 规范时，为每个模块提供一个 exports 的私有变量，指向 module.exports）</li></ul><p>具体详细的规范内容可以在官方网站查看：</p><ul><li>CommonJS 社区规范： <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1" target="_blank" rel="noopener">Modules 1.1.1</a> </li><li>NodeJS 的模块规范： <a href="http://nodejs.org/api/modules.html" target="_blank" rel="noopener">Modules</a> </li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'./m2'</span>);</span><br><span class="line">p.say(<span class="string">'hi'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m2.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_say</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br><span class="line">exports.say = _say; <span class="comment">// 或者 module.exports = &#123;say: _say&#125;</span></span><br></pre></td></tr></table></figure><h2 id="主流的实现"><a href="#主流的实现" class="headerlink" title="主流的实现"></a>主流的实现</h2><p>CommonJs的主流实现有 node.js、webpack、babel 等。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>在 Node.js 中模块加载的方式是同步的，因为在服务器端所有文件都存储在本地的硬盘上，传输速率快而且稳定。</li><li>CommonJS 模块输出的值，对于基本数据类型，是复制，对于复杂数据类型，是浅拷贝。</li><li>CommonJS 模块输出的是值的缓存，不存在动态更新，当使用require命令加载某个模块时，就会运行整个模块的代码,然后在内存生成一个对象。Require 命令加载同一个模块，不会再执行，而是取缓存之中的值。即，commonjs模块无论加载多少次，都只会在第一次加载的时候运行一次，以后再加载，就返回第一次运行的结果。除非手动清除系统缓存。</li><li>Requirejs循环加载时候，属于加载时执行。即脚本在require的时候，就会全部执行。一旦出现某个模块<br>被循环加载，就只输出已经执行的部分，还未执行的部分不会输出。</li><li>Require是动态加载，这意味着require语句可写在任何位置，同时也意味着commonjs模块只能在运行时才能确定模块的依赖关系。</li></ul><h2 id="核心实现逻辑"><a href="#核心实现逻辑" class="headerlink" title="核心实现逻辑"></a>核心实现逻辑</h2><ol><li>解析模块路径</li><li>同步从本地读取模块文件内容，得到文本字符串</li><li>将字符串包裹成自执行函数的前半部分</li><li>使用vm沙箱将字符串转换成函数（vm是node.js的虚拟沙箱模块，vm.runInThisContext方法可以接受一个字符串，并将它转换成一个函数返回）</li><li>执行函数（将关键变量传入进去：<code>exports、require、module、__filename、__dirname</code>）</li></ol><p>–</p><p>参考：<br><a href="http://www.commonjs.org/history/" target="_blank" rel="noopener">http://www.commonjs.org/history/</a><br><a href="http://wiki.commonjs.org/wiki/Modules" target="_blank" rel="noopener">http://wiki.commonjs.org/wiki/Modules</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底弄懂前端模块化（一）</title>
      <link href="/2021/03/22/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/03/22/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前端模块化已经不是什么新鲜概念了，这年头提到前端开发，模块化、组件化开发谁不是张口就来，但是你真的彻底了解前端模块化吗？我想有一大部分人可能未必。如果你就是其中之一，那么我这篇文章可能对你有帮助。</p></blockquote><a id="more"></a><h1 id="一、什么是模块化？"><a href="#一、什么是模块化？" class="headerlink" title="一、什么是模块化？"></a>一、什么是模块化？</h1><p>模块化是指解决一个复杂问题时自顶向下逐层把整体划分成若干组成部分的过程。模块化是一种管理方式，是一种生产方式，一种解决问题的方案。</p><p>放在开发场景中，模块化就是有组织地把一个大文件拆成独立并互相依赖的多个小文件。在这里模块化是一种代码管理方式。</p><h1 id="二、什么是模块？"><a href="#二、什么是模块？" class="headerlink" title="二、什么是模块？"></a>二、什么是模块？</h1><p>模块就是完成特定功能的单元。</p><p>模块具有以下几个基本属性：功能、接口、状态、逻辑。功能、接口与状态反映模块的外部特性，逻辑反映它的内部特性。</p><p>在开发场景中，一个模块就是实现特定功能的文件。</p><h1 id="三、模块化的目的"><a href="#三、模块化的目的" class="headerlink" title="三、模块化的目的"></a>三、模块化的目的</h1><p>模块化的目的在于最大化的设计重用，以最少的模块、零部件，更快速的满足更多的个性化需求。</p><h1 id="四、什么是模块化开发？"><a href="#四、什么是模块化开发？" class="headerlink" title="四、什么是模块化开发？"></a>四、什么是模块化开发？</h1><p>模块化开发是一种开发思想。简单的说就是程序的编写不是开始就着手实现功能细节，而是首先用主程序、子程序、子过程把软件的主要结构和流程描述出来，并定义和调试好各个框架之间的输入、输出连接关系。逐步求解的结果是得到一系列以功能块为单位的算法描述。</p><p>以功能块为单位进行程序设计、实现其求解算法的过程称为模块化开发。</p><h1 id="五、前端模块化的历程"><a href="#五、前端模块化的历程" class="headerlink" title="五、前端模块化的历程"></a>五、前端模块化的历程</h1><p>前面说了，模块化开发是一种思想，要实现这种思想，需要语言的支持，或者当语言支持的脚步赶不上我们的需求的时候，我们可以自定义一个模块化规范，然后再实现一个预编译器（或者浏览器端的加载器），将模块化代码转换成语言能识别的语法，这样我们就可以使用模块化的方式开发了。</p><h2 id="1-一开始没有模块化概念"><a href="#1-一开始没有模块化概念" class="headerlink" title="1. 一开始没有模块化概念"></a>1. 一开始没有模块化概念</h2><p>JavaScript当时被设计出来只是用来实现一些简单的交互，所以JavaScript一开始并没有模块化的概念。</p><h2 id="2-冲突和依赖管理问题需要被解决，自执行函数的模式已不够用"><a href="#2-冲突和依赖管理问题需要被解决，自执行函数的模式已不够用" class="headerlink" title="2. 冲突和依赖管理问题需要被解决，自执行函数的模式已不够用"></a>2. 冲突和依赖管理问题需要被解决，自执行函数的模式已不够用</h2><p>在Ajax被提出，前端拥有向后端异步请求数据的能力后，前端逻辑越来越复杂，代码越来越庞大，网页也越来越像桌面APP。为了维护的方便，我们不停地把不同功能的js抽取出来作为独立的js文件。然而当项目变得复杂，一个HTML页面可能需要加载十几甚至几十个js文件时，全局变量污染、函数名冲突，依赖关系不好处理等问题随之而来。</p><p>  不像Java，可以把不同功能的文件放在不同的package中，需要某个函数或功能的时候只需import相关的包而无需担心变量冲突等问题。当时，变量污染和冲突问题我们可以利用JavaScript的函数作用域特性，用自执行函数来解决（比如JQuery的做法）。但是依赖关系问题依然没有很好的解决：js文件的加载靠的是浏览器的加载能力，默认是阻塞式的加载，async 异步加载顺序没有保证，defer 异步加载虽然可以保证加载顺序，但是依赖的维护仍全靠手动很不灵活。</p><h2 id="3-社区涌现第三方模块化规范"><a href="#3-社区涌现第三方模块化规范" class="headerlink" title="3. 社区涌现第三方模块化规范"></a>3. 社区涌现第三方模块化规范</h2><p>为此 JavaScript 社区做了很多努力，2009年，Rayn Dahl 在他创造的 node.js 项目中使用了 CommonJS 模块规范，从此 JavaScript 模块化开发正式拉开序幕。并且带来了npm生态，以及一大批前端构建工具grunt、gulp、browserify，webpack等等。随后，社区又出现了 AMD、CMD 等优秀的模块化规范，以及requirejs、curljs 和 seajs等前端模块加载器。</p><h2 id="4-ES6模块化规范"><a href="#4-ES6模块化规范" class="headerlink" title="4. ES6模块化规范"></a>4. ES6模块化规范</h2><p>2016年，ES6的出现，JavaScript语言终于有了原生模块（module）体系。这意味着，不使用第三方模块化规范也可以用模块化方式进行开发了。</p><blockquote><p>篇幅原因，CommonJS、AMD、CMD、ESmodule 的详细分析将另起篇幅来写。</p></blockquote><p>–<br>Happy coding.</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git之 git clean</title>
      <link href="/2021/03/19/Git%E4%B9%8B-git-clean/"/>
      <url>/2021/03/19/Git%E4%B9%8B-git-clean/</url>
      
        <content type="html"><![CDATA[<blockquote><p>要取消已经track过的文件的修改，可以使用<code>git checkout xxx</code>，但是如果要取消 untracked 文件的修改，checkout 就不行了。除了手动删除修改，我们还可以使用 git 提供的 <code>git clean</code> 命令来快速达到目的。</p></blockquote><a id="more"></a><h1 id="删除-untracked-files"><a href="#删除-untracked-files" class="headerlink" title="删除 untracked files"></a>删除 untracked files</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f</span><br></pre></td></tr></table></figure><h1 id="删除-untracked-文件和目录"><a href="#删除-untracked-文件和目录" class="headerlink" title="删除 untracked 文件和目录"></a>删除 untracked 文件和目录</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -df</span><br></pre></td></tr></table></figure><h1 id="连-gitignore-的-untracked-文件和目录也一起删掉"><a href="#连-gitignore-的-untracked-文件和目录也一起删掉" class="headerlink" title="连 gitignore 的 untracked 文件和目录也一起删掉"></a>连 gitignore 的 untracked 文件和目录也一起删掉</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -xdf</span><br></pre></td></tr></table></figure><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>建议加上<code>-n</code>参数来看看会删掉哪些文件，防止重要文件被误删。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clean -nf</span><br><span class="line">git clean -ndf</span><br><span class="line">git clean -nxdf</span><br></pre></td></tr></table></figure></p><h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>如果想要取消本地所有 tracked 和 untracked 的文件修改和删除目录可以把两个命令连起来使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout . &amp;&amp; git clean -nxdf</span><br></pre></td></tr></table></figure></p><p>–<br>Have a nice day!</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SystemJS</title>
      <link href="/2021/03/05/SystemJS/"/>
      <url>/2021/03/05/SystemJS/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近的工作有用到SystemJS，在这里对SystemJS的理解做个总结和记录吧，备忘。</p></blockquote><a id="more"></a><h1 id="什么是SystemJS"><a href="#什么是SystemJS" class="headerlink" title="什么是SystemJS"></a>什么是SystemJS</h1><p><a href="https://github.com/systemjs/systemjs" target="_blank" rel="noopener">SystemJS</a>是一个可运行于浏览器端的模块加载器，是一个polifill，可以让我们在浏览器上直接使用ES模块等先进语法，而不用管浏览器是否支持该语法。</p><p>对应的，SystemJS有一个运行于Nodejs的版本：system-node.cjs。</p><h1 id="为什么会出现SystemJS"><a href="#为什么会出现SystemJS" class="headerlink" title="为什么会出现SystemJS"></a>为什么会出现SystemJS</h1><p>Chrome浏览器其实已经支持js代码中的import、export有一段时间了，语法规则为<code>&lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt;&lt;/script&gt;</code>。</p><p>这个特性可以让我们在浏览器端import一个js模块，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在html里</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"./index.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在 index.js 中可以直接使用import</span></span><br><span class="line"><span class="keyword">import</span> lodash <span class="keyword">from</span> <span class="string">"https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.20/lodash.min.js"</span>;</span><br></pre></td></tr></table></figure></p><p>我们也可以通过名称来 import 一个 js 模块：<code>import lodash from &quot;lodash&quot;;</code>，注意：本地不需要安装lodash模块，但需要我们要给这个名称做一个映射配置——importmap：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"importmap"</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"imports"</span>: &#123;</span><br><span class="line">      <span class="string">"lodash"</span>: <span class="string">"https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.20/lodash.min.js"</span> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>Chrome是目前唯一实现importmap的浏览器，以上写法，要开启chrome的feature标记才可以体验。在普通模式下，上述写法是会报错的。如果想要在普通模式下使用importmap，那就要用到SystemJS了。</p><p>SystemJS是一个支持importmaps和其他js未来特性的pollyfill，这意味着你可以在IE11或者任何浏览器下使用importmaps而不用等这些浏览器支持importmaps等特性。</p><h1 id="SystemJS的几个特性"><a href="#SystemJS的几个特性" class="headerlink" title="SystemJS的几个特性"></a>SystemJS的几个特性</h1><p>除了importmaps，SystemJS还有5个让你现在就可以使用 js 模块新特性的能力，这些特性是不能直接依赖浏览器来使用的。其中importmaps是当中最重要的一个。</p><ol><li><p>importmaps。 </p></li><li><p>通过1个文件加载多个js模块。正常情况下，加载一个js文件必须发起1次网络请求，如果只使用浏览器的能力，100个js文件就要发100个网络请求。通过SystemJS，允许你通过system.set 和 system.register apis，一次网络请求加载多个js文件。 </p></li><li><p>检测已注册模块，通过 system.get 和 system.has，system.entries apis 可以查看所有可用的js模块。 </p></li><li><p>import.meta.resolve，得到任何模块的完整url。如果浏览器不支持import.meta，可以改为使用 systemjs.contex.meta.resolve。 </p></li><li><p>Import.meta.url, 返回当前模块的url。 </p></li><li><p>除了js模块，SystemJS还支持其他类型模块，如下类型已经进入提案：json模块、css模块、html模块等，这些模块的加载，浏览器暂时还不支持，但是SystemJS已经支持。 </p></li></ol><h1 id="如何使用SystemJS"><a href="#如何使用SystemJS" class="headerlink" title="如何使用SystemJS"></a>如何使用SystemJS</h1><ul><li><p>首先，要修改script标签的type，由<code>importmap</code>改为<code>systemjs-importmap</code>。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- &lt;script type="importmap"&gt;</span></span><br><span class="line"><span class="addition">+ &lt;script type="systemjs-importmap"&gt;</span></span><br><span class="line">  &#123;</span><br><span class="line">    "imports": &#123;</span><br><span class="line">      "lodash": "https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.20/lodash.min.js" </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>接着，引入模块的script也要修改type，由<code>module</code>改为<code>systemjs-module</code>。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- &lt;script type="module" src="./index.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+ &lt;script type="systemjs-module" src="./index.js"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>除了使用<code>systemjs-module</code>我们还可以直接在script标签里<code>System.import(&#39;./xxx.js&#39;);</code>（这种写法更常见）。注意，模块导入是一个异步过程，返回的是一个Promise对象，可以配合then来使用。</p></li><li><p>然后，我们不能在模块中再使用import关键字了。<br>SystemJS维护它自己的js模块列表，与浏览器跟踪的js模块不一样，如果继续在浏览器使用import，浏览器识别它，并会去跟踪查明它到底是什么模块，而我们正在使用的是一个浏览器在未来才会支持的特性，所以浏览器会报错。所以我们要使用另一种只有SystemJS才能理解而不被浏览器去解析的语法System.register：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- import lodash from 'lodash';</span></span><br><span class="line"><span class="addition">+ System.register(['lodash'], (exports) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+    return &#123;</span></span><br><span class="line"><span class="addition">+      setters: [</span></span><br><span class="line"><span class="addition">+        () =&gt; &#123;&#125;;</span></span><br><span class="line"><span class="addition">+      ],</span></span><br><span class="line"><span class="addition">+      execute() &#123;</span></span><br><span class="line"><span class="addition">+        console.log('test');</span></span><br><span class="line"><span class="addition">+        exports(&#123;_: lodash&#125;);</span></span><br><span class="line"><span class="addition">+      &#125;)</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+ &#125;)</span></span><br></pre></td></tr></table></figure><p>这个语法，打包工具（例如webpack或者rollup）会自动帮我们转换，省得咱们去记。</p><p>在webpack下只需要将libraryTarget设置为system即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Webpack 关键配置</span><br><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    libraryTarget: &apos;system&apos;, </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rollup中配置的是format字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// rollup 关键配置</span><br><span class="line">output: &#123;</span><br><span class="line">    format: &apos;system&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>最后，我们要在页面加载SystemJS。<br>使用script标签加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://lib.baomitu.com/systemjs/latest/system.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><p>总结起来，就是我们需要：加载SystemJS、配置systemjs-importmap和systemjs-module（或者使用system.import）、加载使用 <code>sytemjs.registry</code> 代替 <code>import</code> 的 js 模块，然后刷新页面就就可以看到运行效果了。</p><p>需要注意的是：<br>配置 systemjs-import 的资源url时候，url对应的资源内容不能是 es6 module（有import和export）必须是es5 module。</p><h1 id="Unable-to-resolve-bare-specifier-报错的解决"><a href="#Unable-to-resolve-bare-specifier-报错的解决" class="headerlink" title="Unable to resolve bare specifier 报错的解决"></a>Unable to resolve bare specifier 报错的解决</h1><p>使用SystemJS的过程中，如果遇到<code>Unable to resolve bare specifier xxx</code>的报错，那是因为SystemJS找不到<code>xxx</code>对应的url。而通过importmaps ，SystemJS可以将 “bare specifier” 转换为URL，所以此时只需要配置importmap将对应的资源地址告诉SystemJS即可。</p><p>另外，以下几种行为，会触发 SystemJS 获取模块的 url：<br>• 直接加载模块： System.import(‘specifier’)<br>• 将模块作为依赖来加载：System.register([‘specifier’], …)<br>• 手动resolve：System.resolve(‘specifier’)</p><blockquote><p>更多SystemJS错误可参考：<a href="https://github.com/systemjs/systemjs/blob/master/docs/errors.md#8" target="_blank" rel="noopener">https://github.com/systemjs/systemjs/blob/master/docs/errors.md#8</a></p></blockquote><p><br></p><p>文章同时发表于公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> systemjs </tag>
            
            <tag> 加载器 </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SaaS</title>
      <link href="/2020/09/06/SaaS/"/>
      <url>/2020/09/06/SaaS/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我换工作了，新的工作内容是围绕 SaaS 业务展开。作为前端，全面理解所服务的行业业务，将有助于日常工作的展开。SaaS 是一个很有商业价值的领域。但在此之前我对 SaaS 知之甚少。SaaS 有哪些形态，它的分类，适用场景，价值的衡量标准是什么？开发商希望从 SaaS 中获得什么，商家希望从 SaaS 中获得什么，消费者又会有什么受益？我想了解关于 SaaS 的一切。对新领域的好奇心和求知欲促使我将平常的碎片时间几乎都用来查阅 SaaS 相关的资料和书籍，加上自己的理解和思考，我对 SaaS 总算有了比较全面的了解。</p></blockquote><a id="more"></a><h1 id="什么是-SaaS"><a href="#什么是-SaaS" class="headerlink" title="什么是 SaaS"></a>什么是 SaaS</h1><p>SaaS: Software as a Service 软件即服务。</p><p>与之相应的还有 PaaS 和 IaaS：</p><ul><li>PaaS：Platform as a Service 平台即服务。</li><li>IaaS：Infrastructure as a Service 基础设施服务。</li></ul><p>这三类服务模式中，在用户需要承担的工作量上，IaaS &gt; PaaS &gt; SaaS。</p><p>SaaS 是软件的开发、部署、管理都交给第三方（服务商），用户不需要关心技术问题，可以拿来即用。</p><p>SaaS 软件有免费、付费、增值三种模式。普通用户接触到的互联网服务，几乎都是 SaaS，比如存储服务：阿里云、腾讯云；社交服务：微信、微博；以及买家电商：淘宝、京东等等。</p><h1 id="SaaS-的技术点"><a href="#SaaS-的技术点" class="headerlink" title="SaaS 的技术点"></a>SaaS 的技术点</h1><p>SaaS 服务通常基于一套标准软件系统为成百上千的不同租户提供服务。这要求 SaaS 服务能够支持不同租户之间数据和配置的隔离，从而保证每个租户的安全与隐私，以及用户对界面、业务逻辑、数据结构等的个性化需求。这对支撑软件的基础设施平台的性能、稳定性和扩展性提出很大挑战。优化软件大规模应用后的性能和运用成本是架构师的核心任务。</p><p>传统软件的定制服务是在软件开发阶段完成，而 SaaS 需要在软件使用过程中针对需求的变化更新定制，而且在定制的时候不能影响其他用户的使用。同时，SaaS 的定制过程必须简单易行，使得用户可以自行完成。这些差异使得 SaaS 应用在技术设计上更加复杂，传统的个性化定制无法应用在 SaaS 领域，SaaS 的个性化定制技术的改进是制约其发展的瓶颈之一。</p><h1 id="为什么会出现-SaaS"><a href="#为什么会出现-SaaS" class="headerlink" title="为什么会出现 SaaS"></a>为什么会出现 SaaS</h1><p>SaaS 是软件技术进步、信息化越来越普及，以及同类客户需求趋于统一的大背景下，催生的一种商业模式，也是开发服务商为自己创造的商机。</p><h2 id="SaaS-的目的是什么"><a href="#SaaS-的目的是什么" class="headerlink" title="SaaS 的目的是什么"></a>SaaS 的目的是什么</h2><p>SaaS 产品的最基本的目的是提升客户管理效率，节约成本，在“商业化”领域，SaaS 还能帮助客户企业增加获客数量和营收，这是每个企业的刚需。</p><h2 id="商业领域-SaaS-会给开发商、商家、消费者带来什么"><a href="#商业领域-SaaS-会给开发商、商家、消费者带来什么" class="headerlink" title="商业领域 SaaS 会给开发商、商家、消费者带来什么"></a>商业领域 SaaS 会给开发商、商家、消费者带来什么</h2><ul><li><p>开发商<br>对于 SaaS 软件开发商，通过向商家出租 SaaS 服务获利，客户持续的复购和增购为其带来了源源不断的收入。</p></li><li><p>商家<br>对于使用 SaaS 的商家，除了使用 SaaS 的管理能力，为自己的店铺管理提效，还能通过 SaaS 的营销能力，将他的产品信息精准触达到潜客人群和目标人群，增加客流，增加转化率，进而增加营收；还可以通过 SaaS 的投放能力，将促销及优惠活动投放给会员用户，增加复购率等等。另外，还可以通过 SaaS 的大数据分析能力，辅助自己作出商业调整的决策。总之 SaaS 可以为商家带来开源节流增收的好处。</p></li><li><p>消费者<br>对于消费者，可以享受到更好的服务，比如作为潜客或者目标顾客，使用商家精准投放的优惠券购物——省钱，比如商家推送的商品正是自己想买的商品，还有优惠，可以省去从海量商品中挑选的精力，快速购买到所需的商品——省时。</p></li></ul><p>由此可见，一个成功的专业的商家 SaaS 带来的，将是一个开发商、商家、消费者三赢的局面。</p><h1 id="SaaS-是从什么时候开始出现的"><a href="#SaaS-是从什么时候开始出现的" class="headerlink" title="SaaS 是从什么时候开始出现的"></a>SaaS 是从什么时候开始出现的</h1><p>SaaS 源于美国的 Saleforce 公司（1999年由 Marc Benioff 创立）创造的软件服务模式。美国市场的 SaaS 模式在2019年就已经进入商业成熟期，发展出了一大批在市场上非常成功的 SaaS 公司，例如：</p><ul><li>Saleforce（CRM等领域）市值1200亿美元</li><li>ServiceNow（IT运营领域）市值500亿美元</li><li>Workday（HR领域）市值480亿美元</li></ul><p>（数据截止到2019年6月）</p><h1 id="中国的-SaaS-行业现状"><a href="#中国的-SaaS-行业现状" class="headerlink" title="中国的 SaaS 行业现状"></a>中国的 SaaS 行业现状</h1><p>我们国家的 SaaS 应用最早也是开始于1999年，但后来的10几年，这些做 SaaS 的企业都发展的不温不火，原因可以归结为三个：</p><ul><li>一是当时的企业不觉得数字化有那么的必要；</li><li>二是 SaaS 不是部署在企业内部，这意味着企业的数据将不在企业端，当时的大部分企业是不能接受的；</li><li>三是这个时期的 SaaS 产品本身不够好。</li></ul><p>2015年，国内业内普遍认为这一年是中国 SaaS 元年。企业服务市场，特别是 SaaS 领域的融资达到了一个高点。</p><p>2017年开始，在众多垂直行业中涌现出大量初创 SaaS 公司。</p><p>在中国，整个 SaaS 领域还在早期阶段。</p><h1 id="SaaS-的分类"><a href="#SaaS-的分类" class="headerlink" title="SaaS 的分类"></a>SaaS 的分类</h1><h2 id="我们在谈论-SaaS-时，我们在谈论什么"><a href="#我们在谈论-SaaS-时，我们在谈论什么" class="headerlink" title="我们在谈论 SaaS 时，我们在谈论什么"></a>我们在谈论 SaaS 时，我们在谈论什么</h2><p>在看一些 SaaS 文章的时候，我感觉到 SaaS 产品的分类，或者说“叫法”很多，而且有的不太直观。有的人从技术架构给 SaaS 产品分类，有的文章是从平台来分类，还有从交易类型、从行业类型等等角度来给 SaaS 分类。这很容易导致一些混乱和误导。也让我同时意识到，当我们在谈论 SaaS 时，很可能我们谈论的不是一类东西。想要高效地交流，就有必要在进入正题之前，把我们所说的 SaaS 界定清楚。</p><h2 id="如何界定分类"><a href="#如何界定分类" class="headerlink" title="如何界定分类"></a>如何界定分类</h2><p>我比较欣赏和推荐的 SaaS 分类方法，是从两个维度来划分，非常直观：</p><ul><li>从服务对象维度，分为<code>通用型</code>和<code>行业型</code></li><li>从价值模式维度，分为<code>工具型</code>和<code>商业型</code></li></ul><p>通用型：聚焦某个业务，但客户群体是跨行业的。<br>行业型：聚焦一个行业内的多个业务。<br>工具型：为客户企业提供一个提高管理效率的工具。（帮客户省钱）<br>商业型：除了工具价值外，还为客户企业提供增值价值。（即帮客户省钱，又帮客户多挣钱）</p><p>这两个维度可以叠加，这意味着我们可以通过4个类型界定一个 SaaS 产品：</p><ol><li>通用工具型 SaaS</li><li>通用商业型 SaaS</li><li>行业工具型 SaaS</li><li>行业商业型 SaaS</li></ol><p>这样，当我们想要讨论 SaaS 的时候，就可以非常明确地实现界定好，比如我想要跟你谈的是行业商业型 SaaS，不是其他别的。</p><h2 id="SaaS-产品间的转化路径"><a href="#SaaS-产品间的转化路径" class="headerlink" title="SaaS 产品间的转化路径"></a>SaaS 产品间的转化路径</h2><ol><li>通用 SaaS 加上构建 PaaS 能力或者可配置能力，可以切行业市场，转行业 SaaS</li><li>行业 SaaS 从工具型可以向商业型转变</li><li>通用 SaaS 增加场景价值可以从工具型转商业 SaaS</li></ol><h1 id="SaaS-的本质"><a href="#SaaS-的本质" class="headerlink" title="SaaS 的本质"></a>SaaS 的本质</h1><p>从技术角度，SaaS 是一种软件布局模型；<br>从产品角度，SaaS 是一种基于互联网的软件交付、软件应用和软件运营模式；<br>从管理学角度，SaaS 是一种商业模式[1]。</p><p>有人说 SaaS 的本质是“续费”，我很认同。一方面，从商业角度来看 SaaS，续费是它的核心盈利模式之一；另一方面“续费”这一报价方式给公司带来的，还有服务模式、销售模式以及公司估值等方面的巨大影响。</p><h2 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h2><p>传统软件公司在客户企业一次性买断软件的使用许可后，提供的售后服务，是被动的客户服务。即客户遇到问题了，联系售后客服来反馈或者投诉以获得帮助，客服部门的人被动响应，按照流程提供相应的解决预案，积极性也不高。</p><p>而 SaaS 公司，因为客户采用租赁（入驻平台）的方式来使用我们的服务，为了保证客户复购和续费，会主动持续帮助客户解决问题。比如通过走访持续跟客户保持联系，比如通过行业数据分析发现客户营收等潜在问题主动反馈给客户等，帮助客户的同时也帮助 SaaS 软件更好的迭代（有的 SaaS 公司会有 CSM 客户成功管理部门，做的就是这个事情）。</p><h2 id="销售模式"><a href="#销售模式" class="headerlink" title="销售模式"></a>销售模式</h2><p>因为 SaaS 的续费模式，SaaS 的销售难度比传统软件要小（新单价格比较低），销售周期比传统软件要短，并且第二年以及之后的续费成本非常低，因此，SaaS 的新单毛利可以非常低，甚至可以实行0毛利政策：把首次成交的毛利全部分给销售提成和代理商返款，提成比例比传统行业高近10倍！这种销售模式刺激下，SaaS 的销售和代理商的积极性显然要比传统软件的高。</p><h2 id="公司估值"><a href="#公司估值" class="headerlink" title="公司估值"></a>公司估值</h2><p>传统上市公司的估值，是按照年盈利来估值的，而 SaaS 公司是按照年营收额来估值的。在美国，传统上市公司是20倍左右的市盈率（市值/盈利），即市值大概为年利润的20倍左右。而 SaaS 公司的估值是10倍左右的市销率（市值/销售额），即市值大概是年销售额的10倍左右。</p><p>这么说可能大家没有体感，举个例子：同样是年销售额1000万，传统公司，净利润一般在10%左右，那么它的估值为：1000 x 10% x 20 = 2000万；而 SaaS 公司，它的估值为 1000 x 10 = 1亿。这对于 to B 公司来说是巨大的价值！</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>借用我很喜欢的一句话来作为结尾吧（不记得是哪位大佬说的了）：每个传统行业都值得用互联网再重做一次，而 SaaS 与 AI、IOT 一起，就是用互联网思维改写每个行业的工具。</p><p>–<br>[1]商业模式是指企业在市场中与用户、供应商、其他合作伙伴（即营销的任务环境的各主体）的关系，尤其是彼此间的物流、信息流和资金流。</p><p>推荐阅读<br>《SaaS创业路线图》——吴昊<br><a href="https://blog.csdn.net/hzp666/article/details/76915288" target="_blank" rel="noopener">一文读懂IaaS，PaaS，SaaS 的区别</a><br><a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-multitenantsaas/" target="_blank" rel="noopener">将您的 web 应用程序转化为多租户 SaaS 解决方案</a></p><p><br></p><p>文章同步发于公众号「前端手札」，一名WEB技术爱好者的手札，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 商业模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SaaS </tag>
            
            <tag> merchant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deno 初探</title>
      <link href="/2020/06/14/Deno-%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/06/14/Deno-%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/deno.png" alt="deno.png"></p><blockquote><p>Deno 已经被前端圈子提及有很长一段时间了，上个月 Deno 发布了 1.0 版本，又掀起了一小股 Deno 热。Deno 到底是什么？它可以用来做什么呢？它好用吗？带着一直以来的好奇心，趁着周末的时间，认真地接触了一次 Deno。</p></blockquote><a id="more"></a><h1 id="一、什么是Deno？"><a href="#一、什么是Deno？" class="headerlink" title="一、什么是Deno？"></a>一、什么是Deno？</h1><p>Deno 是一个更安全的 JavaScript 和 TypeScript 运行时，作者 Ryan Dahl 同时也是 Node.js 的创建者。</p><h2 id="什么是运行时？"><a href="#什么是运行时？" class="headerlink" title="什么是运行时？"></a>什么是运行时？</h2><p>运行时是一个运行环境，也叫运行平台，开发者可以使用指定的语言，基于这个环境开发应用。可以认为运行时就是一个舞台，能做什么事情，取决于舞台能提供什么道具。比如浏览器就是一个运行时，我们可以在浏览器上通过 JS 调用浏览器提供的 API 操作 DOM。</p><h2 id="Deno-的作用"><a href="#Deno-的作用" class="headerlink" title="Deno 的作用"></a>Deno 的作用</h2><p>Deno 的作用，是让开发者可以使用 JavaScript 语言开发后端服务。</p><h1 id="二、为什么会有Deno？"><a href="#二、为什么会有Deno？" class="headerlink" title="二、为什么会有Deno？"></a>二、为什么会有Deno？</h1><p>我们知道 Node.js 也是一个让开发者可以使用 JavaScript 语言开发后端服务的 JavaScript 运行时。那既然已经有一个 Node.js，而且已经非常成功，为什么还要造另一个 JavaScript 运行时 Deno ？</p><p>两年前（2018年6月），Ryan Dahl 在德国柏林召开的 JSConf EU 会议上发表了名为 “10 Things I Regret About Node.js” 的演讲，有兴趣可以到这里下载 <a href="https://github.com/yc111/ebooks/blob/master/js-conf/Design%20Mistakes%20in%20Node.pdf" target="_blank" rel="noopener">PPT</a> 。</p><p><img src="/images/deno-Ryan-Dahl.jpg" alt="deno-Ryan-Dahl.jpg"></p><p>在分享中，Ryan 回顾了在他看来当初开发 Node.js 时留下的10大遗憾。但由于Node.js 现在已经广泛应用于各个领域，为了保证兼容性，对 Node.js 底层进行大规模改造已经不现实。会上，Ryan 宣布了他决定开发一个全新的 JavaScript Runtime 以解决当初的种种缺陷，这个项目就是 Deno。</p><p><img src="/images/deno-logo.png" alt="deno-logo.png"></p><p>Deno 的命名很有意思，就是把 node（no de） 倒过来 deno（de no），颇有颠覆 Node 的意味。</p><p>BTW，上个月（2020年5月15日），Deno 发布了1.0版本。</p><h1 id="三、走近-Deno"><a href="#三、走近-Deno" class="headerlink" title="三、走近 Deno"></a>三、走近 Deno</h1><h2 id="Deno-的开发语言"><a href="#Deno-的开发语言" class="headerlink" title="Deno 的开发语言"></a>Deno 的开发语言</h2><p>相比 Node.js 使用 C++ 开发，Deno 起初使用的开发语言是 GoLang，后来改为了 Rust。并且随后把 C++ 写的 libdeno 换成了 Rust 编写的 V8 绑定：denoland/rusty_8。</p><p>Deno 目前是建立在 V8 引擎、Rust 、Tokio、TypeScript 的基础之上。</p><ul><li>V8 是 chrome 浏览器内的 JavaScript 运行时。</li><li>Rust 是一门系统编程语言，专注于安全，尤其是并发安全。它的性能和标准C++ 不相上下。</li><li>Tokio 是一个给 Rust 语言使用的异步运行时，提供 event loop 和具体的 I/O 类型。</li><li>TypeScript 是 JavaScript 的超集。</li></ul><h2 id="Deno-的特性"><a href="#Deno-的特性" class="headerlink" title="Deno 的特性"></a>Deno 的特性</h2><ul><li>默认支持 ES Modules</li><li>默认支持 TypeScript</li><li>尽可能兼容 Web 标准 APIs</li><li>默认采用沙箱模式运行代码，更安全</li><li>去中心化第三方模块机制</li><li>提供标准库</li></ul><h2 id="与-Node-js-的比较"><a href="#与-Node-js-的比较" class="headerlink" title="与 Node.js 的比较"></a>与 Node.js 的比较</h2><ul><li>使用 ES 模块，不支持 require()</li><li>Deno 不使用 package.json</li><li>Deno 不使用 npm</li><li>Deno  中的所有异步操作返回 promise，因此 Deno 提供与 Node 不同的 API</li><li>Deno 需要显示指定文件、网络和环境权限</li><li>第三方模块通过 URL 或者文件路径导入</li><li>当未捕获的错误发生时，Deno 总是会异常退出</li><li>兼容 Web 的运行时 APIs，更利于前后端的代码同构。</li></ul><h1 id="四、如何使用-Deno"><a href="#四、如何使用-Deno" class="headerlink" title="四、如何使用 Deno"></a>四、如何使用 Deno</h1><p>Deno 能够在 macOS、Linux 和 Windows 上运行。Deno 是一个单独的可执行文件，它没有额外的依赖。</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>在 macOS 下可以通过Shell命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://deno.land/x/install/install.sh | sh</span><br></pre></td></tr></table></figure><p>这个方式在国内安装会很慢，慢到下不下来。。。so，不推荐。</p><p>也可以通过HomeBrew 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install deno</span><br></pre></td></tr></table></figure><p><img src="/images/deno-install-brew.jpg" alt="deno-install-brew.jpg"></p><p>这个方式可以安装下来，但是，安装的版本是 v0.20.0，很低的版本：</p><p><img src="/images/deno-version-low.jpg" alt="deno-version-low.jpg"></p><p>并且这个版本不带 upgrade 命令，升级 deno 的时候很不方便。so，也不推荐。</p><p>安利通过国内加速器（镜像源 <a href="https://x.deno.js.cn" target="_blank" rel="noopener">https://x.deno.js.cn</a> ）来安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://x.deno.js.cn/install.sh | sh</span><br></pre></td></tr></table></figure><p>也可以指定版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://x.deno.js.cn/install.sh | sh -s v1.0.0</span><br></pre></td></tr></table></figure><p><img src="/images/deno-install-x.jpg" alt="deno-install-x.jpg"></p><p>首次安装，可以看到提示，需要手动配置一下环境变量，配置语句也已经给出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ touch ~/.bash_profile # 创建用户环境变量文件</span><br><span class="line">$ vim ~/.bash_profile # 打开文件，将刚才命令行提示给出的配置语句粘贴进去，保存退出。</span><br></pre></td></tr></table></figure><p>让配置立即生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>环境变量就设置好了，现在在任何一个新打开的命令行里面都可以使用 deno 命令了。</p><p>注意：如果之前使用 brew 安装过低版本的 deno，请使用 brew uninstall deno 卸载 deno 之后，再使用加速器安装高版本，不卸载直接安装高版本不会生效。（别问我为什么知道。。。都是泪。</p><p>其他操作系统环境的安装可参考 <a href="https://github.com/denoland/deno_install。" target="_blank" rel="noopener">https://github.com/denoland/deno_install。</a></p><p>如果要升级本地的 Deno，可以运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno upgrade</span><br></pre></td></tr></table></figure><p>还可以安装指定的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno upgrade --version 1.1.0</span><br></pre></td></tr></table></figure><p>这个命令会从 github.com/denoland/deno/releases 获取最新的发布版本（一个可执行的二进制文件 zip 压缩包），然后解压并替换现有的版本。而 github release 的文件使用的是 aws，在国内访问不稳定。</p><p>So，升级也推荐使用国内加速器安装指定版本来达到目的。</p><h2 id="2-测试安装"><a href="#2-测试安装" class="headerlink" title="2.测试安装"></a>2.测试安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno --version</span><br></pre></td></tr></table></figure><p><img src="/images/deno-version-high.jpg" alt="deno-version-high.jpg"></p><p>如果打印出 Deno 版本，说明安装成功。</p><p>到这里，我们就安装好 Deno ，并且可以基于 Deno 进行开发了。</p><h2 id="3-运行一个远程的项目"><a href="#3-运行一个远程的项目" class="headerlink" title="3.运行一个远程的项目"></a>3.运行一个远程的项目</h2><p>跑一个远程项目（官方的demo）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno run https://deno.land/std/examples/welcome.ts</span><br></pre></td></tr></table></figure><p>可以看到在控制台输出”Welcome to Deno 🦕”。</p><p><img src="/images/deno-run-remote.jpg" alt="deno-run-remote.jpg"></p><h2 id="4-运行一个本地的项目"><a href="#4-运行一个本地的项目" class="headerlink" title="4.运行一个本地的项目"></a>4.运行一个本地的项目</h2><p>起一个最简单的本地服务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; serve &#125; <span class="keyword">from</span> <span class="string">"https://deno.land/std@0.57.0/http/server.ts"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = serve(&#123; <span class="attr">port</span>: <span class="number">8000</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"http://localhost:8000/"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> req <span class="keyword">of</span> s) &#123;</span><br><span class="line">  req.respond(&#123; <span class="attr">body</span>: <span class="string">"Hello World\n"</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Deno 在引用第三方模块的方式为 ES6 的 import 语法，并且直接通过 URL 来引入，版本号也被锁定在了 URL 中。</p><p>另外，Deno 支持 顶层的 await 语法，不用与 async 语法配对使用了。</p><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno run http.js</span><br></pre></td></tr></table></figure><p><img src="/images/deno-run-local.jpg" alt="deno-run-local.jpg"></p><p>首次引入第三方包，Deno 会去下载这个包和它的依赖，这些包会被缓存到全局，下次再引入的时候，将直接读取缓存。</p><p>这里报了一个缺少网络权限的错，这是因为 Deno 采用沙箱模式运行代码，网络权限必须通过手动添加 flag （–allow-net）来开启。</p><p>带上网络权限运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deno run --allow-net http.js</span><br></pre></td></tr></table></figure><p><img src="/images/deno-run-with-net.jpg" alt="deno-run-with-net.jpg"></p><p>打开localhost://8000</p><p><img src="/images/deno-server.jpg" alt="deno-server.jpg"></p><p>可以看到一个简单的本地服务就跑起来了。</p><h2 id="5-其他相关配置"><a href="#5-其他相关配置" class="headerlink" title="5.其他相关配置"></a>5.其他相关配置</h2><p>如果我们要高效地使用 Deno，最好还需要设置一些开发环境，比如环境变量、命令行自动补全、编辑器等。</p><ul><li><p>环境变量</p><p>DENO_DIR：<br>这是 Deno 在本地存放生成的代码和缓存下载的模块的路径，默认为 $HOME/Library/Caches/deno。</p><p>NO_COLOR：<br>这个会关闭输出的文字颜色。</p><p>HTTP_PROXY 和 HTTPS_PROXY ：<br>这两个变量用来设置 HTTP 和 HTTPS 的代理地址。</p></li><li><p>命令自动补全<br>通过 deno completions <shell> 命令可以生成补全脚本。他会输出到 stdout，应该将它重定向到适当的文件。</shell></p><p>Deno 支持的 shell 有 zsh、bash、fish、powershell、elvish。</p></li><li><p>编辑器插件<br>我们可以给 VS Code 配置 Deno 的插件： <a href="https://github.com/denoland/vscode_deno" target="_blank" rel="noopener">vscode_deno</a></p><p>如果你是其他编辑器/IDE，可以参考官网<a href="https://deno.land/manual/getting_started/setup_your_environment" target="_blank" rel="noopener">推荐的插件</a></p></li></ul><h1 id="Deno-将来会取代-Node-js-吗？"><a href="#Deno-将来会取代-Node-js-吗？" class="headerlink" title="Deno 将来会取代 Node.js 吗？"></a>Deno 将来会取代 Node.js 吗？</h1><p>这也是很多前端者关心的话题，网络上两种声音都有，我的看法是：会共存，但不会取代。</p><p>首先，Node.js 的作者之所以开发 Deno 只是为了兑现他心目中对 JavaScript Runtime 的一个理想实现，并不是为了取代 Node.js；</p><p>其次，Node.js 经过十多年的发展，已经很成熟了（虽然在 Ryan 的眼里不那么完美），并且已经被广泛应用。个人认为，将来 Deno 要做的事情，Node.js 都能做，如果没有特别的因素（比如潜在的安全隐患等），已经使用了 Node.js 的应用，不大会改用 Deno 重构。</p><p>所以，以我目前的认知，我认为 Deno 如果能发展起来，应该会与 Node.js 共生，而不会取代 Node.js。</p><p>不管怎样，我很钦佩 Ryan，在 Node.js 获得如此成功之后，仍然怀揣对作品的理想追求，大胆分享自己在 Node.js 中犯的“错误”，开始 Deno 的征程，并且现在 Deno 正在以飞快的速度在迭代。就在昨天，Deno 又发布了 V1.1.0。</p><p><img src="/images/deno-release-v1.1.0.jpg" alt="deno-release-v1.1.0.jpg"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上是我对 Deno 的一个初探，解答了什么是 Deno，它有什么作用，有哪些特点，与 Node.js 有什么不同，以及如何使用 Deno（虽然只浅浅地跑了最简单的程序，但足以让我感觉到 Deno 与 Node.js 在使用上的不同）。现在，总算对 Deno 的有了一个比较清晰的了解。</p><p>有兴趣交流的小伙伴可以在这里留言讨论：<a href="https://github.com/yc111/yc111.github.io/issues/2" target="_blank" rel="noopener">https://github.com/yc111/yc111.github.io/issues/2</a><br>Deno 交流QQ群：698469316</p><p>-End-</p><p>参考<br>Deno Manual：<a href="https://deno.land/manual" target="_blank" rel="noopener">https://deno.land/manual</a><br>Deno Doc：<a href="https://doc.deno.land/https/github.com/denoland/deno/releases/latest/download/lib.deno.d.ts" target="_blank" rel="noopener">https://doc.deno.land/https/github.com/denoland/deno/releases/latest/download/lib.deno.d.ts</a><br>Deno中文社区：<a href="https://denocn.org/" target="_blank" rel="noopener">https://denocn.org/</a><br>Deno中文开发者社区：<a href="https://deno.js.cn/" target="_blank" rel="noopener">https://deno.js.cn/</a><br>Deno中文手册：<a href="https://nugine.github.io/deno-manual-cn/" target="_blank" rel="noopener">https://nugine.github.io/deno-manual-cn/</a><br>Futures 和 Tokio 项目的前世今生：<a href="https://rustcc.cn/article?id=8af74de6-1e3d-4596-94ca-c3da45509f58" target="_blank" rel="noopener">https://rustcc.cn/article?id=8af74de6-1e3d-4596-94ca-c3da45509f58</a></p><p><br></p><p>文章首发于于公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deno </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你有多久没有进行深度思考了？</title>
      <link href="/2020/05/23/%E4%BD%A0%E6%9C%89%E5%A4%9A%E4%B9%85%E6%B2%A1%E6%9C%89%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E4%BA%86%EF%BC%9F/"/>
      <url>/2020/05/23/%E4%BD%A0%E6%9C%89%E5%A4%9A%E4%B9%85%E6%B2%A1%E6%9C%89%E8%BF%9B%E8%A1%8C%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E4%BA%86%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近日在知乎无意中看到一篇「如何培养自己深度思考的习惯」的文章，里面的很多观点，我赞同不已。</p><p>其中一个观点我总结起来就是：“深度思考有两个方向：上推式思考，下推式思考。上推式思考的精髓就是 为什么；下推式思考的精髓就是 假设。”</p><p>这跟我一直以来的思维方式不谋而合，同时也再次引发我对深入思考这件事的思考。</p><p>另外，我还被文中引入的一个理论所吸引，那就是「奶嘴理论」，忍不住去查了下这个理论的来龙去脉，感觉对这个世界的本质，又多了一层认知。</p></blockquote><a id="more"></a><h1 id="一、奶嘴理论"><a href="#一、奶嘴理论" class="headerlink" title="一、奶嘴理论"></a>一、奶嘴理论</h1><p>在互联网越来越发达的今天，我们深度思考的机会反而越来越少。我们的生活可能已经被一些娱乐、游戏、媒体信息给填满了，深度思考的能力在退化。</p><p>对于这种现象，或许我们会认为，这是信息化的发展导致的必然，是文明发展到一定阶段自然衍生的现象，但实际上，从某种程度上来说，这一切都是有人蓄意让其发生的。</p><p>1995年，美国旧金山举行过一个全球精英会议。500名政经精英在会议上，为全球化的世界进行分析与规划。大家一致认为：</p><ol><li>二八定律真切地存在。</li><li>竞争会越来越激烈，而80%的人，将越来越贫穷，地位越来越边缘化。</li></ol><p>于是，问题来了，这80%的“loser”，与剩余20%的精英之间，必然存在冲突。<br>冲突如果剧烈，社会就会动荡。如何解决这一问题呢？</p><p>美国当代著名的战略思想家<code>布热津斯基</code>就此提出了著名的 <code>Titty Tainment 战略</code>（奶嘴理论）。</p><p>这80%的人，他们不必也无法参与产品的生产和服务，同时80%的财富掌握在另外20%的人手中，为了安慰社会中“被遗弃”的人，避免阶层冲突，可以给这80%的被边缘者一个“奶嘴”，让他们心安理得接受被抛弃的命运。当80%被边缘者安分守己，无心挑战现有的统治阶级，20%的精英就能高枕无忧。</p><p>所谓“奶嘴”的安慰，就是采取温情、麻醉、半满足，娱乐化、低智化、游戏化、低成本、轻易就能获取刺激性快乐的办法，来卸除边缘化人口的不满。</p><p><code>布热津斯基</code>认为，有两种娱乐方式能够实现这个想法：一是发泄型娱乐，比如开放色情产业、赌博产业，鼓励暴力网络游戏等，二是满足型娱乐，比如播出一些明星花边，家长里短，肥皂剧、偶像剧、真人秀等大众化视听娱乐。</p><p>用这些令人沉迷的消遣娱乐和充满感官刺激的产品填满人们的生活，转移其注意力和不满情绪，让这80%的人沉浸在这些“快乐”跟“安逸”之中，不知不觉丧失对现实问题的思考能力。</p><p>当娱乐大量占用人们的时间，人们慢慢地安于为他们量身打造的娱乐信息当中，便不会再抗争，也不会再思考，他们会期待媒体为他们进行思考，媒体替她们做出判断。</p><p>所以，娱乐要越多越好，游戏要越普及越好，综艺与真人秀要随处可见，低智的、无逻辑的、甚至堪称恶俗的偶像剧要一部接一部。当这些东西触手可及，底层人就会安分下来，快乐地、毫无怨言地、无知无觉地继续贫穷，继续无所得，然后虚度一生。</p><p>这一社会麻醉剂将会带来“马太效应”，沉迷的人继续沉迷，清醒的人保持清醒，人与人的差距，甚至阶层间的差距也就拉大了。</p><h1 id="二、保持思考的重要性"><a href="#二、保持思考的重要性" class="headerlink" title="二、保持思考的重要性"></a>二、保持思考的重要性</h1><p>看过这个奶嘴理论，是不是有些细思极恐？无形之中，我们的生活，我们的发展道路似乎在被一双隐形的大手操控，而我们可能一边被牵着走，一边还以为这是自己内心的想法。</p><p>奶嘴理论的实施，理论上它将影响的对象是所有人，但是为什么那20%的人没有受到影响呢？我想不用我说，大家也应该知道了吧，那就是思考的力量。当一个人拥有清醒的头脑，独立思考的能力，就可以看清一些现象背后的本质，然后对事物有个比较全面的判断。这项技能，让TA可以摆脱奶嘴战略的影响，成为那20%的人。</p><p>那么，有人要说，我也知道天天刷剧看小说玩游戏不对，我也想有思考和控制自己的能力，但是我做不到啊，我一动脑筋就头疼，想不来，我可能天生没有思考的基因。</p><h1 id="三、思考能力、观点是怎么形成的"><a href="#三、思考能力、观点是怎么形成的" class="headerlink" title="三、思考能力、观点是怎么形成的"></a>三、思考能力、观点是怎么形成的</h1><p>首先，我想说的是，有以上这些消极观点的人，随口都能说出一堆借口的人，你们已经被奶嘴战略侵袭已久，并且对自己的现状已经形成一套自洽的闭环理论，让自己可以心安理得地继续堕落。如果没有因此遇到特别大的挫折和打击，是很难走出这个闭环牢笼，因为它给你营造了一个低成本的虚假安逸感，而走出的过程会很痛苦。</p><p>其次，如果你还有一丝理智，靠自己走出来，也不是不可能。不过这个的前提，是你要知道思考能力、观点是怎么形成的，这样，你才可以通过摸索实践，唤起脑细胞的活动，重拾思考能力。</p><p>一般情况下，我们的观点形成，需要经历这么几个步骤：</p><ol><li><p>直觉<br>在我们什么都不知道的时候，在知识也缺乏，信息也缺乏，能力也不够的时候，我们对一个事情，首先有的是直觉。这个时候，靠的是思维的条件反射和以前的认知形成的潜意识，这是一种非常浅层次的思考，甚至算不上思考。</p></li><li><p>直觉受到挑战<br>直觉很容易带来的一个东西，叫做偏见。随着你接触的事情越来越多，你的偏见总有一天会遭到挑战。</p></li><li><p>自我辩论<br>当你看到另一些事情，或者接触到另一些观点，跟你之前的直觉不一致的时候，你可能会在头脑中产生辩论，因为你要给自己一个说法，到底哪一个才是对的，这个时候你就开始有了判断力，你的三观也在悄悄建立。</p></li><li><p>形成自己的观点<br>最后你终于积累了很多的经验，在看了很多的观点之后，形成了自己比较认同的观点，这个观点相对来说，会比较兼顾，比较稳定，因为它经历了整个思考过程，一段时间内不会变化。</p></li></ol><h1 id="四、如何深度思考"><a href="#四、如何深度思考" class="headerlink" title="四、如何深度思考"></a>四、如何深度思考</h1><p>要实现一个目标，我们需要努力，努力需要一个方向，并且最好是正确的方向，否则，就是瞎忙。思考也是一样，没有方向的思考，不利于理清问题，沿着错误的方向思考，则会让事情耗时且无进展。</p><p>如何深度思考，我很赞同开篇提到的那两个方向：上推思维和下推思维。</p><h2 id="上推思维"><a href="#上推思维" class="headerlink" title="上推思维"></a>上推思维</h2><p>上推式思考的精髓，就是“问为什么”。<br>它可以很好地培养自己透过现象看本质的能力。</p><p>我们不能总是被信息主导着往下想，要想办法往上想，要想为什么，找问题的源头。当我们问到不能再问为什么的时候，就越接近事情的根本原因，然后我们再下结论，就完成了深度思考的过程。如果你一直被信息引导着下结论，你的思维会越来越肤浅。</p><h2 id="下推思维"><a href="#下推思维" class="headerlink" title="下推思维"></a>下推思维</h2><p>下推式思考的精髓，叫做“假设”。<br>它可以很好地培养自己的判断能力。</p><p>我们可以追溯证据来源及可靠性，可以平行对比，当然最多的，是通过提出假设，然后在假设成立的情况下，思考事情会怎么样，然后再反推这个假设是否合理。这有点像数学中经常用来解证明题的反证法。</p><h1 id="五、弱思考能力的几个特征"><a href="#五、弱思考能力的几个特征" class="headerlink" title="五、弱思考能力的几个特征"></a>五、弱思考能力的几个特征</h1><p>如果你不知道如何判断自己的思考能力是否OK，那么你可以通过以下几点来自我检测一下，这些列举的点是被认为思考能力较弱的一些特征：</p><ol><li><p>不喜欢有深度的内容<br>当看到需要动脑思考的内容，不能静下心去思考，而对一些虚构的故事情节非常能看得下去，容易沉浸在一些虚假的幻想当中。</p></li><li><p>情绪化<br>用情绪代替思考，容易被别人的情绪所影响，而不是对方表达的内容。</p></li><li><p>混淆情感跟逻辑<br>容易被情感绑架，当一句话中情感的部分被你认同，里面的逻辑你会无条件地接纳。</p></li><li><p>喜欢说经验<br>未能意识到经验是特定场景才能成立的个例，如果不加以提炼升华为更通用的理论，很容易以偏概全。</p></li><li><p>把假设当结果<br>对事情的前提完全没有质疑意识，也就很难发现自己基于这个前提之下的所有思考的基石，很有可能根本都站不住脚。</p></li><li><p>用现象代替原因<br>未能透过现象看到本质，思考浅尝则止，经常导致一通努力过后但是效果不佳。</p></li><li><p>人云亦云<br>从众思想，大家都这么说，那一定是没错；向来都是这样，那一定是没问题。缺乏对大众舆论的质疑精神。</p></li></ol><h1 id="六、一些我认为很好的建议："><a href="#六、一些我认为很好的建议：" class="headerlink" title="六、一些我认为很好的建议："></a>六、一些我认为很好的建议：</h1><ol><li><p>拒绝低幼化的语言刺激<br>语言会影响我们的思维，甚至有人认为谁掌握了语言，谁就掌握了思维。那么什么是低幼化的语言刺激？绝大多数的网络流行语都是。诸如“我也是醉了”“666”“扎心”“你看这个面，它又长又宽”……<br>所以日常生活中，尽量能拨出一定时间，看深度的、优秀的数据和文章，保持自己对语言的理解和运用能力。</p></li><li><p>拒绝抢夺注意力的低劣产品<br>如果可以，拒绝从众，拒绝那些肤浅的综艺、影视剧、热点消息、娱乐圈资讯，只看最优秀的作品。<br>不要让自己成为愉悦感的奴隶。<br>不动脑子，能带来短期的愉悦和轻松，但长期来看，它只能导向空虚和无聊。</p></li><li><p>为自己设定有意义的目标<br>请找到一件能够带给你长期收益和幸福感的事情，把它安排进每天的日程中。<br>它可以帮助你对抗庸常，平凡，让你保持头脑清醒。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当你满足于低质量的消遣和享乐，自律会一点一点丧失，意志力会逐渐瘫软。你不会再思考，也不再向往艰难的事业。你会恐惧挑战，恐惧前行。你会在一个接一个的综艺中，在一坨又一坨的碎片资讯里，一阵接一阵的低质量欢愉中，走向你的颓废。</p><p>你有多久没有进行深度思考了？<br>你是否经常置身于充满感官刺激的娱乐、碎片化的信息和无尽的游戏中？<br>你是否意识到，你的的注意力全部被娱乐、信息或者游戏占据，时间全部被消耗？</p><p>如果你中招了，不妨从现在开始，保持思维上的警惕，远离一切让你停止思考的事情，刻意坚持思考。</p><p>随着深度思考成为了习惯，你也将逐渐成为更优秀的人。</p><p>–</p><p>文章同时发表于公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thought </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron实战（一）安装</title>
      <link href="/2020/04/25/Electron%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/"/>
      <url>/2020/04/25/Electron%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/electron-cover.png" alt="electron-cover.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道，JavaScript 是用来开发网站的脚本语言。Javascript 开发出来的网页必须依赖浏览器来解析。 而桌面客户端，通常是由 C++ 、C# 等语言来完成。不过现在，我们可以用 JavaScript 来开发桌面客户端了！当然，要借助一点外力，那就是：Electron。</p><a id="more"></a><h1 id="什么是Electron？"><a href="#什么是Electron？" class="headerlink" title="什么是Electron？"></a>什么是Electron？</h1><p>Electron 是一个使用 JavaScript，HTML 和 CSS 等Web技术构建跨平台的桌面应用程序的框架。这意味着，如果你可以建一个网站，你就可以建一个桌面应用程序。</p><p>Electron 基于 Chromium 和 Node.js，它可以让你使用纯 JavaScript 调用丰富的原生(操作系统) APIs 来创造桌面应用。你可以把它看作一个 Node. js 的变体，只不过它专注于桌面应用而不是 Web 服务器端。</p><p>但这不意味着 Electron 是某个图形用户界面（GUI）库的 JavaScript 版本。相反，Electron 使用 web 页面作为它的 GUI，所以你可以把它看作成一个被 JavaScript 控制的，精简版的 Chromium 浏览器。</p><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>2013年4月，Atom 编辑器问世，作为实现它的底层框架 Atom Shell 逐渐被熟知。</p><p>2014年5月，Atom Shell 开源。</p><p>2015年4月，Atom Shell 改名为Electron。</p><h1 id="用Electron开发的桌面应用"><a href="#用Electron开发的桌面应用" class="headerlink" title="用Electron开发的桌面应用"></a>用Electron开发的桌面应用</h1><p>Electron 已经被多个开源应用软件所使用，除了 Atom，著名的编辑器 VsCode 也是基于 Electron 实现的。</p><p>打开 VsCode，点击帮助菜单中的<code>Toggle Developer Tools</code>，可以在界面上看到我们熟悉的 Chrome devtool，如下图：</p><p><img src="/images/vscode-devtool.jpg" alt="vscode-devtool.jpg"></p><h1 id="Electron-程序基本结构"><a href="#Electron-程序基本结构" class="headerlink" title="Electron 程序基本结构"></a>Electron 程序基本结构</h1><p>从开发的角度来看, Electron application 本质上是一个 Node.js 应用程序。与 Node.js 模块相同，应用的入口是 package.json 文件。一个最基本的 Electron 应用一般来说会有如下的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your-app/ </span><br><span class="line">├── package.json </span><br><span class="line">├── main.js </span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure><p>说了这么多，是不是有些心痒痒，迫不及待想知道怎么上手electron，用 JS 来捣鼓桌面应用了？别着急，我们先把开发环境搭好。</p><h1 id="安装Electron"><a href="#安装Electron" class="headerlink" title="安装Electron"></a>安装Electron</h1><p>Electron 通过 npm 来安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install electron --save-dev</span><br></pre></td></tr></table></figure><p>但因为默认会从 GitHub 上下载，即使将 npm register 指向 taobao 镜像也不行，它内部还是会通过 GitHub 的发布下载页面来下载 electron 的二进制 release 文件，如果你不能翻墙，安装会很慢，基本上是下不下来。</p><p>所以如果你不能翻墙，又想要顺利下载 electron，就得自定义 electron 的镜像和缓存。</p><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><p>你可以通过环境变量来覆盖 Electron 二进制文件的URL和文件名。这个URL将被 @electron/get 使用，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url = ELECTRON_MIRROR + ELECTRON_CUSTOM_DIR + &apos;/&apos; + ELECTRON_CUSTOM_FILENAME</span><br></pre></td></tr></table></figure><p>例如，使用 Electron 的中国镜像（taobao）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELECTRON_MIRROR=&quot;https://cdn.npm.taobao.org/dist/electron/&quot;</span><br></pre></td></tr></table></figure><p>我们需要在项目根目录下，添加一个名为 .npmrc  的文件，将上面的镜像配置写进去。这样当我们进行 npm install 的时候，就会读取项目根目录下的 .npmrc 文件使用你配置的镜像地址来下载了。</p><h2 id="自定义缓存"><a href="#自定义缓存" class="headerlink" title="自定义缓存"></a>自定义缓存</h2><p>或者，你可以直接覆盖本地缓存。@electron/get 会在本地的特定目录缓存下载下来的二进制文件，来缓解你的网络压力，提升安装速度。所以我们可以使用该缓存文件夹来提供 Electron 的定制版本，或者避免进行网络连接。</p><p>在不同操作系统下，Electron 默认的缓存目录如下：</p><ul><li><p>Linux: $XDG_CACHE_HOME or ~/.cache/electron/</p></li><li><p>MacOS: ~/Library/Caches/electron/</p></li><li><p>Windows: $LOCALAPPDATA/electron/Cache or ~/AppData/Local/electron/Cache/</p></li></ul><blockquote><p>另外：<br>在使用旧版本 Electron 的环境中，我们也可以在 ~/.electron 中找到缓存。<br>我们还可以通过提供 electron_config_cache 环境变量，来重写本地缓存路径。</p></blockquote><p>缓存包含两部分内容：</p><ol><li><p>版本的官方zip文件</p></li><li><p>校验和（存储格式为文本文件）</p></li></ol><p>典型的缓存可能如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├──httpsgithub.comelectronelectronreleasesdownloadv1.8.1electron-v1.8.1-darwin-x64.zip</span><br><span class="line">│   └── electron-v1.8.1-darwin-x64.zip</span><br><span class="line">├──httpsgithub.comelectronelectronreleasesdownloadv1.8.1SHASUMS256.txt</span><br><span class="line">│   └── SHASUMS256.txt</span><br></pre></td></tr></table></figure><p>我们可以直接从淘宝源下载二进制包electron-v1.8.1-darwin-x64.zip，在缓存路径下（例如我这里是 Mac 中的 ~/Library/Caches/electron/ ）新建上述目录结构，放进去。</p><p>electron 淘宝源下载地址（有两个，任意选一个下载就行）：</p><p>1.<a href="https://npm.taobao.org/mirrors/electron/8.1.1/electron-v8.1.1-darwin-x64.zip" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/electron/8.1.1/electron-v8.1.1-darwin-x64.zip</a></p><p>2.<a href="https://cdn.npm.taobao.org/dist/electron/v8.1.1/electron-v8.1.1-darwin-x64.zip" target="_blank" rel="noopener">https://cdn.npm.taobao.org/dist/electron/v8.1.1/electron-v8.1.1-darwin-x64.zip</a></p><p>校验和淘宝源下载地址：</p><p><a href="https://npm.taobao.org/mirrors/electron/8.1.1/SHASUMS256.txt" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/electron/8.1.1/SHASUMS256.txt</a></p><p>配置完缓存后，再来 npm install ，npm 会先从缓存目录中读取二进制缓存，由于我们已经下载好了，npm 会直接使用缓存，而不会再去网络上获取了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>现在，我们已经准备好了 electron 的开发环境了，接下来我们将要开发一个最简单的 elecrton 应用。（下一篇待续）</p><p>有兴趣交流的小伙伴可以在这里留言讨论：<a href="https://github.com/yc111/yc111.github.io/issues/1" target="_blank" rel="noopener">https://github.com/yc111/yc111.github.io/issues/1</a></p><p><br></p><p>文章首发于于公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底弄懂GMT、UTC、时区和夏令时</title>
      <link href="/2020/04/24/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82GMT%E3%80%81UTC%E3%80%81%E6%97%B6%E5%8C%BA%E5%92%8C%E5%A4%8F%E4%BB%A4%E6%97%B6/"/>
      <url>/2020/04/24/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82GMT%E3%80%81UTC%E3%80%81%E6%97%B6%E5%8C%BA%E5%92%8C%E5%A4%8F%E4%BB%A4%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>格林威治时间、世界时、祖鲁时间、GMT、UTC、跨时区、夏令时，这些眼花缭乱的时间术语，我们可能都不陌生，但是真正遇到问题，可能又不那么确定，不得不再去查一查，处理完可能过段时间又忘记。今天，我们彻底来梳理一下它们。</p></blockquote><a id="more"></a><h1 id="一、GMT"><a href="#一、GMT" class="headerlink" title="一、GMT"></a>一、GMT</h1><h2 id="什么是GMT"><a href="#什么是GMT" class="headerlink" title="什么是GMT"></a>什么是GMT</h2><p>GMT（Greenwich Mean Time）， 格林威治平时（也称格林威治时间）。</p><p>它规定太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间为中午12点。</p><h2 id="GMT的历史"><a href="#GMT的历史" class="headerlink" title="GMT的历史"></a>GMT的历史</h2><p>格林威治皇家天文台为了海上霸权的扩张计划，在十七世纪就开始进行天体观测。为了天文观测，选择了穿过英国伦敦格林威治天文台子午仪中心的一条经线作为零度参考线，这条线，简称格林威治子午线。</p><p>1884年10月在美国华盛顿召开了一个国际子午线会议，该会议将格林威治子午线设定为本初子午线，并将格林威治平时 (GMT, Greenwich Mean Time) 作为世界时间标准（UT, Universal Time）。由此也确定了全球24小时自然时区的划分，所有时区都以和 GMT 之间的偏移量做为参考。</p><p>1972年之前，格林威治时间（GMT）一直是世界时间的标准。1972年之后，GMT 不再是一个时间标准了。</p><h1 id="二、UTC"><a href="#二、UTC" class="headerlink" title="二、UTC"></a>二、UTC</h1><h2 id="什么是UTC"><a href="#什么是UTC" class="headerlink" title="什么是UTC"></a>什么是UTC</h2><p>UTC（Coodinated Universal Time），协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。</p><p>UTC 是现在全球通用的时间标准，全球各地都同意将各自的时间进行同步协调。UTC 时间是经过平均太阳时（以格林威治时间GMT为准）、地轴运动修正后的新时标以及以秒为单位的国际原子时所综合精算而成。</p><p>在军事中，协调世界时会使用“Z”来表示。又由于Z在无线电联络中使用“Zulu”作代称，协调世界时也会被称为”Zulu time”。</p><h2 id="UTC-由两部分构成："><a href="#UTC-由两部分构成：" class="headerlink" title="UTC 由两部分构成："></a>UTC 由两部分构成：</h2><ul><li><p>原子时间（TAI, International Atomic Time）:<br>结合了全球400个所有的原子钟而得到的时间，它决定了我们每个人的钟表中，时间流动的速度。</p></li><li><p>世界时间（UT, Universal Time）:<br>也称天文时间，或太阳时，他的依据是地球的自转，我们用它来确定多少原子时，对应于一个地球日的时间长度。</p></li></ul><h2 id="UTC的历史"><a href="#UTC的历史" class="headerlink" title="UTC的历史"></a>UTC的历史</h2><p>1960年，国际无线电咨询委员会规范统一了 UTC 的概念，并在次年投入实际使用。</p><p>“Coordinated Universal Time”这个名字则在1967年才被正式采纳。</p><p>1967年以前， UTC被数次调整过，原因是要使用闰秒（leap second）来将 UTC 与地球自转时间进行统一。</p><h1 id="三、GMT-vs-UTC"><a href="#三、GMT-vs-UTC" class="headerlink" title="三、GMT vs UTC"></a>三、GMT vs UTC</h1><p>GMT是前世界标准时，UTC是现世界标准时。<br>UTC 比 GMT更精准，以原子时计时，适应现代社会的精确计时。<br>但在不需要精确到秒的情况下，二者可以视为等同。<br>每年格林尼治天文台会发调时信息，基于UTC。</p><h1 id="四、时区"><a href="#四、时区" class="headerlink" title="四、时区"></a>四、时区</h1><p>随着火车铁路与其他交通和通讯工具的发展，以及全球化贸易的推动，各地使用各自的当地太阳时间带来了时间不统一的问题，在19世纪催生了统一时间标准的需求，时区由此诞生。</p><h2 id="时区是如何定义的"><a href="#时区是如何定义的" class="headerlink" title="时区是如何定义的"></a>时区是如何定义的</h2><p>从格林威治本初子午线起，经度每向东或者向西间隔15°，就划分一个时区，在这个区域内，大家使用同样的标准时间。</p><p>但实际上，为了照顾到行政上的方便，常将1个国家或1个省份划在一起。所以时区并不严格按南北直线来划分，而是按自然条件来划分。另外：由于目前，国际上并没有一个批准各国更改时区的机构。一些国家会由于特定原因改变自己的时区。</p><p>全球共分为24个标准时区，相邻时区的时间相差一个小时。<br><img src="/images/time-timezone.png" alt="time-timezone.png"></p><p>在不同地区，同一个时区往往会有很多个不同的时区名称，因为名称中通常会包含该国该地区的地理信息。在夏令时期间，当地的时区名称及字母缩写会有所变化（通常会包含“daylight”或“summer”字样）。</p><p>例如美国东部标准时间叫：EST，Estern Standard Time；而东部夏令时间叫：EDT，Estern Daylight Time。</p><blockquote><p>想查看世界所有时区的名字可以访问这个网站：<br><a href="https://www.timeanddate.com/time/zones/" target="_blank" rel="noopener">https://www.timeanddate.com/time/zones/</a></p></blockquote><h1 id="四、夏令时"><a href="#四、夏令时" class="headerlink" title="四、夏令时"></a>四、夏令时</h1><h2 id="什么是夏令时"><a href="#什么是夏令时" class="headerlink" title="什么是夏令时"></a>什么是夏令时</h2><p>DST（Daylight Saving Time），夏令时又称夏季时间，或者夏时制。</p><p>它是为节约能源而人为规定地方时间的制度。一般在天亮早的夏季人为将时间提前一小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。</p><p>全球约40%的国家在夏季使用夏令时，其他国家则全年只使用标准时间。标准时间在有的国家也因此被相应地称为冬季时间。</p><p>在施行夏令时的国家，一年里面有一天只有23小时（夏令时开始那一天），有一天有25小时（夏令时结束那一天），其他时间每天都是24小时。<br><img src="/images/time-daylight-time.jpg" alt="time-daylight-time.jpg"></p><p>绿色部分为2019年统计的在全球施行冬夏令时的国家和地区。</p><h2 id="夏令时的历史"><a href="#夏令时的历史" class="headerlink" title="夏令时的历史"></a>夏令时的历史</h2><p>1784年，美国驻法国大使本杰明·富兰克林（Benjamin Franklin）提出“日光节约时间制”。1908年，英国建筑师威廉·维莱特（William Willett）再次提出，但当时该提案并未被采纳。</p><p>1916年，处于一战时期的德国政府下令将时钟推至一个小时后，通过获得额外一小时的日光来节省战争所需的煤炭，成为第一个实行夏时制的国家。随后，英法俄美四个一战参战国纷纷效仿。</p><p>美国在一战结束后于1919年取消夏时制，但在1942年二战时，美国重新启动夏令时制，1966年正式立法确定永久使用。1973至1975年石油危机爆发期间，美国连续两年延长夏令时制，以节省石油。</p><p>欧洲大部分国家则是从1976年——第四次中东战争导致首次石油危机（1973年）的3年后才开始施行夏令时制。</p><p>1986年4月，中国国务院办公厅发出《在全国范围内实行夏时制的通知》，要求全民早睡早起节约能源：每年4月中旬的第一个星期日2时，将时钟拨快一小时；10月中旬第一个星期日的2时，再将时钟拨慢一小时。但此夏令时只实行了6年，在1992年停止施行，主因是中国东西地域广阔却只奉行一个北京时间，实时夏令时制带来很多不切实际的反效果。</p><h2 id="夏令时的争议"><a href="#夏令时的争议" class="headerlink" title="夏令时的争议"></a>夏令时的争议</h2><p>从过去的100多年来看，夏令时往往是在国家发生严重危机（如战争和能源短缺）的情况下才会受到青睐。而在相对和平的近10年里，这种时间制度则变得越来越不受欢迎。</p><p>它会使得人们的生物钟被扰乱，常常陷入睡眠不足的情况，不仅对人体健康有害、导致车祸，还会对旅游、航空领域造成极大的混乱。</p><p>另外，冬、夏令时究竟能否起到节能的作用，也仍有待商榷。美国一项截至2014年3月的研究表明，这种时间转换制度最多能在3、4月帮助美国减少1%的用电量，而美国国家标准局则认为，夏令时对用电量没有丝毫影响。 </p><p>在俄罗斯，此前的一份报告也显示，夏令时帮助俄罗斯每年节约的电量，仅相当于两三个火力发电厂的发电量，十分的“鸡肋”。</p><p>去年（2019年）3月26日，作为全世界第一个提出并实行夏令时的国家，德国，在欧洲议会上以410比192的赞成票通过了取消冬、夏令时转换制提案，拟定于2021年4月起，所有欧盟国家不再实行冬、夏令时转换。待各成员国形成最终法案后，将选择永久使用夏令时时间或是冬令时时间。</p><h1 id="五、本地时间"><a href="#五、本地时间" class="headerlink" title="五、本地时间"></a>五、本地时间</h1><p>在日常生活中所使用的时间我们通常称之为本地时间。这个时间等于我们所在（或者所使用）时区内的当地时间，它由与世界标准时间（UTC）之间的偏移量来定义。这个偏移量可以表示为 UTC- 或 UTC+，后面接上偏移的小时和分钟数。</p><h1 id="六、JavaScript中的Date"><a href="#六、JavaScript中的Date" class="headerlink" title="六、JavaScript中的Date"></a>六、JavaScript中的Date</h1><p>得到本地时间，在不同时区打印 new Date() ，输出的结果将会不一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Date();</span><br></pre></td></tr></table></figure></p><p>得到本地时间距 1970年1月1日午夜（GMT时间）之间的毫秒数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Date().getTime();</span><br></pre></td></tr></table></figure></p><p>返回本地时间与 GMT 时间之间的时间差，以分钟为单位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Date().getTimezoneOffset();</span><br></pre></td></tr></table></figure></p><p>如何在任何地方都能正确显示当地时间（只要知道该地的timezone）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//目标表时间，东八区</span><br><span class="line">let timezone = 8；</span><br><span class="line">//获取本地时间与格林威治时间的时间差(注意是分钟，记得转换)</span><br><span class="line">const diff = new Date().getTimezoneOffset();</span><br><span class="line">//根据本地时间和时间差获得格林威治时间</span><br><span class="line">const absTime = new Date().getTime() + diff * 60 * 1000;</span><br><span class="line">//根据格林威治时间和各地时区，得到各地时区的时间</span><br><span class="line">let localTime = new Date(absTime + timeZone * 60 * 60 * 1000)；</span><br><span class="line">//处理夏令时(isDST为自己封装的处理方法)</span><br><span class="line">if(isDST(localTime, country)) &#123;</span><br><span class="line">  localTime = new Date(absTime + (timeZone + 1) * 60 * 60 * 1000)；</span><br><span class="line">&#125;</span><br><span class="line">return localTime;</span><br></pre></td></tr></table></figure></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上分别从定义、来源等维度解释和扩展说明了GMT、UTC、时区和夏令时的概念、历史、意义，并在最后列举了这些概念在JS项目中的一个非常实用的应用。</p><p>简单地讲， GMT 是以前的世界时间标准；UTC 是现在在使用的世界时间标准；时区是基于格林威治子午线来偏移的，往东为正，往西为负；夏令时是地方时间制度，施行夏令时的地方，每年有2天很特殊（一天只有23个小时，另一天有25个小时）。</p><p>从源头上彻底了解了这些概念，将会让我们在处理与时间相关的问题时如虎添翼。</p><p><br></p><p>文章同时发表于公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>疫情地图（公益）</title>
      <link href="/2020/04/10/%E7%96%AB%E6%83%85%E5%9C%B0%E5%9B%BE(%E5%85%AC%E7%9B%8A%E9%A1%B9%E7%9B%AE)/"/>
      <url>/2020/04/10/%E7%96%AB%E6%83%85%E5%9C%B0%E5%9B%BE(%E5%85%AC%E7%9B%8A%E9%A1%B9%E7%9B%AE)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声，有一分热，发一份光，就令萤火虫一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火，我便是唯一的光。</p><p><img src="/images/covid001.png" alt="covid_map.png"></p><p>上面这个网站就是我们发布的疫情地图，我是这个项目的开发者。开发时忙到飞起，发布后狠狠休息了几天，今天终于缓过来，决定把这一段难忘经历好好写一写。</p></blockquote><a id="more"></a><h2 id="结缘公益"><a href="#结缘公益" class="headerlink" title="结缘公益"></a>结缘公益</h2><p>今天是2020年4月9日，距离我们发布全球疫情地图已经过去了3周。昨天凌晨，武汉解封，这意味着国内疫情战争的胜利，虽然防范仍然不能松懈，但是紧张的疫情终于告一段落！与国内形成鲜明对比的，是欧美各国日益严峻的 COVID-19 感染和死亡情况。这是今天的全球数据：美国以40多万确诊数高居第一，中国已经降到第六。</p><p>而3个月前，1月23日，武汉宣布封城。微博，公众号，b站，百度等各大社交、新闻媒体都密集地推送着新冠肺炎的新闻、事态、故事、和求助。</p><p>1月27日我在知乎发表了一篇「《新型冠状病毒肺炎预防手册》电子书」的文章，把有幸从湘雅医学院老师那获取到的一份从学术角度分析的实用科普手册，分享了出去，短时间内就有几千人阅读。在原帖的基础上，我不时地把我收集到的小tip更新上去，希望为新冠肺炎防护知识的普及作出一点微小的贡献。</p><p>本以为，我对抗击疫情的能做的事就仅限于此了。</p><p>直到，1月30日，我在浏览知乎的时候，无意看到一篇关于新冠疫情志愿者组织的文章，通过里面贴出的二维码，我加入了其中一个组织——nCoV疫情地图项目组。</p><h2 id="负责开发"><a href="#负责开发" class="headerlink" title="负责开发"></a>负责开发</h2><p>很快有相关人找到了我。简单沟通后，我开始着手开发。</p><p>用了不到2天时间，我搭建好框架并做了一版仿丁香园的 Demo，发了过去。</p><p><img src="/images/covid002.png" alt="covid_map_demo.png"><br>2月1日，组织方表示，将在我的代码基础上进行开发，我也顺理成章成为了这个志愿者项目的前端负责人。</p><p>之后，不断有新的志愿者加入进来，群成员不断壮大，我同时担起了分配任务的职责。还好我搭的框架够健壮，分配的任务都可以很有逻辑地在框架中找到位置。我们的代码开源托管在 GitHub 上，为了在 GitHub 上更好地多人协作，我不得不马上制定了 GitHub 协作规范，约定分支管理、pr 和代码审核流程。事实证明效果非常好，大家开始有意识地通过 pr 来贡献代码。</p><p><img src="/images/covid003.png" alt="covid_map_github.png"><br>一切都进展的如火如荼，一片欣欣向荣的景象。</p><p>然而这场顺利的场景没有持续多久。</p><p>首先是年假结束，参与开发的人陆续开始上班，逐渐退出。然后是我们在2月中旬遭受了一个非常大的组织动荡，让前一秒还在贡献代码的我们有些措手不及。。。由于影响较大，志愿者们的积极性受到了很大的打击，而此时，我们的项目还只开发了不到三分之一。。。</p><h2 id="舍弃旧版"><a href="#舍弃旧版" class="headerlink" title="舍弃旧版"></a>舍弃旧版</h2><p>消沉了几天，不忍看到项目就此夭折，我决定尝试独自奋战，完成它。</p><p>我做了这些事情：</p><h3 id="1-精简需求"><a href="#1-精简需求" class="headerlink" title="1. 精简需求"></a>1. 精简需求</h3><p>首先，我砍掉了之前产品组提出的需求中的非核心的功能，将业务聚焦到实时地图和数据播放着两个核心功能上。</p><image src="/images/covid004.png" art="covid_map_modules.png" style="width: 600px"></image><h3 id="2-重新设计交互"><a href="#2-重新设计交互" class="headerlink" title="2. 重新设计交互"></a>2. 重新设计交互</h3><p>然后，我舍弃了之前设计组提供的半成品设计稿，以自己的设计经验（我曾是一名设计师），重新设计了交互和视觉。</p><p><img src="/images/covid005.png" alt="covid_map_design.png"><br>最大化地图的视野，突出重点信息，尽可能地做到简洁和体验友好。</p><ul><li><p>地图控制栏：</p><image src="/images/covid006.png" art="covid_map_toolbar.png" style="width: 350px"></image></li><li><p>疫情时间轴，可以自动播放、手动上一天下一天，也可以直接点击查看某一天的数据：</p><image src="/images/covid007.png" art="covid_map_timeline.png" style="width: 350px"></image></li><li><p>全球 COVID-19 病例累计dashboard：</p><image src="/images/covid008.png" art="covid_map_dashboard.png" style="width: 350px"></image></li><li><p>全球感染国家的确诊、死亡、治愈统计表，可以按不同维度排序，点击国家地图联动定位到该区域：</p><image src="/images/covid009.png" art="covid_map_datatable.png" style="width: 350px"></image></li></ul><h3 id="3-重构代码"><a href="#3-重构代码" class="headerlink" title="3. 重构代码"></a>3. 重构代码</h3><p>之前由于人多手杂，又追求快，地图业务逻辑代码交织耦和在一块，非常不利于复用、扩展和维护。于是我花了一些时间，重构了一把。</p><p><img src="/images/covid010.png" alt="covid_map_refactor.png"></p><h3 id="4-增强功能"><a href="#4-增强功能" class="headerlink" title="4. 增强功能"></a>4. 增强功能</h3><p>在开发的过程中我随手给网站加上了一些增强的功能：</p><ul><li><p>支持换肤<br><img src="/images/covid011.png" alt="covid_map_skin.png"></p></li><li><p>支持多语言<br><img src="/images/covid012.png" alt="covid_map_lan.png"></p></li><li><p>支持移动端友好</p><image src="/images/covid013.png" art="covid_map_mobile.png" style="width: 350px"></image></li></ul><p>这些做完，几乎是推翻了所有原有的功能和设计，完成了一版全新的疫情地图！</p><p>现在，距离一个可用产品，还差数据接口和部署两步。</p><h2 id="搞定后台"><a href="#搞定后台" class="headerlink" title="搞定后台"></a>搞定后台</h2><p>疫情数据和数据接口本应由后端开发组提供，但是始终没有动静，估计是无法等到了。不等了，我自己来吧！</p><h3 id="1-解决数据问题"><a href="#1-解决数据问题" class="headerlink" title="1. 解决数据问题"></a>1. 解决数据问题</h3><p>造数据库已来不及，只能爬数据。通过对丁香园、百度疫情地图、新浪等公开的网站的数据结构分析，锁定MapBox官网上的疫情地图网页，上面的数据非常符合我的需求。</p><p>研究了它的网站接口后，我用 <code>nodejs + express</code> 成功爬取到了我需要的疫情数据。</p><p>随着将其封装为数据API接口、在 nodejs 服务端配置 cors 解决完跨域的问题，数据接口服务搞定！</p><h3 id="2-解决部署"><a href="#2-解决部署" class="headerlink" title="2.解决部署"></a>2.解决部署</h3><p>在自己购买的阿里云服务器上，我将80端口交给了 nginx ，便于以后做集群和负载均衡。</p><p>用 <code>nodejs + express + pm2</code>  部署了好了一个支持 history 前端路由的静态资源服务器。</p><p>然后通过 nginx 将两个服务（数据 api 接口服务器和网站静态资源服务器）进行反向代理。</p><p>最后将前端打包后的资源文件往public目录一放。</p><p>部署也搞定了！</p><h3 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3.性能优化"></a>3.性能优化</h3><p>目前，打开网站，基本上5秒内首屏即可加载完毕（当然，还需要继续优化），这个速度已经是我做了性能优化的结果，有兴趣可以看我之前的这篇文章<a href="https://mp.weixin.qq.com/s/CNZp26jzBPv4uTZ4ctjHnQ?token=1712334281&amp;lang=zh_CN" target="_blank" rel="noopener">「一次网上优化全记录」</a>，详细记录了我将首屏加载由1分钟优化到5秒的过程。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>做完所有我认为可以做的事情之后，3月16日，我将在自己的服务器部署的最终版 <a href="http://map.champyin.com/situation" target="_blank" rel="noopener">coronovirus-map</a> 地址，发给了组织方(当时来不及买域名，给的裸的ip地址)。</p><p>组织群里惊喜不已，沉寂好久的群也开始变得热闹起来，接下来的事情，我就轻松了。负责宣传的志愿者们张罗着在组织的新公众号「地图学人」上发表了文章：「关于疫情，这是独一份的热图——nCoV疫情地图（PC端）发布」，隆重地官宣了一番。</p><p>当天，地图就有美国、加拿大、澳大利亚等境外的用户在访问了。</p><image src="/images/covid014.png" art="covid_map_visitor.png" style="width: 600px"></image><p>另外，我居然收到了加入的另一个自愿者组织——武汉2020发送的公益志愿者证书，我在那个组织只是冒泡咨询，远没有在这个组织做的事情多，然而却发给了我这么有仪式感的证书，感觉逼格比我们高得多啊🤪</p><image src="/images/covid015.png" art="covid_map_reward.png" style="width: 350px"></image><p>3月19日，由组织发起人的推荐，我接受了中国日报 China Daily 新闻记者的采访。</p><p>4月1日，ChinaDaily 在 Youth 板块刊登了对我们的报道。</p><image src="/images/covid016.png" art="covid_map_report.png" style="width: 350px"></image><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>covid-19 疫情在世界范围内还没有结束，通过这份地图，我们可以很直观地看到整个疫情在世界范围内一路演变的历程。美国和欧洲感染率一度以指数级在增长。希望疫苗能早日研发出来。在那之前，这份地图将持续承担展示全球疫情态势的任务，为用户提供疫情数据可视化的服务。</p><p>感谢当初没有无视那些二维码的自己，才能有这样一个契机，用自己擅长的的专业能力为抗击疫情做了微小的贡献。</p><p>感谢这些自愿者组织的发起人们，让我们一群互不相识的人聚在了一起，用善意为疫情做了有意义的事情（虽然过程中也有波折）。</p><p>一直以来我都很想尝试做一次完整的全栈，说起来，也要感谢这次公益项目，给了我实践的机会。</p><p>不要小看自己所做的事，哪怕是非常微小的帮助，也是很有价值的。</p><p>很喜欢鲁迅先生在他的杂文集《热风》中说过的一段话：</p><blockquote><p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声，有一分热，发一份光，就令萤火虫一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火，我便是唯一的光。</p></blockquote><p>愿这个世界越来越好！</p><p>—<br>附上我们的疫情地图地址：<br><a href="http://map.champyin.com/situation" target="_blank" rel="noopener">http://map.champyin.com/situation</a></p><p><br></p><p>文章同时发表于公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
            <tag> covid_19 </tag>
            
            <tag> mapbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发一个时间小程序</title>
      <link href="/2020/04/08/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/04/08/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跟异国他乡的朋友们微信聊天的时候，经常面临时差的问题。我每次想要确定对方现在是几点，总是要口算一下，有时忘记具体时差，或者涉及跨天，还得打开浏览器查一下，很不方便。有什么方法可以把朋友们所在城市的时间集中起来随时供自己查看呢？于是想到了微信小程序。找了找市面上的时间小程序，不是功能太杂就是小广告太多，不满意。天音：为什么不自己动手量身打造一个呢？</p><a id="more"></a><p>行动起来。</p><h2 id="首先快速明确需求"><a href="#首先快速明确需求" class="headerlink" title="首先快速明确需求"></a>首先快速明确需求</h2><p>很简单：</p><ol><li>需要展示时间的城市初定：加州、纽约，再加北京做对比</li><li>需要显示具体的时分秒，和年月日</li><li>需要实时变化</li><li>在其他国家也能正确展示时间</li></ol><h2 id="然后创建项目开撸"><a href="#然后创建项目开撸" class="headerlink" title="然后创建项目开撸"></a>然后创建项目开撸</h2><blockquote><p>怎么创建和前期的准备就不在这里展开了，相信不少人都熟悉。如果不熟悉小程序开发的可以参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">官网</a> 或者我的另一篇文章<a href="https://champyin.com/2020/04/07/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">如何开发微信小程序</a> ，上面有对如何开发小程序的简明扼要的的介绍。</p></blockquote><h3 id="关键逻辑"><a href="#关键逻辑" class="headerlink" title="关键逻辑"></a>关键逻辑</h3><p>这个小程序的核心是时间的处理。如何得到其他地区的时刻信息？</p><p>这还不简单？<br>先获取本地时刻，然后加上或者减去另外一个地点与国内（北京时间）的时差（小时），最多再处理一下跨天的情况，不就得到其他地点的时刻了？</p><p>我一开始也是这么想的，做完觉得还挺美，准备提交的时候，突然意识到问题：我时差全是基于北京时间计算的，换在其他国家访问，获取的本地时间已经不是北京时间了，时差应该变才对，写死了时差可还行？！发布一个只能在国内使用的鸡肋时间工具，可不是我的风格！</p><p>捣鼓一阵，新方案出炉：</p><ol><li>想办法获得零时区的时间</li><li>获取不同地区与零时区的时差（时区）</li><li>用零时区的时间加减与零时区的时差（时区），得到各地的绝对时间</li></ol><h4 id="1-获得零时区的时间"><a href="#1-获得零时区的时间" class="headerlink" title="1. 获得零时区的时间"></a>1. 获得零时区的时间</h4><p>零时区，也叫中时区，位于英国格林威治本初子午线上。该时区的地方时，叫做格林威治时间，也叫世界时。</p><p>我们不能直接获得格林威治时间，但是我们可以获得本地与格林威治的时间差：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> diff = <span class="keyword">new</span> <span class="built_in">Date</span>().getTimezoneOffset() <span class="comment">// 单位为分钟</span></span><br></pre></td></tr></table></figure></p><p>然后根据本地时间和时间差获得格林威治时间：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> absTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + diff * <span class="number">60</span> * <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></p><h4 id="2-查询各地时区"><a href="#2-查询各地时区" class="headerlink" title="2. 查询各地时区"></a>2. 查询各地时区</h4><p>格林威治本初子午线将地球划分为东西两个半球，格林威治本初子午线为零时区，往西依次为西一区到西十一区，往东依次为东一区到东十一区，西十二区和东十二区重合成为东西十二区，一共划分了24个时区，每个时区相差正好是1个小时。</p><p>北京是东八区，纽约是西五区，加州是西八区。</p><p>完整时区地图：<br><img src="/images/timezone-map.jpg" alt="timezone-map.jpg"></p><h4 id="3-计算各地的绝对时间"><a href="#3-计算各地的绝对时间" class="headerlink" title="3. 计算各地的绝对时间"></a>3. 计算各地的绝对时间</h4><p>东时区的时刻比零时区快，西时区的时刻比零时区慢，所以东时区为正，西时区为负，所有时间计算记得转换为毫秒。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> localTime = <span class="keyword">new</span> <span class="built_in">Date</span>(absTime + timeZone * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>获取任何时区的绝对时间的完整核心代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timeZone: 东n区为正，西n区为负, 单位为小时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> getFullTimeInfo = <span class="function">(<span class="params">timeZone, country, spliter</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取本地时间与格林威治时间的时间差(注意是分钟，记得转换)</span></span><br><span class="line">  <span class="keyword">const</span> diff = <span class="keyword">new</span> <span class="built_in">Date</span>().getTimezoneOffset();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据本地时间和时间差获得格林威治时间</span></span><br><span class="line">  <span class="keyword">const</span> absTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + diff * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据格林威治时间和各地时区，得到各地时区的时间</span></span><br><span class="line">  <span class="keyword">let</span> localTime = <span class="keyword">new</span> <span class="built_in">Date</span>(absTime + timeZone * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    time: formatTime(localTime, spliter)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>很快，第一版就完成了。</p><p><img src="/images/world-time-v1.0.0.png" alt="world-time-v1.0.0"></p><p>刚开始这个样子略丑，有点裸奔的赶脚。不过第一版最主要是核心功能，简陋的界面只是暂时的。</p><p>给当地的朋友检验确定时间展示正确后，提交代码、提交审核，2天后收到审核通过的通知（吐槽腾讯的审核效率😓），然后在小程序管理平台点击发布，哦了。</p><p>扫描二维码，打开小程序，然后收藏。以后要看时间了，微信主界面向下一拉，打开我的时间工具，一眼就看到想要知道的时间信息，确实比之前便捷多了。功能虽然简单，界面虽然简陋，但是妥妥滴满足我的需求。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>用了一阵子，觉得样式啥的还是得丰富丰富，于是花了一些时间做了一次改版，实时时间以时钟效果展示，并且修改了布局，顺便重构了一下代码，便于新增地区。</p><p><img src="/images/world-time-v2.0.0.jpg" alt="world-time-v2.0.0"></p><p>嗯，效果似乎还行～</p><h2 id="改BUG"><a href="#改BUG" class="headerlink" title="改BUG"></a>改BUG</h2><p>前几天跟澳洲的朋友聊天，聊着聊着居然发现了我的程序的一个潜在BUG。</p><p>那天是4月4日的早晨（北京时间），我跟朋友吐槽我的一个疑惑：查询悉尼时区为东十区（即与北京相差2小时），但是为啥查询悉尼时间却与北京相差3小时（所以我当时程序中是把悉尼作为东十一区来计算的）。朋友说：是的没错，我们这里现在在使用夏令时，等夏令时结束就恢复2个小时时差了。然后一查，今年澳洲夏令时将在4月5号凌晨3点结束。。。</p><p>也就是说，距离这个BUG发作还有不到一天的时间。。。</p><p>马上打开电脑，改BUG。。。</p><p>根据资料，获得美国和澳大利亚的夏令时规则：</p><ul><li><p>美国<br>每年的3月第二个星期日02:00:00，时钟向前调整1小时，变为03:00:00，开始夏令时。<br>每年的11月第一个星期日02:00:00，时钟向后调整1小时，变为01:00:00，结束夏令时。</p></li><li><p>澳大利亚<br>每年的10月第一个星期日02:00:00，时钟向前调整1小时，变为03:00:00，开始夏令时。<br>每年的4月第一个星期日03:00:00，时钟向后调整1小时，变为02:00:00，结束夏令时。</p></li></ul><blockquote><p>关于夏令时，也挺有意思，有空我会另开一个篇幅来专门讲述。</p></blockquote><p>将夏令时的判断逻辑加上：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timeZone: 东n区为正，西n区为负, 单位为小时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> getFullTimeInfo = <span class="function">(<span class="params">timeZone, country, spliter</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取本地时间与格林威治时间的时间差(注意是分钟，记得转换)</span></span><br><span class="line">  <span class="keyword">const</span> diff = <span class="keyword">new</span> <span class="built_in">Date</span>().getTimezoneOffset();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据本地时间和时间差获得格林威治时间</span></span><br><span class="line">  <span class="keyword">const</span> absTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + diff * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据格林威治时间和各地时区，得到各地时区的时间</span></span><br><span class="line">  <span class="keyword">let</span> localTime = <span class="keyword">new</span> <span class="built_in">Date</span>(absTime + timeZone * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">+  <span class="comment">// 考虑夏令时</span></span><br><span class="line">+  <span class="comment">// judgeDST 是我封装好的一个判断夏令时的方法</span></span><br><span class="line">+  <span class="keyword">const</span> isDST = judgeDST(localTime, country);</span><br><span class="line">+  <span class="keyword">if</span> (isDST) &#123;</span><br><span class="line">+    localTime = <span class="keyword">new</span> <span class="built_in">Date</span>(absTime + (timeZone + <span class="number">1</span>) * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    time: formatTime(localTime, spliter).split(<span class="string">':'</span>).slice(<span class="number">0</span>,<span class="number">2</span>).join(<span class="string">':'</span>), </span><br><span class="line">    isDST</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了现在的版本：<br><img src="/images/world-time-v2.1.0.jpg" alt="world-time-v2.1.0"></p><p>以后对这个小工具我还会不断优化，会越来越灵活，比如支持地区选择，这样每个人都可以定制自己的时差表了。可以期待一下哦～</p><p>最后附上小程序二维码，扫一扫即可体验。</p><p><img src="/images/world-time-qr-code.jpg" alt="world-time-qr-code.jpg"></p><p>–<br>还是毛爷爷说得好：自己动手丰衣足食。</p><p>Happy coding :)</p><p>文章同时发表于公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何开发微信小程序</title>
      <link href="/2020/04/07/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/04/07/%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>小程序是一种不需要下载安装即可使用的应用。它是连接用户与服务的新方式，它实现了应用“触手可及” 的梦想，用户通过扫一扫或者搜一下即可打开应用，应用将无处不在，随时可用，用完即走。</p></blockquote><p>2017年1月，微信正式推出微信小程序。同年9月，支付宝也推出了支付宝小程序。2018年7月，百度也不甘落后，推出百度智能小程序。从此BAT三巨头都进军了小程序领域。</p><p>此篇是微信小程序开发的一个简明介绍和关键说明。</p><a id="more"></a><p>微信小程序的主要开发语言是 JavaScript，如果你使用过 Vue 或者 React，你将会对微信小程序的开发有一种亲切感，它们的一些理念有一些类似，比如数据绑定、数据驱动视图等。</p><p>不过跟开发普通网页不同，开发微信小程序需要进行一些特定的准备工作。</p><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><ol><li>注册小程序账号<br><a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener">注册地址</a></li><li>获取AppID<br>位于小程序管理平台的菜单 “开发”-“开发设置”</li><li>安装小程序开发者工具<br><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">下载地址</a></li><li>配置项目<ul><li>打开小程序开发者工具，用微信扫码登录开发者工具</li><li>新建项目</li><li>选择小程序项目</li><li>选择在本地准备好的代码路径</li><li>填入第二步获取到的AppID</li><li>完成，进入开发界面</li></ul></li></ol><p>微信开发者工具会很贴心地为我们初始化好一个默认的工程，好让我们不用从零开始编写。</p><h1 id="二、一些重要的概念"><a href="#二、一些重要的概念" class="headerlink" title="二、一些重要的概念"></a>二、一些重要的概念</h1><ol><li><p>小程序的组成<br>小程序包含一个描述整体程序的 <code>app</code> 和多个描述各自页面的 <code>page</code>。</p></li><li><p>一个小程序主体部分由三个文件组成，必须放在项目的根目录：</p><ul><li><code>app.js</code> 小程序逻辑</li><li><code>app.json</code> 小程序公共配置——相当于html</li><li><code>app.wxss</code> 小程序公共样式表（非必须）——相当于css</li></ul></li><li><p>一个小程序页面由四个文件组成：</p><ul><li><code>.js</code>文件 页面逻辑</li><li><code>.wxml</code>文件 页面结构</li><li><code>.json</code>文件 页面配置（非必须）</li><li><code>.wxss</code>文件 页面样式表（非必须）</li></ul><p>为了方便开发者减少配置项目，描述页面的四个文件必须具有相同的路径与文件名。</p></li><li><p>最终，一个小程序的基本目录结构，大致长这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|—pages/</span><br><span class="line">|   |—about/</span><br><span class="line">|      |—about.js</span><br><span class="line">|      |—about.json</span><br><span class="line">|      |—about.wxml</span><br><span class="line">|      |—about.wxss</span><br><span class="line">|—app.js</span><br><span class="line">|—app.json</span><br><span class="line">|—app.wxss</span><br><span class="line">|—project.config.js // 工具配置,存放开发者对开发工具的一些个性化配置，例如界面颜色、编译配置等</span><br></pre></td></tr></table></figure></li><li><p>宿主环境<br>每个小程序都是运行在它所在的微信客户端上的，通过微信客户端给他提供的运行环境，小程序可以直接获取微信客户端的原生体验和原生能力。</p></li><li><p>基本架构<br>小程序的运行环境分为渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。</p><p>其中渲染层的界面使用 WebView 线程进行渲染，逻辑层采用 jsCore 线程运行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端（Native）做中转，逻辑层发送网络请求也经由 Native 转发。</p><p><img src="/images/wxxcx-architecture.png" alt="微信小程序通信模型"></p></li></ol><h1 id="三、小程序语法"><a href="#三、小程序语法" class="headerlink" title="三、小程序语法"></a>三、小程序语法</h1><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/" target="_blank" rel="noopener">WXML 语法参考</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/" target="_blank" rel="noopener">WXS 语法参考</a></li></ul><h1 id="四、小程序发布流程"><a href="#四、小程序发布流程" class="headerlink" title="四、小程序发布流程"></a>四、小程序发布流程</h1><ol><li>在开发工具里，提交代码，填写版本信息</li><li>在<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">小程序管理平台</a>提交审核</li><li>收到审核通过通知后，在小程序管理平台，点击发布</li><li>小程序将会发布到线上提供服务，可以下载二维码让别人扫码使用了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub疑似遭受中间人攻击</title>
      <link href="/2020/03/27/GitHub%E7%96%91%E4%BC%BC%E9%81%AD%E5%8F%97%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2020/03/27/GitHub%E7%96%91%E4%BC%BC%E9%81%AD%E5%8F%97%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/github-attacked-cover.png" alt="github-attacked-cover.png"></p><p>昨天下午4点多起，github pages 突然不能访问，今早，GitHub 官网也出现不能访问的情况。访问这些网站时，浏览器统一检测出证书无效。</p><a id="more"></a><p>现在是2020年3月27日北京时间13点，目前 github.com 和 pages.github.com 已经恢复访问。</p><p>这是昨天我在访问 github pages 页面的截图：<br><img src="/images/githubpages-attacked.jpg" alt="githubpages-遭到攻击.jpg"></p><p>提示<code>ERR_CERT_AUTHORITY_INVALID</code>网站证书无效。并告诉我：<em>您目前无法访问 pages.github.com，因为此网站使用了 HSTS。网络错误和攻击通常是暂时的，因此，此网页稍后可能会恢复正常。</em>​</p><p>而我在国外的朋友访问却没有问题，开始我还天真地以为是被墙了，后来晚上看到有朋友在朋友圈讨论此事，这才认真去看了下浏览器收到的网站证书：</p><p><img src="/images/github-attacked-003.png" alt="github-attacked-003.png"></p><p>GitHub网站证书居然使用QQ邮箱？AYK？！显然，这不是被墙，这是被攻击了啊。这些网站的证书被攻击者使用的自签名证书代替，导致浏览器无法信任，从而阻止用户访问。这次攻击可能只针对中国IP的访问者，外网并未受到影响。</p><p>兴趣来了，这个留下qq邮箱的人是攻击者吗？</p><p>可能是，也可能不是（这不是废话吗 - -!）。可能是攻击者自信放出自己的邮箱，也有可能是攻击者不小心暴露了自己的邮箱，但也有可能是攻击者放出的烟雾弹，这个qq号只是混淆视听的假线索。</p><p>Anyway，不管怎样，也不妨碍我们去简单人肉这个qq号的主人是谁。搜索qq号 346608453 ，这是一个网名为<code>心即灵山</code>的用户：</p><p><img src="/images/github-attacked-004.png" alt="github-attacked-004.png"></p><p>经查资料，这不是 GitHub 第一次遭受攻击，早在2015年，就受到过一次大规模的中间人攻击，<a href="https://github.blog/2015-03-27-large-scale-ddos-attack-on-github-com/" target="_blank" rel="noopener">github官方日志</a>：<br><img src="/images/github-attacked-in-2015.jpg" alt="github2015年遭受中间人攻击.jpg"></p><p><em>翻译：</em><br><em>我们正在遭受github历史上最大的DDOS(分布式拒绝服务)攻击，攻击从3月26号，周四下午两点开始，攻击手段组合了多种攻击方式，从一些老式的攻击手段到新式，通过浏览器让毫不相干的围观群众参与到对github攻击流量的贡献，根据我们收到的报告推断，我们相信攻击的目的是让我们删除某些特定的内容。</em></p><p>关于中间人攻击，我在百度百科找到了还算通俗易懂的解释：</p><blockquote><p>中间人攻击（Man-in-the-MiddleAttack，简称“MITM攻击”）是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。这是一种由来已久的网络入侵手段，并且当今仍然有着广泛的发展空间，如SMB会话劫持、DNS欺骗等攻击都是典型的MITM攻击。简而言之，所谓的MITM攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而通信的双方却毫不知情。<br>——百度百科</p></blockquote><p><strong>中间人攻击举例：</strong><br>假设爱丽丝（Alice）希望与鲍伯（Bob）通信。同时，马洛里（Mallory）希望拦截会话以进行窃听并可能在某些时候传送给鲍伯一个虚假的消息。</p><p>首先，爱丽丝会向鲍勃索取他的公钥。如果Bob将他的公钥发送给Alice，并且此时马洛里能够拦截到这个公钥，就可以实施中间人攻击。马洛里发送给爱丽丝一个伪造的消息，声称自己是鲍伯，并且附上了马洛里自己的公钥（而不是鲍伯的）。</p><p>爱丽丝收到公钥后相信这个公钥是鲍伯的，于是爱丽丝将她的消息用马洛里的公钥（爱丽丝以为是鲍伯的）加密，并将加密后的消息回给鲍伯。马洛里再次截获爱丽丝回给鲍伯的消息，并使用马洛里自己的私钥对消息进行解密，如果马洛里愿意，她也可以对消息进行修改，然后马洛里使用鲍伯原先发给爱丽丝的公钥对消息再次加密。当鲍伯收到新加密后的消息时，他会相信这是从爱丽丝那里发来的消息。</p><p>整个过程大致会是这样：</p><ol><li>爱丽丝发送给鲍伯一条消息，却被马洛里截获：<br>爱丽丝 <code>“嗨，鲍勃，我是爱丽丝。给我你的公钥”</code> –&gt;马洛里鲍勃</li><li>马洛里将这条截获的消息转送给鲍伯；此时鲍伯并无法分辨这条消息是否从真的爱丽丝那里发来的：<br>爱丽丝马洛里 <code>“嗨，鲍勃，我是爱丽丝。给我你的公钥”</code> –&gt;鲍伯</li><li>鲍伯回应爱丽丝的消息，并附上了他的公钥：<br>爱丽丝马洛里&lt;– <code>[鲍伯的公钥]</code> –鲍伯</li><li>马洛里用自己的公钥替换了消息中鲍伯的公钥，并将消息转发给爱丽丝，声称这是鲍伯的公钥：<br>爱丽丝&lt;– <code>[马洛里的公钥]</code> –马洛里鲍勃</li><li>爱丽丝用她以为是鲍伯的公钥加密了她的消息，以为只有鲍伯才能读到它：<br>爱丽丝 <code>“我们在公共汽车站见面！”</code> –[使用马洛里的公钥加密]–&gt;马洛里鲍勃</li><li>然而，由于这个消息实际上是用马洛里的公钥加密的，所以马洛里可以解密它，阅读它，并在愿意的时候修改它。他使用鲍伯的公钥重新加密，并将重新加密后的消息转发给鲍伯：<br>爱丽丝马洛里 <code>“在家等我！”</code> –[使用鲍伯的公钥加密]–&gt;鲍伯</li><li>鲍勃认为，这条消息是经由安全的传输通道从爱丽丝那里传来的。</li></ol><p>其实马洛里一直夹在它们会话的中间，进行拦截和转发，必要时对内容进行篡改，而爱丽丝和鲍勃均毫不知情。这就是中间人攻击。</p><p>这个例子很形象地说明了在网络安全上的一个关键：通信双方需要某种方法来确定他们是真正拿到了属于对方的公钥，而不是拿到来自攻击者的公钥。否则，这类攻击一般都是可行的，在原理上，可以针对任何使用公钥——密钥技术的通讯消息发起攻击。</p><p>幸运的是，有各种不同的技术可以帮助抵御 <code>MITM</code> 攻击，比如最文章最开始提到的 <code>HSTS</code>。目前大多数网站都开启了加密技术对抗劫持，因此遇到证书伪造的攻击，用户访问会被阻止，用户的损失止步于打开不了网页。</p><p>–</p><p>关于什么是HSTS，推荐大家看这篇文章：<br><a href="https://blog.csdn.net/u014311799/article/details/79037717" target="_blank" rel="noopener">HSTS详解</a></p><p>更多关于中间人网络攻击的信息，有兴趣可以一读这篇：<br><a href="https://juejin.im/post/5aa116eff265da23906b97ce" target="_blank" rel="noopener">对github的中间人攻击</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 网络攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发一个Vue插件</title>
      <link href="/2020/03/05/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAVue%E6%8F%92%E4%BB%B6/"/>
      <url>/2020/03/05/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAVue%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/vue-toast-cover.png" alt="vue-toast-cover.png"></p><blockquote><p>Vue 项目开发过程中​，经常用到插件，比如原生插件 <code>vue-router</code>、<code>vuex</code>，还有 <code>element-ui</code> 提供的 <code>notify</code>、<code>message</code> 等等。这些插件让我们的开发变得更简单更高效。那么 Vue 插件是怎么开发的呢​？​如何自己开发一个 Vue 插件然后打包发布到npm？</p></blockquote><a id="more"></a><p>本文涉及技术点：</p><ol><li>Vue 插件的本质</li><li><code>Vue.extend()</code> 全局方法</li><li>如何手动挂载 <code>Vue</code> 实例</li><li><code>Vue.use()</code> 的原理</li><li>如何打包成 <code>umd</code> 格式</li><li>发布前如何测试 <code>npm</code> 包</li></ol><p><br></p><h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p>什么是Vue插件，它和Vue组件有什么区别​？​来看一下官网的解释：</p><blockquote><p>“插件通常用来为 Vue 添加全局功能。”<br>“组件是可复用的 Vue 实例，且带有一个名字。”<br>—— Vue.js 官网</p></blockquote><p>Emmmm，似乎好像有种朦胧美。。。</p><p>我来尝试解释一下，其实， <code>Vue 插件</code> 和 <code>Vue组件</code> 只是在 <code>Vue.js</code> 中包装的两个概念而已​，不管是插件还是组件，最终目的都是为了实现逻辑复用。它们的本质都是对代码逻辑的封装，只是封装方式不同而已。在必要时，组件也可以封装成插件，插件也可以改写成组件，就看实际哪种封装更方便使用了。</p><p>除此之外，插件是全局的，组件可以全局注册也可以局部注册。</p><p>我们今天只聚焦 Vue 插件。</p><blockquote><p>插件一般有下面几种：</p><ul><li>添加全局方法或者属性。如: vue-custom-element</li><li>添加全局资源：指令/过滤器/过渡等。如 vue-touch</li><li>通过全局混入来添加一些组件选项。如 vue-router</li><li>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</li><li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router<br>—— Vue.js 官网</li></ul></blockquote><h1 id="二、插件的使用"><a href="#二、插件的使用" class="headerlink" title="二、插件的使用"></a>二、插件的使用</h1><p>插件需要通过 <code>Vue.use()</code> 方法注册到全局，并且需要在调用 <code>new Vue()</code> 启动应用之前完成。之后在其他 Vue 实例里面就可以通过 <code>this.$xxx</code> 来调用插件中提供的 API 了。</p><p>下面以实现一个简易的提示框插件 toast 为例，给大家介绍怎么一步一步开发和发布一个 Vue 插件。</p><p>希望达到的效果：<br>在 main.js 中 use：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> toast <span class="keyword">from</span> <span class="string">'@champyin/toast'</span></span><br><span class="line"></span><br><span class="line">Vue.use(toast)</span><br></pre></td></tr></table></figure></p><p>在 App.vue 的生命周期 mounted 方法里调用 this.$toast()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// src/App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   &lt;button @click=&apos;handleClick&apos;&gt;Toast&lt;/button&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &apos;demo&apos;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleClick() &#123;</span><br><span class="line">      this.$toast(&#123;</span><br><span class="line">        type: &apos;success&apos;,</span><br><span class="line">        msg: &apos;成功&apos;,</span><br><span class="line">        duration: 3</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>运行后在页面上点击按钮，弹出 <code>成功</code> 的提示，然后3秒后消失。</p><p><img src="/images/how-to-write-a-vue-plugin01.jpg" alt="how-to-write-a-vue-plugin01.jpg"></p><p>在线地址：<a href="http://champyin.com/toast/">http://champyin.com/toast/</a></p><h1 id="三、插件开发"><a href="#三、插件开发" class="headerlink" title="三、插件开发"></a>三、插件开发</h1><h2 id="1-编写-toast-的本体。"><a href="#1-编写-toast-的本体。" class="headerlink" title="1. 编写 toast 的本体。"></a>1. 编写 toast 的本体。</h2><p>在 Vue 项目（你可以使用 Vue-cli 快速生成一个 Vue 项目，也可以自己用 webpack 搭建一个）的 src 目录下创建 components/Toast/index.vue 文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/Toast/index.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;transition name=<span class="string">'fade'</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">'uco-toast'</span> v-<span class="keyword">if</span>=<span class="string">'isShow'</span>&gt;</span><br><span class="line">      &lt;span :<span class="class"><span class="keyword">class</span></span>=<span class="string">'iconStyle'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">      &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/transition&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isShow: <span class="literal">false</span>,</span><br><span class="line">      type: <span class="string">'success'</span>,</span><br><span class="line">      msg: <span class="string">'成功'</span>,</span><br><span class="line">      duration: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    iconStyle() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`tfont icon-<span class="subst">$&#123;<span class="keyword">this</span>.type&#125;</span> toast-icon`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isShow = <span class="literal">true</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.isShow = <span class="literal">false</span>;</span><br><span class="line">    &#125;, <span class="keyword">this</span>.duration * <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style lang='less' scoped&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 样式略</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure></p><p>现在 toast 本体完成了，但是它里面的数据目前没法改变，因为我没有给它定义 props 属性。这不是 bug，而是，插件并不是通过 pops 来传值的。</p><h2 id="2-手动挂载-toast-实例的-dom"><a href="#2-手动挂载-toast-实例的-dom" class="headerlink" title="2. 手动挂载 toast 实例的 dom"></a>2. 手动挂载 toast 实例的 dom</h2><p>为了给插件传值，可以利用基础 Vue 构造器 <code>Vue.extend()</code> 创建一个“子类”。这个子类相当于一个继承了 Vue 的 Toast 构造器。然后在 new 这个构造函数的时候，给 Toast 的 data 属性传值，然后手动调用这个实例的 <code>$mount()</code> 方法手动挂载，最后使用原生JS的 appendChild 将真实 DOM （通过实例上的 <code>$el</code> 属性获取）添加到 body 上。</p><p>在 src 目录下新建 components/Toast/index.js 文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/Toast/index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">'./index.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Vue.extend() 创建 Toast 的构造器</span></span><br><span class="line"><span class="keyword">const</span> ToastConstructor = Vue.extend(Toast);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toast = <span class="function"><span class="keyword">function</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Toast 实例，通过构造函数传参，</span></span><br><span class="line">    <span class="comment">// 并调用 Vue 实例上的 $mount() 手动挂载</span></span><br><span class="line">    <span class="keyword">const</span> toastInstance = <span class="keyword">new</span> ToastConstructor(&#123;</span><br><span class="line">        data: options</span><br><span class="line">    &#125;).$mount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动把真实 dom 挂到 html 的 body 上</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(toastInstance.$el);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toastInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出包装好的 toast 方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> toast;</span><br></pre></td></tr></table></figure></p><h2 id="3-暴露-install-方法给-Vue-use-使用。"><a href="#3-暴露-install-方法给-Vue-use-使用。" class="headerlink" title="3. 暴露 install 方法给 Vue.use() 使用。"></a>3. 暴露 install 方法给 Vue.use() 使用。</h2><blockquote><p>为了支持 Vue.use()，Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象。<br>—— Vue.js 官网</p></blockquote><p>通过 <a href="https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js" target="_blank" rel="noopener">Vue.js 源码</a>也可以看出，Vue.use() 方法所做的事情就是调用插件或者组件的 install 方法，然后把全局 Vue 传进去供插件和组件使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/vuejs/vue/blob/dev/src/core/global-api/use.js</span></span><br><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: Function | Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = (<span class="keyword">this</span>._installedPlugins || (<span class="keyword">this</span>._installedPlugins = []))</span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// additional parameters</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.unshift(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 src 目录下新建 components/index.js 文件，定义一个 install 方法，在里面将 toast 实例放到 Vue.prototype 上作为 Vue 实例的方法暴露到全局。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/index.js</span></span><br><span class="line"><span class="keyword">import</span> toast <span class="keyword">from</span> <span class="string">'./Toast/index'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../icon/iconfont.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备好 install 方法 给 Vue.use() 使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (install.installed) <span class="keyword">return</span>;</span><br><span class="line">  install.installed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将包装好的 toast 挂到Vue的原型上，作为 Vue 实例上的方法</span></span><br><span class="line">  Vue.prototype.$toast = toast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出 install</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>现在插件就开发完成了，可以在当前项目中本地引用这个插件了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 main.js 中</span></span><br><span class="line"><span class="keyword">import</span> toast <span class="keyword">from</span> src/components/index.js;</span><br><span class="line">Vue.use(toast);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 App.vue 中</span></span><br><span class="line">handleClick()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$toast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四、发布到npm"><a href="#四、发布到npm" class="headerlink" title="四、发布到npm"></a>四、发布到npm</h1><p>为了方便其他人也可以使用到这个插件，我们可以把它发布到 npm 上去。发布的步骤很简单，但是发布之前，需要有一些小配置和一些注意的地方。</p><h2 id="1-打包配置"><a href="#1-打包配置" class="headerlink" title="1. 打包配置"></a>1. 打包配置</h2><p>首先我们要把它打包成可以给浏览器解析的 UMD 格式的的模块，并且去掉对 Vue.js 的打包，这样别人在 Vue 项目中使用这个插件的时候就不会有两份 Vue 或者出现 Vue 版本冲突的问题，以保证可以更好被独立引用。</p><p>如果你是用 Vue-cli 生成的项目，那只需要在你的 npm 脚本中配置一下库的打包命令：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">"build:lib": "vue-cli-service build --target lib --name toast --dest lib  src/components/index.js"</span><br></pre></td></tr></table></figure></p><p>命令说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--target：构建的目标</span><br><span class="line">          targetType 有三个选项：lib | wc | wc-async</span><br><span class="line">          lib：库</span><br><span class="line">          wc：web component</span><br><span class="line">          wc-async：异步的 web component</span><br><span class="line"></span><br><span class="line">--name：库或组件的名字</span><br><span class="line">          当入口为单一文件时，name为库或组件的文件名</span><br><span class="line">          当入口为global表达式时，name为每个库或组件文件名字的前缀</span><br><span class="line"></span><br><span class="line">[entry]：打包入口</span><br><span class="line">          可以是.vue文件，也可以是.js文件</span><br><span class="line">          当注册多个web component时，入口可以是一个global表达式，如 components/*.vue</span><br><span class="line"></span><br><span class="line">--dest：输出目录</span><br><span class="line">          默认为dist目录，也可以修改为自定义的目录</span><br></pre></td></tr></table></figure></p><p>然后运行 <code>npm run build:lib</code>，即可在 lib 目录下生成如下文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toast.umd.js 一个直接给浏览器或者AMD loader 使用的 UMD 包</span><br><span class="line">toast.umd.min.js 一个压缩版 UMD 构建版本</span><br><span class="line">toast.common.js 一个给打包器用的CommonJS包</span><br></pre></td></tr></table></figure></p><p>如果你是用 webpack 搭建的 Vue 项目，那就需要在 webpck 中配置一下 output.libraryTarget 等属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build/webpack.lib.conf.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/components/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../lib'</span>),</span><br><span class="line">    filename: <span class="string">'toast.js'</span>,</span><br><span class="line">    library: <span class="string">'toast'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">    libraryExport: <span class="string">'default'</span>,</span><br><span class="line">    umdNamedDefine: <span class="literal">true</span>,</span><br><span class="line">    globalObject: <span class="string">'typeof self !== \'undefined\' ? self : this'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: &#123;</span><br><span class="line">    vue: &#123;</span><br><span class="line">      root: <span class="string">'Vue'</span>,</span><br><span class="line">      commonjs: <span class="string">'vue'</span>,</span><br><span class="line">      commonjs2: <span class="string">'vue'</span>,</span><br><span class="line">      amd: <span class="string">'vue'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后运行 <code>npm run build:lib</code>，即可在 lib 目录下生成如下文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toast.js 直接给浏览器或者AMD loader 使用的 UMD 包</span><br></pre></td></tr></table></figure></p><h2 id="2-发布前的测试"><a href="#2-发布前的测试" class="headerlink" title="2. 发布前的测试"></a>2. 发布前的测试</h2><p>发布前，我们需要配置一下 <code>package.json</code> 里的 <code>name</code> 和 <code>main</code> 字段：<br><code>name</code> 的值是最终包的名字，<code>install</code> 和 <code>import</code> 的就是这个名字（请确保全网唯一）。<br><code>main</code> 的值是包的入口文件路径（相对当前文件的路径），一定要填写正确，否则包无法被引用。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"name": "@champyin/toast",</span><br><span class="line">"main": "lib/toast.js",</span><br></pre></td></tr></table></figure></p><p>为了确保包的配置没有问题，我们可以利用 <code>npm link</code> 命令在本地测试一下包的使用情况。使用npm link测试包的使用估计很多人都会，就不赘述了。如果有需要可以看我的另一篇中文章<a href="https://champyin.com/2019/08/27/npm-link%E8%AF%A6%E8%A7%A3/">npm link详解</a>。</p><p>这个时候，我们其实就可以发布了，但是为了防止把不必要的文件发布出去（比如测试用例和demo）浪费人家下载的流量，我们最好是建一个 <code>.npmigore</code> 文件，语法跟 <code>.gitignore</code> 相同。</p><h2 id="3-发布"><a href="#3-发布" class="headerlink" title="3. 发布"></a>3. 发布</h2><p>发布的方法很简单(不过首先你要有个 npm 账号)，在 package.json 所在的目录下执行这两句就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm add user</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure></p><p>关于更详细的发布教程，我在另一篇文章有专门细说：<a href="https://champyin.com/2018/06/07/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E6%A8%A1%E5%9D%97/">如何发布一个npm模块</a>。</p><h2 id="4-安装测试"><a href="#4-安装测试" class="headerlink" title="4. 安装测试"></a>4. 安装测试</h2><p>其实到了这一步一99.99%是不会出错了，安装一遍只是为了那 0.01% 的万一。</p><p>在另一个 Vue 项目里（注意不能在开发toast的项目里哈），从 npm 安装自己刚才发布的包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @champyin/toast</span><br></pre></td></tr></table></figure></p><p>然后在项目中使用一下自己的插件，点击按钮就会弹出 toast 小提示了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 main.js 中</span></span><br><span class="line"><span class="keyword">import</span> toast <span class="keyword">from</span> <span class="string">'@champyin/toast'</span>;</span><br><span class="line">Vue.use(toast);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 App.vue 中</span></span><br><span class="line">handleClick()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$toast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><p>项目体验地址：<a href="http://champyin.com/toast/">http://champyin.com/toast/</a><br>npm 地址：<a href="https://www.npmjs.com/package/@champyin/toast" target="_blank" rel="noopener">https://www.npmjs.com/package/@champyin/toast</a><br>欢迎给我提 issue：<a href="https://github.com/yc111/toast/issues" target="_blank" rel="noopener">https://github.com/yc111/toast/issues</a></p><p>Happy coding :)</p><p>文章同时发表于公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p><p>更多参考：<br><a href="https://cn.vuejs.org/v2/guide/plugins.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/plugins.html</a><br><a href="https://cn.vuejs.org/v2/api/#Vue-extend-options" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#Vue-extend-options</a><br><a href="https://cli.vuejs.org/zh/guide/build-targets.html" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/build-targets.html</a><br><a href="https://webpack.js.org/guides/author-libraries/" target="_blank" rel="noopener">https://webpack.js.org/guides/author-libraries/</a><br><a href="https://docs.npmjs.com/cli-commands/link.html" target="_blank" rel="noopener">https://docs.npmjs.com/cli-commands/link.html</a><br><a href="https://docs.npmjs.com/cli-commands/pack.html" target="_blank" rel="noopener">https://docs.npmjs.com/cli-commands/pack.html</a><br><a href="https://www.npmjs.com/package/@champyin/toast" target="_blank" rel="noopener">https://www.npmjs.com/package/@champyin/toast</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑img src=&quot;[object Module]&quot;</title>
      <link href="/2020/03/03/%E8%B8%A9%E5%9D%91img-src-object-Module/"/>
      <url>/2020/03/03/%E8%B8%A9%E5%9D%91img-src-object-Module/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了快速测试自己开发的某个插件功能，我通常都是用webpack快速搭建一个vue项目，这样可以保证没有其他未知因素地干扰。这次也同往常一样顺利，直到，我的插件需要内置一张图片。。。</p></blockquote><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>图片没有出来，查看控制台，img标签的src属性变成了<code>&quot;[object Module]&quot;</code>。图片并没有按照预期编译返回url字符串，而是一个模块对象。<br><img src="/images/img-object01.jpg" alt="img-object01.jpg"></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我就奇怪了，以前都是这么配置的，从没出过问题。</p><p>冷静思考，其实有一点不一样，那就是新安装的依赖插件版本可能比以前的高。而且既然是图片打包的问题，那就优先排查图片处理插件。</p><p>一番操作猛如虎，果然！就是新版本惹的祸！</p><p><code>file-loader</code> 从 5.0 版本开始，将默认输出改成了 <code>esModule</code> 模块！<br><img src="/images/file-loader-v5.0-change.jpg" alt="file-loader-v5.0-change.jpg"></p><p><code>url-loader</code> 从 3.0 版本开始，将默认输出改成了 <code>esModule</code> 模块！<br><img src="/images/url-loader-v3.0-change.jpg" alt="url-loader-v3.0-change.jpg"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>接下来我手动添加了配置 <code>esModule: false</code>（改成输出commonJS模块）。<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(png|jpe?g|gif|bmp)$/,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: 'url-loader',</span><br><span class="line">      options:&#123;</span><br><span class="line">        limit: 1024 * 8,</span><br><span class="line"> +       esModule: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题解决！<br><img src="/images/img-object02.jpg" alt="img-object02.jpeg"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遇到打包错误不要慌乱，不要回避问题。用单一变量法进行排除，以及逻辑判断大致定位问题，然后查看插件版本的 <code>BREAKING CHANGES</code> 记录，基本可以找到答案。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> vue </tag>
            
            <tag> url-loader </tag>
            
            <tag> file-loader </tag>
            
            <tag> img </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git之 git stash</title>
      <link href="/2020/02/25/Git%E4%B9%8B-git-stash/"/>
      <url>/2020/02/25/Git%E4%B9%8B-git-stash/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我有时会遇到这样的情况：正在 dev 分支上开发某个项目，这时有人反馈了一个 bug，需要紧急修复，但是正在开发的内容又不想现在提交，因为只完成了一半（强迫症不想增加一个脏的提交，然后惦记着日后做 <code>rebase</code>，麻烦）。或者是很嗨地开发完了一个功能，快要提交的时候才发现当前所在分支竟然是 master，而这本应是在 dev 分支开发的内容（两条分支并不同步，可能因冲突而不能直接切换分支）。  </p><p>这些时候，我 prefer 使用 <code>git stash</code>（git存储）来快速处理。</p></blockquote><a id="more"></a><h1 id="一、git-stash-的作用"><a href="#一、git-stash-的作用" class="headerlink" title="一、git stash 的作用"></a>一、git stash 的作用</h1><ul><li><code>git stash</code> 可以获取你工作目录的中间状态，并将它保存到一个未完结变更的本地堆栈中，让当前工作区变干净。</li><li>stash 中的内容随时可以重新应用，而且不仅可以恢复到原先开发的分支，还可以应用到其他任意指定的分支上。</li></ul><p>所以你就可以在 <code>git stash</code> 后，顺利地切换到另一个分支去修改 bug，修改完提交后，再切回 dev 分支。然后使用 <code>git stash pop</code> 来恢复之前的进度继续开发新功能。也可以在 <code>git stash</code> 后，从 master 切换到 dev 分支，然后使用 <code>git stash pop</code> 把在 master 上 stash 的内容恢复到 dev 上，然后在 dev 分支上提交。</p><h1 id="二、git-stash-的作用范围"><a href="#二、git-stash-的作用范围" class="headerlink" title="二、git stash 的作用范围"></a>二、git stash 的作用范围</h1><p>git stash 默认会存储以下文件：</p><ul><li>unstaged changes：未添加到暂存区的 <code>git track</code> 文件（曾经 <code>add</code> 过，然后修改了）</li><li>staged changes：添加到暂存区的文件（<code>add</code> 了但还没 <code>commit</code>）</li></ul><p>默认不会存储以下文件：</p><ul><li>untracked files：在工作目录中的新文件（从未 <code>add</code> 过）</li><li>ignored files：被忽略的文件（符合 <code>.gitigore</code> 文件里的规则的文件）</li></ul><p>总结起来，也就是默认只针对你修改过的被追踪的文件和暂存的变更，其他的不管。</p><h1 id="三、stash-存到哪里去了"><a href="#三、stash-存到哪里去了" class="headerlink" title="三、stash 存到哪里去了"></a>三、stash 存到哪里去了</h1><p>git 会在 <code>.git/refs/</code> 目录下建立一个 <code>stash</code> 文件，存放最后一个 stash 的节点指针。<br>然后在 <code>.git/logs/refs/</code> 目录下建立一个 <code>stash</code> 文件，存放所有的 stash 记录（每条记录包括下一个节点指针、当前节点指针、作者、邮箱、hash、stash message 六个字段 ）。</p><h1 id="四、git-stash-的用法"><a href="#四、git-stash-的用法" class="headerlink" title="四、git stash 的用法"></a>四、git stash 的用法</h1><h2 id="stash-当前修改"><a href="#stash-当前修改" class="headerlink" title="stash 当前修改"></a>stash 当前修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>这个命令把当前工作区所有未提交的修改（不包括untrack 和 ignore 的）都保存起来，同时会给每次 stash 添加默认的 message（来自于最后一次commit的message），所以如果你在未commit的期间进行了多次stash，会产生看上去一样的stash记录（其实不一样），因为message完全相同。</p><p>所以，一般我会使用<code>git stash save</code>命令取代<code>git stash</code>，给每次stash填写一个message作为标识。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash save &lt;message&gt;</span><br></pre></td></tr></table></figure></p><h2 id="查看-stash"><a href="#查看-stash" class="headerlink" title="查看 stash"></a>查看 stash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On feature/fix: conflict2 # 自己添加的 message</span><br><span class="line">stash@&#123;1&#125;: On feature/fix: change c </span><br><span class="line">stash@&#123;2&#125;: WIP on feature/fix: 6488467 update # 未加message的stash，获取的最后一次提交日志</span><br></pre></td></tr></table></figure></p><h2 id="重新应用缓存的-stash"><a href="#重新应用缓存的-stash" class="headerlink" title="重新应用缓存的 stash"></a>重新应用缓存的 stash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch feature/fix</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (aed4ca7d79520beebd22af25bc2b21964fa3a0f2)</span><br></pre></td></tr></table></figure></p><p>这个指令将缓存栈中的第一个stash中对应的修改应用到当前的工作目录下，并将这个stash删除。</p><p>你也可以指定 stash list 中的任意一个 stash 来恢复：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash@&#123;num&#125;</span><br><span class="line">git stash pop stash@&#123;2&#125; # 恢复 stash list 中的第三个到当前工作目录</span><br></pre></td></tr></table></figure></p><p>你也可以只应用某个 stash，而不自动删除它，在需要多次应用某个 stash 的时候适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;num&#125;</span><br></pre></td></tr></table></figure></p><h2 id="移除-stash"><a href="#移除-stash" class="headerlink" title="移除 stash"></a>移除 stash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;num&#125;</span><br></pre></td></tr></table></figure><p>删除掉某个 stash 缓存。<code>git stash pop</code> 其实就相当于 <code>git stash apply stash@{0}</code> + <code>git stash drop stash@{0}</code></p><p>你也可以一次删除所有的 stash 缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure></p><h2 id="查看指定-stash-的-diff"><a href="#查看指定-stash-的-diff" class="headerlink" title="查看指定 stash 的 diff"></a>查看指定 stash 的 diff</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash show</span><br></pre></td></tr></table></figure><p>查看 stash 中第一个缓存与当前目录的修改数量。也可以指定stash的名字。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show stash@&#123;0&#125;</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p><p>也可以在命令后添加 -p 或者 -patch 查看具体的修改diff。输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git stash show stash@&#123;0&#125; -p</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 1fd5ae1..08106f6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -4,3 +4,4 @@ test dev</span><br><span class="line"> </span><br><span class="line"> add feature</span><br><span class="line"> </span><br><span class="line">+change c</span><br></pre></td></tr></table></figure></p><h2 id="冲突的处理"><a href="#冲突的处理" class="headerlink" title="冲突的处理"></a>冲突的处理</h2><p>从 stash 里应用缓存的时候，可能会跟当前工作目录上的内容有冲突。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature/fix</span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   readme.txt</span><br></pre></td></tr></table></figure></p><p>这个时候，stash 会在自动合并文件内容后，标出冲突所在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream</span><br><span class="line">change b</span><br><span class="line">=======</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes</span><br><span class="line">change c</span><br></pre></td></tr></table></figure></p><p>Git用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>、<code>=======</code>、<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记出冲突中不同来源的内容。其中：<br><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream</code> 指当前工作区的内容。<br><code>=======</code> 是分割线。<br><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes</code> 指 stash 缓存的修改内容。</p><p>只需跟解决其他冲突一样，处理完冲突（选择保留哪段代码或者都不要重新写）之后，add 和 commit 这个文件即可。</p><h2 id="从-stash-创建分支"><a href="#从-stash-创建分支" class="headerlink" title="从 stash 创建分支"></a>从 stash 创建分支</h2><p>有时候，在当前分支对某次 idea 进行了 stash 之后，又在这个分支做了大量 commit、pull、merge 等操作，再想进行 stash pop 已经很明显会造成冲突，但是你不想处理冲突又很想继续之前的进度完成自己的 idea，有个更方便的方法让你无冲突地恢复你储藏的变更：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash branch &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure></p><p>它会创建一个新的分支，检出你在stash时所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。</p><h2 id="暂存未跟踪或忽略的文件"><a href="#暂存未跟踪或忽略的文件" class="headerlink" title="暂存未跟踪或忽略的文件"></a>暂存未跟踪或忽略的文件</h2><p>刚才有提到，git stash 的默认作用范围不包括未跟踪和忽略的文件，其实你也可以强行暂存他们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash -u #（或者 --include-untracked）stash untracked 文件 </span><br><span class="line">git stash -a #（或者 --a）stash 当前目录下的所有修改</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工具千千万，使用工具的方法千千万，条条大路通罗马，如果没有<code>git stash</code>命令，我们确实照样可以使用 git 做日常代码管理（只是有时不那么便利罢了），但是如果有这么一个高效工具却不去使用那就是给自己添堵了。</p><p>最后我想说：I love git！</p><p>–<br><a href="https://git-scm.com/docs/git-stash" target="_blank" rel="noopener">git官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> stash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx安装（linux环境）</title>
      <link href="/2020/02/21/nginx%E5%AE%89%E8%A3%85%EF%BC%88linux%E7%8E%AF%E5%A2%83%EF%BC%89/"/>
      <url>/2020/02/21/nginx%E5%AE%89%E8%A3%85%EF%BC%88linux%E7%8E%AF%E5%A2%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/nginx-install-cover.png" alt="nginx-install-cover.png"></p><blockquote><p>Nginx 是一款高性能的 <code>Web</code> 和 <code>反向代理</code> 服务器，也是一个 <code>IMAP/POP3/SMTP</code> 代理服务器。它的开发者是俄罗斯工程师：<code>Igor Sysoev</code>。<br>这篇是针对 Linux 操作系统的安装。</p></blockquote><a id="more"></a><p>在 linux 下安装 nginx 有两种方式：一种是源码编译，一种是yum安装。</p><h1 id="一、通过源码编译方式的安装步骤"><a href="#一、通过源码编译方式的安装步骤" class="headerlink" title="一、通过源码编译方式的安装步骤"></a>一、通过源码编译方式的安装步骤</h1><h2 id="step1-wget下载nginx源码"><a href="#step1-wget下载nginx源码" class="headerlink" title="step1: wget下载nginx源码"></a>step1: wget下载nginx源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nginx.org/download/nginx-1.17.1.tar.gz</span><br></pre></td></tr></table></figure><h2 id="step2-tar命令解压"><a href="#step2-tar命令解压" class="headerlink" title="step2: tar命令解压"></a>step2: tar命令解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf nginx-1.17.1.tar.gz</span><br></pre></td></tr></table></figure><h2 id="step3-安装gcc编译工具"><a href="#step3-安装gcc编译工具" class="headerlink" title="step3: 安装gcc编译工具"></a>step3: 安装gcc编译工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc gcc-c++</span><br></pre></td></tr></table></figure><h2 id="step4-安装其他库跟工具"><a href="#step4-安装其他库跟工具" class="headerlink" title="step4: 安装其他库跟工具"></a>step4: 安装其他库跟工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install pure pure-devel openssl openssl-devel zlib zlib-devel</span><br></pre></td></tr></table></figure><h2 id="step5-编译源码并安装"><a href="#step5-编译源码并安装" class="headerlink" title="step5: 编译源码并安装"></a>step5: 编译源码并安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.17.1</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="step6-启动niginx"><a href="#step6-启动niginx" class="headerlink" title="step6: 启动niginx"></a>step6: 启动niginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>Done！</p><p>但是，我觉得步骤实在太繁琐，个人不喜欢这种方式。</p><h1 id="二、通过-yum-安装的步骤-（推荐）"><a href="#二、通过-yum-安装的步骤-（推荐）" class="headerlink" title="二、通过 yum 安装的步骤 （推荐）"></a>二、通过 yum 安装的步骤 （推荐）</h1><p>这也是官方推荐的安装方式<a href="https://nginx.org/en/linux_packages.html" target="_blank" rel="noopener">nginx官网文档</a></p><h2 id="step1-进入-yum-repos-配置目录"><a href="#step1-进入-yum-repos-配置目录" class="headerlink" title="step1: 进入 yum repos 配置目录"></a>step1: 进入 yum repos 配置目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d</span><br></pre></td></tr></table></figure><h2 id="step2-配置-nginx-repo"><a href="#step2-配置-nginx-repo" class="headerlink" title="step2: 配置 nginx.repo"></a>step2: 配置 nginx.repo</h2><p>从官网提供的稳定版和最新版的repo信息(如下)复制一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure></p><p>然后在ssh终端配置 nginx.repo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi nginx.repo # 新建 nginx.repo 文件，将官网提供的稳定版和最新版的repo信息粘贴进去</span><br><span class="line">:wq # 保存并退出 vi</span><br></pre></td></tr></table></figure></p><h2 id="step3-安装"><a href="#step3-安装" class="headerlink" title="step3: 安装"></a>step3: 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure><h2 id="step4-启动nginx"><a href="#step4-启动nginx" class="headerlink" title="step4: 启动nginx"></a>step4: 启动nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>Done！</p><p>在浏览器输入服务器公网ip，回车，即可看到 nginx 欢迎文字，nginx安装启动成功！<br><img src="/images/nginx-welcome.jpg" alt="nginx-welcome.jpg"></p><h1 id="三、其他命令"><a href="#三、其他命令" class="headerlink" title="三、其他命令"></a>三、其他命令</h1><h2 id="查看ngix安装路径"><a href="#查看ngix安装路径" class="headerlink" title="查看ngix安装路径"></a>查看ngix安装路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure><h2 id="测试nginx"><a href="#测试nginx" class="headerlink" title="测试nginx"></a>测试nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><h2 id="修改nginx-conf配置后，重载nginx"><a href="#修改nginx-conf配置后，重载nginx" class="headerlink" title="修改nginx.conf配置后，重载nginx"></a>修改nginx.conf配置后，重载nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><br></h2><p>文章同时发表于公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> linux </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭秘webpack loader</title>
      <link href="/2020/01/28/%E6%8F%AD%E7%A7%98webpack-loader/"/>
      <url>/2020/01/28/%E6%8F%AD%E7%A7%98webpack-loader/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/webpack-loader-cover.png" alt="webpack-loader-cover.png"></p><blockquote><p>Loader(加载器) 是 webpack 的核心之一。它用于将不同类型的文件转换为 webpack 可识别的模块。本文将尝试深入探索 webpack 中的 loader，揭秘它的工作原理，以及如何开发一个 loader。</p></blockquote><a id="more"></a><h1 id="一、Loader-工作原理"><a href="#一、Loader-工作原理" class="headerlink" title="一、Loader 工作原理"></a>一、Loader 工作原理</h1><p>webpack 只能直接处理 javascript 格式的代码。任何非 js 文件都必须被预先处理转换为 js 代码，才可以参与打包。loader（加载器）就是这样一个代码转换器。它由 webpack 的 <code>loader runner</code> 执行调用，接收原始资源数据作为参数（当多个加载器联合使用时，上一个loader的结果会传入下一个loader），最终输出 javascript 代码（和可选的 source map）给 webpack 做进一步编译。</p><h1 id="二、-Loader-执行顺序"><a href="#二、-Loader-执行顺序" class="headerlink" title="二、 Loader 执行顺序"></a>二、 Loader 执行顺序</h1><h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h2><ul><li>pre： 前置loader</li><li>normal： 普通loader</li><li>inline： 内联loader</li><li>post： 后置loader</li></ul><h2 id="2-执行优先级"><a href="#2-执行优先级" class="headerlink" title="2. 执行优先级"></a>2. 执行优先级</h2><ul><li>4类 loader 的执行优级为：<code>pre &gt; normal &gt; inline &gt; post</code> 。</li><li>相同优先级的 loader 执行顺序为：<code>从右到左，从下到上</code>。</li></ul><h2 id="3-前缀的作用"><a href="#3-前缀的作用" class="headerlink" title="3. 前缀的作用"></a>3. 前缀的作用</h2><p>内联 loader 可以通过添加不同前缀，跳过其他类型 loader。</p><ul><li><code>!</code> 跳过 normal loader。</li><li><code>-!</code> 跳过 pre 和 normal loader。</li><li><code>!!</code> 跳过 pre、 normal 和 post loader。</li></ul><p>这些前缀在很多场景下非常有用。</p><h1 id="三、如何开发一个loader"><a href="#三、如何开发一个loader" class="headerlink" title="三、如何开发一个loader"></a>三、如何开发一个loader</h1><p>loader 是一个导出一个函数的 node 模块。</p><h2 id="1-最简单的-loader"><a href="#1-最简单的-loader" class="headerlink" title="1. 最简单的 loader"></a>1. 最简单的 loader</h2><p>当只有一个 loader 应用于资源文件时，它接收源码作为参数，输出转换后的 js 代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loaders/simple-loader.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">loader</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'simple-loader is working'</span>);</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是一个最简单的 loader 了，这个 loader 啥也没干，就是接收源码，然后原样返回，为了证明这个loader被调用了，我在里面打印了一句话‘simple-loader is working’。</p><p>测试这个 loader：<br><strong>需要先配置 loader 路径</strong><br>若是使用 npm 安装的第三方 loader，直接写 loader 的名字就可以了。但是现在用的是自己开发的本地 loader，需要我们手动配置路径，告诉 webpack 这些 loader 在哪里。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;...&#125;,</span><br><span class="line">  output: &#123;...&#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 直接指明 loader 的绝对路径</span></span><br><span class="line">        use: path.resolve(__dirname, <span class="string">'loaders/simple-loader'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如果觉得这样配置本地 loader 并不优雅，可以在 <a href="https://champyin.com/2020/01/04/webpack%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0loader%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/">webpack配置本地loader的四种方法</a> 中挑一个你喜欢的。</p></blockquote><p><strong>执行webpack编译</strong><br>可以看到，控制台输出 ‘simple-loader is working’。说明 loader 成功被调用。<br><img src="/images/webpack-loader1.jpg" alt="webpack-loader1.jpg"></p><h2 id="2-带-pitch-的-loader"><a href="#2-带-pitch-的-loader" class="headerlink" title="2. 带 pitch 的 loader"></a>2. 带 pitch 的 loader</h2><p><code>pitch</code> 是 loader 上的一个方法，它的作用是阻断 loader 链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loaders/simple-loader-with-pitch.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'normal excution'</span>);   </span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loader上的pitch方法，非必须</span></span><br><span class="line"><span class="built_in">module</span>.exports.pitch =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'pitching graph'</span>);</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pitch 方法不是必须的。如果有 pitch，loader 的执行则会分为两个阶段：<code>pitch</code> 阶段 和 <code>normal execution</code> 阶段。webpack 会先从左到右执行 loader 链中的每个 loader 上的 pitch 方法（如果有），然后再从右到左执行 loader 链中的每个 loader 上的普通 loader 方法。</p><p>假如配置了如下 loader 链：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use: [<span class="string">'loader1'</span>, <span class="string">'loader2'</span>, <span class="string">'loader3'</span>]</span><br></pre></td></tr></table></figure></p><p>真实的 loader 执行过程是：<br><img src="/images/webpack-loader-flow-with-pitch.png" alt="webpack-loader-flow-with-pitch.png"></p><p>在这个过程中如果任何 pitch 有返回值，则 loader 链被阻断。webpack 会跳过后面所有的的 pitch 和 loader，直接进入上一个 loader 的 <code>normal execution</code>。</p><p>假设在 loader2 的 pitch 中返回了一个字符串，此时 loader 链发生阻断：<br><img src="/images/webpack-loader-flow-with-pitch2.png" alt="webpack-loader-flow-with-pitch2.png"></p><h2 id="3-写一个简版的-style-loader"><a href="#3-写一个简版的-style-loader" class="headerlink" title="3. 写一个简版的 style-loader"></a>3. 写一个简版的 style-loader</h2><p>style-loader 通常不会独自使用，而是跟 css-loader 连用。css-loader 的返回值是一个 js 模块，大致长这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印 css-loader 的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Imports</span></span><br><span class="line"><span class="keyword">var</span> ___CSS_LOADER_API_IMPORT___ = <span class="built_in">require</span>(<span class="string">"../node_modules/css-loader/dist/runtime/api.js"</span>);</span><br><span class="line">exports = ___CSS_LOADER_API_IMPORT___(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// Module</span></span><br><span class="line">exports.push([<span class="built_in">module</span>.id, <span class="string">"\nbody &#123;\n    background: yellow;\n&#125;\n"</span>, <span class="string">""</span>]);</span><br><span class="line"><span class="comment">// Exports</span></span><br><span class="line"><span class="built_in">module</span>.exports = exports;</span><br></pre></td></tr></table></figure></p><p>这个模块在运行时上下文中执行后返回 <code>css</code> 代码 <code>&quot;\nbody {\n    background: yellow;\n}\n&quot;</code>。</p><p>style-loader 的作用就是将这段 <code>css</code> 代码转成 <code>style</code> 标签插入到 <code>html</code> 的 <code>head</code> 中。</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol><li>style-loader 最终需返回一个 <code>js</code> 脚本：在脚本中创建一个 <code>style</code> 标签，将 <code>css</code> 代码赋给 <code>style</code> 标签，再将这个 <code>style</code> 标签插入 <code>html</code> 的 <code>head</code> 中。</li><li>难点是获取 <code>css</code> 代码，因为 css-loader 的返回值只能在运行时的上下文中执行，而执行 loader 是在编译阶段。换句话说，css-loader 的返回值在 style-loader 里派不上用场。</li><li>曲线救国方案：使用获取 <code>css</code> 代码的表达式，在运行时再获取 css (类似 <code>require(&#39;css-loader!index.css&#39;)</code>）。</li><li>在处理 css 的 loader 中又去调用 <code>inline loader</code> require <code>css</code> 文件，会产生循环执行 loader 的问题，所以我们需要利用 <code>pitch</code> 方法，让 style-loader 在 <code>pitch</code> 阶段返回脚本，跳过剩下的 loader，同时还需要内联前缀 <code>!!</code> 的加持。</li></ol><blockquote><p>注：pitch 方法有3个参数：</p><ul><li>remainingRequest：loader链中排在自己后面的 loader 以及资源文件的绝对路径以<code>!</code>作为连接符组成的字符串。</li><li>precedingRequest：loader链中排在自己前面的 loader 的绝对路径以<code>!</code>作为连接符组成的字符串。</li><li>data：每个 loader 中存放在上下文中的固定字段，可用于 pitch 给 loader 传递数据。  </li></ul><p>可以利用 <code>remainingRequest</code> 参数获取 loader 链的剩余部分。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loaders/simple-style-loader.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.pitch = <span class="function"><span class="keyword">function</span>(<span class="params">remainingRequest</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'simple-style-loader is working'</span>);</span><br><span class="line">    <span class="comment">// 在 pitch 阶段返回脚本</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="string">`</span></span><br><span class="line"><span class="string">      // 创建 style 标签</span></span><br><span class="line"><span class="string">      let style = document.createElement('style');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      /**</span></span><br><span class="line"><span class="string">      * 利用 remainingRequest 参数获取 loader 链的剩余部分</span></span><br><span class="line"><span class="string">      * 利用 ‘!!’ 前缀跳过其他 loader </span></span><br><span class="line"><span class="string">      * 利用 loaderUtils 的 stringifyRequest 方法将模块的绝对路径转为相对路径</span></span><br><span class="line"><span class="string">      * 将获取 css 的 require 表达式赋给 style 标签</span></span><br><span class="line"><span class="string">      */</span></span><br><span class="line"><span class="string">      style.innerHTML = require(<span class="subst">$&#123;loaderUtils.stringifyRequest(<span class="keyword">this</span>, <span class="string">'!!'</span> + remainingRequest)&#125;</span>);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      // 将 style 标签插入 head</span></span><br><span class="line"><span class="string">      document.head.appendChild(style);</span></span><br><span class="line"><span class="string">      `</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简易的 style-loader 就完成了。</p><h3 id="试用"><a href="#试用" class="headerlink" title="试用"></a>试用</h3><p>webpack 配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;...&#125;,</span><br><span class="line">  output: &#123;...&#125;,</span><br><span class="line">  <span class="comment">// 手动配置 loader 路径</span></span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">'loaders'</span>), <span class="string">'node_modules'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 配置处理 css 的 loader</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'simple-style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 渲染首页</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 index.js 中引入一个 css 样式文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./index.css'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Brovo!'</span>);</span><br></pre></td></tr></table></figure><p>样式文件中将 body 的背景色设置为黄色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src/index.css */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行webpack</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>可以看到命令行控制台打印了 ‘simple-style-loader is working’，说明 webpack 成功调用了我们编写的 loader。</p><p><img src="/images/webpack-loader3.jpg" alt="webpack-loader3.jpg"></p><p>在浏览器打开 dist 下的 index.html 页面，可以看到样式生效，而且成功插入到了页面头部！</p><p><img src="/images/webpack-loader2.jpg" alt="webpack-loader2.jpg"></p><p>说明我们编写的 loader 发挥作用了。</p><p>成功！</p><h1 id="三、一些-tips"><a href="#三、一些-tips" class="headerlink" title="三、一些 tips"></a>三、一些 tips</h1><h2 id="推荐2个工具包"><a href="#推荐2个工具包" class="headerlink" title="推荐2个工具包"></a>推荐2个工具包</h2><p>开发 loader 必备：</p><p><strong>1. <a href="https://www.npmjs.com/package/loader-utils" target="_blank" rel="noopener">loader-utils</a></strong><br>这个模块中常用的几个方法：</p><ul><li>getOptions 获取 loader 的配置项。</li><li>interpolateName 处理生成文件的名字。</li><li>stringifyRequest 把绝对路径处理成相对根目录的相对路径。</li></ul><p><strong>2. <a href="https://www.npmjs.com/package/schema-utils" target="_blank" rel="noopener">schema-utils</a></strong><br>这个模块可以帮你验证 loader option 配置的合法性。<br>用法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loaders/simple-loader-with-validate.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"><span class="keyword">const</span> validate = <span class="built_in">require</span>(<span class="string">'schema-utils'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 loader 配置项</span></span><br><span class="line">  <span class="keyword">let</span> options = loaderUtils.getOptions(<span class="keyword">this</span>) || &#123;&#125;;</span><br><span class="line">  <span class="comment">// 定义配置项结构和类型</span></span><br><span class="line">  <span class="keyword">let</span> schema = &#123;</span><br><span class="line">    type: <span class="string">'object'</span>,</span><br><span class="line">    properties: &#123;</span><br><span class="line">      name: &#123;</span><br><span class="line">        type: <span class="string">'string'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 验证配置项是否符合要求</span></span><br><span class="line">  validate(schema, options);</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当配置项不符合要求，编译就会中断并在控制台打印错误信息：</p><p><img src="/images/webpack-loader4.jpg" alt="webpack-loader4.jpg"></p><h2 id="开发异步-loader"><a href="#开发异步-loader" class="headerlink" title="开发异步 loader"></a>开发异步 loader</h2><p>异步 loader 的开发（例如里面有一些需要读取文件的操作的时候），需要通过 this.async() 获取异步回调，然后手动调用它。<br>用法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loaders/simple-async-loader.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async loader'</span>);</span><br><span class="line">    <span class="keyword">let</span> cb = <span class="keyword">this</span>.async();</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">      <span class="comment">// 在异步回调中手动调用 cb 返回处理结果</span></span><br><span class="line">      cb(<span class="literal">null</span>, source);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注： 异步回调 cb() 的第一个参数是 <code>error</code>，要返回的结果放在第二个参数。</p></blockquote><h2 id="raw-loader"><a href="#raw-loader" class="headerlink" title="raw loader"></a>raw loader</h2><p>如果是处理图片、字体等资源的 loader，需要将 loader 上的 raw 属性设置为 true，让 loader 支持二进制格式资源（webpack默认是以 <code>utf-8</code> 的格式读取文件内容给 loader）。<br>用法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loaders/simple-raw-loader.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将输出 buffer 类型的二进制数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(source);</span><br><span class="line">  <span class="comment">// todo handle source</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">'results of processing source'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    module.exports = '<span class="subst">$&#123;result&#125;</span>'</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 告诉 wepack 这个 loader 需要接收的是二进制格式的数据</span></span><br><span class="line"><span class="built_in">module</span>.exports.raw = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p><img src="/images/webpack-loader5.jpg" alt="webpack-loader5.jpg"></p><blockquote><p>注：通常 raw 属性会在有文件输出需求的 loader 中使用。</p></blockquote><h2 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h2><p>在开发一些处理资源文件（比如图片、字体等）的 loader 中，需要拷贝或者生成新的文件，可以使用内部的 <code>this.emitFile()</code> 方法.<br>用法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loaders/simple-file-loader.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 loader 的配置项</span></span><br><span class="line">  <span class="keyword">let</span> options = loaderUtils.getOptions(<span class="keyword">this</span>) || &#123;&#125;;</span><br><span class="line">  <span class="comment">// 获取用户设置的文件名或者制作新的文件名</span></span><br><span class="line">  <span class="comment">// 注意第三个参数，是计算 contenthash 的依据</span></span><br><span class="line">  <span class="keyword">let</span> url = loaderUtils.interpolateName(<span class="keyword">this</span>, options.filename || <span class="string">'[contenthash].[ext]'</span>, &#123;<span class="attr">content</span>: source&#125;);</span><br><span class="line">  <span class="comment">// 输出文件</span></span><br><span class="line">  <span class="keyword">this</span>.emitFile(url, source);</span><br><span class="line">  <span class="comment">// 返回导出文件地址的模块脚本</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`module.exports = '<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(url)&#125;</span>'`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.raw = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p><img src="/images/webpack-loader6.jpg" alt="webpack-loader6.jpg"></p><blockquote><p>在这个例子中，loader 读取图片内容（buffer），将其重命名，然后调用 <code>this.emitFile()</code> 输出到指定目录，最后返回一个模块，这个模块导出重命名后的图片地址。于是当 <code>require</code> 图片的时候，就相当于 require 了一个模块，从而得到最终的图片路径。（这就是 file-loader 的基本原理）</p></blockquote><h2 id="开发约定"><a href="#开发约定" class="headerlink" title="开发约定"></a>开发约定</h2><p>为了让我们的 loader 具有更高的质量和复用性，记得保持简单。也就是尽量保持让一个 loader 专注一件事情，如果发现你写的 loader 比较庞大，可以试着将其拆成几个 loader 。</p><p>在 webpack 社区，有一份 loader 开发准则，我们可以去参考它来指导我们的 loader 设计：</p><ul><li>保持简单。</li><li>利用多个loader链。</li><li>模块化输出。</li><li>确保loader是无状态的。</li><li>使用 loader-utils 包。</li><li>标记加载程序依赖项。</li><li>解析模块依赖关系。</li><li>提取公共代码。</li><li>避免绝对路径。</li><li>使用 peerDependency 对等依赖项。</li></ul><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><ol><li><p>loader 的本质是一个 node 模块，这个模块导出一个函数，这个函数上可能还有一个 pitch 方法。</p></li><li><p>了解了 loader 的本质和 loader 链的执行机制，其实就已经具备了 loader 开发基础了。</p></li><li><p>开发 loader 不难上手，但是要开发一款高质量的 loader，仍需不断实践。</p></li><li><p>尝试自己开发维护一个小 loader 吧～ 没准以后可以通过自己编写 loader 来解决项目中的一些实际问题。</p></li></ol><p>文章源码获取：<a href="https://github.com/yc111/webpack-loader" target="_blank" rel="noopener">https://github.com/yc111/webpack-loader</a></p><p>欢迎交流～</p><p>Happy New Year！</p><p>–</p><p>参考<br><a href="https://webpack.js.org/concepts/#loaders" target="_blank" rel="noopener">https://webpack.js.org/concepts/#loaders</a><br><a href="https://webpack.js.org/api/loaders/" target="_blank" rel="noopener">https://webpack.js.org/api/loaders/</a><br><a href="https://webpack.js.org/contribute/writing-a-loader/" target="_blank" rel="noopener">https://webpack.js.org/contribute/writing-a-loader/</a><br><a href="https://github.com/webpack/webpack/blob/v4.41.5/lib/NormalModuleFactory.js" target="_blank" rel="noopener">https://github.com/webpack/webpack/blob/v4.41.5/lib/NormalModuleFactory.js</a><br><a href="https://github.com/webpack-contrib/style-loader/blob/master/src/index.js" target="_blank" rel="noopener">https://github.com/webpack-contrib/style-loader/blob/master/src/index.js</a><br><a href="https://www.npmjs.com/package/loader-utils" target="_blank" rel="noopener">https://www.npmjs.com/package/loader-utils</a><br><a href="https://www.npmjs.com/package/schema-utils" target="_blank" rel="noopener">https://www.npmjs.com/package/schema-utils</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> webpack </tag>
            
            <tag> loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《新型冠状病毒肺炎预防手册》电子书</title>
      <link href="/2020/01/27/%E3%80%8A%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92%E8%82%BA%E7%82%8E%E9%A2%84%E9%98%B2%E6%89%8B%E5%86%8C%E3%80%8B%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
      <url>/2020/01/27/%E3%80%8A%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92%E8%82%BA%E7%82%8E%E9%A2%84%E9%98%B2%E6%89%8B%E5%86%8C%E3%80%8B%E7%94%B5%E5%AD%90%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/new-coronavirus-cover.png" alt="new-coronavirus-cover.png"></p><blockquote><p>没想到这次爆发的肺炎疫情这么严重。 这个是从湘雅医学院老师那获取的 <strong>新型冠状病毒肺炎预防手册</strong> 普及扩散之。</p></blockquote><a id="more"></a><h4 id="电子书预览："><a href="#电子书预览：" class="headerlink" title="电子书预览："></a>电子书预览：</h4><body><br>    <embed src="/images/New-coronavirus-pneumonia prevention-manual.pdf" type="application/pdf" width="100%" height="800px" internalinstanceid="81/"><br></body><p><strong>若无法预览可以直接到github下载pdf：</strong><br><a href="https://github.com/yc111/ebooks/tree/master/medical-science" target="_blank" rel="noopener">https://github.com/yc111/ebooks/tree/master/medical-science</a></p><h4 id="另附小贴士："><a href="#另附小贴士：" class="headerlink" title="另附小贴士："></a>另附小贴士：</h4><p><strong>出门回家后，身上可能沾染病毒？应该如何消毒更安全更合理？</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.头发</span><br><span class="line">感染率低，防护策略：日常清洁。</span><br><span class="line"></span><br><span class="line">2.皮肤</span><br><span class="line">感染率低（新冠病毒不能透过皮肤侵入人体），但是手沾病毒概率极大，</span><br><span class="line">防护策略：正确洗手勤洗手，不摸脸，不揉眼。</span><br><span class="line"></span><br><span class="line">3.眼膜</span><br><span class="line">感染率高，防护策略：手部消毒前不揉眼，必要时带上护目镜。</span><br><span class="line"></span><br><span class="line">4.手机</span><br><span class="line">是高频接触物品，防护策略：关闭电源，等手机冷却，沾取75%酒精擦拭。</span><br><span class="line"></span><br><span class="line">5.口罩</span><br><span class="line">重要防护，防护策略：不建议重复使用，摘取口罩不要触碰外表面，此处已污染。</span><br><span class="line"></span><br><span class="line">6.衣服</span><br><span class="line">感染率低，防护措施：没去过特定场所不需要对衣服进行专门消毒，</span><br><span class="line">注意：喷洒酒精在衣物上，遇到明火、高温或静电可能起火。</span><br><span class="line"></span><br><span class="line">7.购物袋</span><br><span class="line">防护措施：必要时，用75%酒精喷洒表面。</span><br><span class="line"></span><br><span class="line">8.鞋底</span><br><span class="line">感染率低，防护措施： 保持清洁，门口换鞋。</span><br><span class="line"></span><br><span class="line">9.出租车</span><br><span class="line">防护措施：关闭车内空调，开窗通风，全程佩戴口罩，减少交流。</span><br><span class="line"></span><br><span class="line">10.其他</span><br><span class="line">流水洗菜，不吃生食，菜品烧熟、煮透，水果削皮。</span><br></pre></td></tr></table></figure></p><p><strong>为什么外面没有人也要戴口罩</strong><br><img src="/images/new-coronavirus3.png" alt="new-coronavirus3.png"></p><p><strong>耳戴式口罩佩戴方法</strong><br><img src="/images/new-coronavirus1.jpeg" alt="new-coronavirus1.jpeg"></p><p><strong>医院标准七步洗手法: <code>内、外、夹、弓、大、指、腕</code></strong><br><img src="/images/new-coronavirus2.jpeg" alt="new-coronavirus2.jpeg"></p><p><strong>友情链接：</strong><br><a href="https://3g.dxy.cn/newh5/view/pneumonia?scene=2&amp;clicktime=1579583352&amp;enterid=1579583352&amp;from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">实时疫情地图-丁香园</a><br><a href="https://voice.baidu.com/act/newpneumonia/newpneumonia" target="_blank" rel="noopener">最新疫情地图及动态</a><br><a href="https://baike.baidu.com/item/2019%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92/24267858?fromtitle=%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92&amp;fromid=7904360&amp;fr=aladdin" target="_blank" rel="noopener">2019新型冠状病毒-百度百科</a><br><a href="https://baike.baidu.com/medicine/disease/%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92%E6%84%9F%E6%9F%93%E7%9A%84%E8%82%BA%E7%82%8E/24282048?tab=%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">新型冠状病毒肺炎-百科医典</a></p>]]></content>
      
      
      <categories>
          
          <category> 电子书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭秘webpack plugin</title>
      <link href="/2020/01/12/%E6%8F%AD%E7%A7%98webpack-plugin/"/>
      <url>/2020/01/12/%E6%8F%AD%E7%A7%98webpack-plugin/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/webpack-plugin-cover.png" alt="webpack-plugin-cover.png"></p><blockquote><p>Plugin(插件) 是 webpack 生态的的一个关键部分。它为社区提供了一种强大的方法来扩展 webpack 和开发 webpack 的编译过程。本文将尝试探索 webpack plugin，揭秘它的工作原理，以及如何开发一个 plugin。</p></blockquote><a id="more"></a><h1 id="一、Plugin-的作用"><a href="#一、Plugin-的作用" class="headerlink" title="一、Plugin 的作用"></a>一、Plugin 的作用</h1><p>关于 Plugin 的作用，引用一下 webpack 官方的介绍：</p><blockquote><p>Plugins expose the full potential of the webpack engine to third-party developers. Using staged build callbacks, developers can introduce their own behaviors into the webpack build process. </p></blockquote><p>我把它通俗翻译了下：<br>我们可以通过插件，扩展 webpack，加入自定义的构建行为，使 webpack 可以执行更广泛的任务，拥有更强的构建能力。</p><h1 id="二、Plugin-工作原理"><a href="#二、Plugin-工作原理" class="headerlink" title="二、Plugin 工作原理"></a>二、Plugin 工作原理</h1><blockquote><p>webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 </p><p>插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。</p><p>webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。<br>——「深入浅出 Webpack」</p></blockquote><p>站在代码逻辑的角度就是：webpack 在编译过代码程中，会触发一系列 Tapable 钩子事件，插件所做的，就是找到相应的钩子，往上面挂上自己的任务，也就是注册事件，这样，当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行了。</p><h1 id="三、webpack-的一些底层逻辑"><a href="#三、webpack-的一些底层逻辑" class="headerlink" title="三、webpack 的一些底层逻辑"></a>三、webpack 的一些底层逻辑</h1><p>开发一个 plugin 比开发一个 loader 更高级一些（关于 loader 的开发，可以看我的另一篇文章<a href="https://champyin.com/2020/01/28/%E6%8F%AD%E7%A7%98webpack-loader/">「揭秘webpack loader」</a>），因为我们会用到一些 webpack 比较底层的内部组件。因此我们需要了解一些 webpack 的底层逻辑。</p><h2 id="webpack-内部执行流程"><a href="#webpack-内部执行流程" class="headerlink" title="webpack 内部执行流程"></a>webpack 内部执行流程</h2><p>一次完整的 webpack 打包大致是这样的过程：</p><ul><li>将命令行参数与 <code>webpack 配置文件</code> 合并、解析得到参数对象。</li><li>参数对象传给 webpack 执行得到 <code>Compiler</code> 对象。</li><li>执行 <code>Compiler</code> 的 <code>run</code>方法开始编译。每次执行 <code>run</code> 编译都会生成一个 <code>Compilation</code> 对象。</li><li>触发 <code>Compiler</code> 的 <code>make</code>方法分析入口文件，调用 <code>compilation</code> 的 <code>buildModule</code> 方法创建主模块对象。</li><li>生成入口文件 <code>AST(抽象语法树)</code>，通过 <code>AST</code> 分析和递归加载依赖模块。</li><li>所有模块分析完成后，执行 <code>compilation</code> 的 <code>seal</code> 方法对每个 <code>chunk</code> 进行整理、优化、封装。</li><li>最后执行 <code>Compiler</code> 的 <code>emitAssets</code> 方法把生成的文件输出到 <code>output</code> 的目录中。</li></ul><p>webpack 底层基本流程图</p><p><img src="/images/webpack-basic-flow.png" alt="webpack-basic-flow.png"></p><h2 id="webpack-内部的一些钩子"><a href="#webpack-内部的一些钩子" class="headerlink" title="webpack 内部的一些钩子"></a>webpack 内部的一些钩子</h2><h3 id="什么是钩子"><a href="#什么是钩子" class="headerlink" title="什么是钩子"></a>什么是钩子</h3><p>钩子的本质就是：事件。为了方便我们直接介入和控制编译过程，webpack 把编译过程中触发的各类关键事件封装成事件接口暴露了出来，这些接口被很形象地称做：<code>hooks</code>（钩子）。开发插件，离不开这些钩子。</p><h3 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h3><p>Tapable 为 webpack 提供了统一的插件接口（钩子）类型定义，它是 webpack 的核心功能库。webpack 中目前有十种 <code>hooks</code>，在 Tapable 源码中可以看到，他们是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/webpack/tapable/blob/master/lib/index.js</span></span><br><span class="line"></span><br><span class="line">exports.SyncHook = <span class="built_in">require</span>(<span class="string">"./SyncHook"</span>);</span><br><span class="line">exports.SyncBailHook = <span class="built_in">require</span>(<span class="string">"./SyncBailHook"</span>);</span><br><span class="line">exports.SyncWaterfallHook = <span class="built_in">require</span>(<span class="string">"./SyncWaterfallHook"</span>);</span><br><span class="line">exports.SyncLoopHook = <span class="built_in">require</span>(<span class="string">"./SyncLoopHook"</span>);</span><br><span class="line">exports.AsyncParallelHook = <span class="built_in">require</span>(<span class="string">"./AsyncParallelHook"</span>);</span><br><span class="line">exports.AsyncParallelBailHook = <span class="built_in">require</span>(<span class="string">"./AsyncParallelBailHook"</span>);</span><br><span class="line">exports.AsyncSeriesHook = <span class="built_in">require</span>(<span class="string">"./AsyncSeriesHook"</span>);</span><br><span class="line">exports.AsyncSeriesBailHook = <span class="built_in">require</span>(<span class="string">"./AsyncSeriesBailHook"</span>);</span><br><span class="line">exports.AsyncSeriesLoopHook = <span class="built_in">require</span>(<span class="string">"./AsyncSeriesLoopHook"</span>);</span><br><span class="line">exports.AsyncSeriesWaterfallHook = <span class="built_in">require</span>(<span class="string">"./AsyncSeriesWaterfallHook"</span>);</span><br></pre></td></tr></table></figure><p>Tapable 还统一暴露了三个方法给插件，用于注入不同类型的自定义构建行为：</p><ul><li><code>tap</code>：可以注册同步钩子和异步钩子。</li><li><code>tapAsync</code>：回调方式注册异步钩子。</li><li><code>tapPromise</code>：Promise方式注册异步钩子。</li></ul><p>webpack 里的几个非常重要的对象，<code>Compiler</code>, <code>Compilation</code> 和 <code>JavascriptParser</code> 都继承了 Tapable 类，它们身上挂着丰富的钩子。</p><h3 id="Compiler-Hooks"><a href="#Compiler-Hooks" class="headerlink" title="Compiler Hooks"></a>Compiler Hooks</h3><p>Compiler 编译器模块是创建编译实例的主引擎。大多数面向用户的插件都首先在 Compiler 上注册。</p><p>compiler上暴露的一些常用的钩子：</p><table><thead><tr><th>钩子</th><th>类型</th><th>什么时候调用</th></tr></thead><tbody><tr><td>run</td><td>AsyncSeriesHook</td><td>在编译器开始读取记录前执行</td></tr><tr><td>compile</td><td>SyncHook</td><td>在一个新的compilation创建之前执行</td></tr><tr><td>compilation</td><td>SyncHook</td><td>在一次compilation创建后执行插件</td></tr><tr><td>make</td><td>AsyncParallelHook</td><td>完成一次编译之前执行</td></tr><tr><td>emit</td><td>AsyncSeriesHook</td><td>在生成文件到output目录之前执行，回调参数：    <code>compilation</code></td></tr><tr><td>afterEmit</td><td>AsyncSeriesHook</td><td>在生成文件到output目录之后执行</td></tr><tr><td>assetEmitted</td><td>AsyncSeriesHook</td><td>生成文件的时候执行，提供访问产出文件信息的入口，回调参数：<code>file</code>，<code>info</code></td></tr><tr><td>done</td><td>AsyncSeriesHook</td><td>一次编译完成后执行，回调参数：<code>stats</code></td></tr></tbody></table><h3 id="Compilation-Hooks"><a href="#Compilation-Hooks" class="headerlink" title="Compilation Hooks"></a>Compilation Hooks</h3><p>Compilation 是 Compiler 用来创建一次新的编译过程的模块。一个 Compilation 实例可以访问所有模块和它们的依赖。在一次编译阶段，模块被加载、封装、优化、分块、散列和还原。<br>Compilation 也继承了 Tapable 并提供了很多生命周期钩子。</p><p>Compilation 上暴露的一些常用的钩子：</p><table><thead><tr><th>钩子</th><th>类型</th><th>什么时候调用</th></tr></thead><tbody><tr><td>buildModule</td><td>SyncHook</td><td>在模块开始编译之前触发，可以用于修改模块</td></tr><tr><td>succeedModule</td><td>SyncHook</td><td>当一个模块被成功编译，会执行这个钩子</td></tr><tr><td>finishModules</td><td>AsyncSeriesHook</td><td>当所有模块都编译成功后被调用</td></tr><tr><td>seal</td><td>SyncHook</td><td>当一次compilation停止接收新模块时触发</td></tr><tr><td>optimizeDependencies</td><td>SyncBailHook</td><td>在依赖优化的开始执行</td></tr><tr><td>optimize</td><td>SyncHook</td><td>在优化阶段的开始执行</td></tr><tr><td>optimizeModules</td><td>SyncBailHook</td><td>在模块优化阶段开始时执行，插件可以在这个钩子里执行对模块的优化，回调参数：<code>modules</code></td></tr><tr><td>optimizeChunks</td><td>SyncBailHook</td><td>在代码块优化阶段开始时执行，插件可以在这个钩子里执行对代码块的优化，回调参数：<code>chunks</code></td></tr><tr><td>optimizeChunkAssets</td><td>AsyncSeriesHook</td><td>优化任何代码块资源，这些资源存放在 <code>compilation.assets</code> 上。一个 <code>chunk</code> 有一个 <code>files</code> 属性，它指向由一个chunk创建的所有文件。任何额外的 <code>chunk</code> 资源都存放在 <code>compilation.additionalChunkAssets</code> 上。回调参数：<code>chunks</code></td></tr><tr><td>optimizeAssets</td><td>AsyncSeriesHook</td><td>优化所有存放在 <code>compilation.assets</code> 的所有资源。回调参数：<code>assets</code></td></tr></tbody></table><h3 id="JavascriptParser-Hooks"><a href="#JavascriptParser-Hooks" class="headerlink" title="JavascriptParser Hooks"></a>JavascriptParser Hooks</h3><p>Parser 解析器实例在 Compiler 编译器中产生，用于解析 webpack 正在处理的每个模块。我们可以用它提供的 Tapable 钩子自定义解析过程。</p><p>JavascriptParser 上暴露的一些常用的钩子：</p><table><thead><tr><th>钩子</th><th>类型</th><th>什么时候调用</th></tr></thead><tbody><tr><td>evaluate</td><td>SyncBailHook</td><td>在计算表达式的时候调用。</td></tr><tr><td>statement</td><td>SyncBailHook</td><td>为代码片段中每个已解析的语句调用的通用钩子</td></tr><tr><td>import</td><td>SyncBailHook</td><td>为代码片段中每个import语句调用，回调参数：<code>statement</code>,<code>source</code></td></tr><tr><td>export</td><td>SyncBailHook</td><td>为代码片段中每个export语句调用，回调参数：<code>statement</code></td></tr><tr><td>call</td><td>SyncBailHook</td><td>解析一个call方法的时候调用，回调参数：<code>expression</code></td></tr><tr><td>program</td><td>SyncBailHook</td><td>解析一个表达式的时候调用，回调参数：<code>expression</code></td></tr></tbody></table><p>对webpack底层逻辑和tapable钩子有了这些了解后，我们就可以进一步尝试开发一个插件了。</p><h1 id="四、如何开发一个webpack-plugin"><a href="#四、如何开发一个webpack-plugin" class="headerlink" title="四、如何开发一个webpack plugin"></a>四、如何开发一个webpack plugin</h1><h2 id="plugin-的基本结构"><a href="#plugin-的基本结构" class="headerlink" title="plugin 的基本结构"></a>plugin 的基本结构</h2><p>一个 webpack plugin 由如下部分组成：</p><ol><li>一个命名的 Javascript 方法或者 JavaScript 类。</li><li>它的原型上需要定义一个叫做 <code>apply</code> 的方法。</li><li>注册一个事件钩子。</li><li>操作webpack内部实例特定数据。</li><li>功能完成后，调用webpack提供的回调。</li></ol><p>一个基本的 plugin 代码结构大致长这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/MyPlugin.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.done.tap(<span class="string">'My Plugin'</span>, (stats) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Bravo!'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPlugin;</span><br></pre></td></tr></table></figure><p>这就是一个最简单的 webpack 插件了，它注册了 <code>Compiler</code> 上的异步串行钩子 <code>done</code>，在钩子中注入了一条控制台打印的语句。根据上文钩子的介绍我们可以知道，<code>done</code> 会在一次编译完成后执行。所以这个插件会在每次打包结束，向控制台首先输出这句 <code>Bravo!</code>。</p><p><img src="/images/webpack-plugin1.jpg" alt="webpack-plugin1.jpg"></p><h2 id="开发一个文件清单插件"><a href="#开发一个文件清单插件" class="headerlink" title="开发一个文件清单插件"></a>开发一个文件清单插件</h2><p>我希望每次webpack打包后，自动产生一个打包文件清单，上面要记录文件名、文件数量等信息。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul><li>显然这个操作需要在文件生成到dist目录之前进行，所以我们要注册的是<code>Compiler</code>上的<code>emit</code>钩子。</li><li><code>emit</code> 是一个异步串行钩子，我们用 <code>tapAsync</code> 来注册。</li><li>在 <code>emit</code> 的回调函数里我们可以拿到 <code>compilation</code> 对象，所有待生成的文件都在它的 <code>assets</code> 属性上。</li><li>通过 <code>compilation.assets</code> 获取我们需要的文件信息，并将其整理为新的文件内容准备输出。</li><li>然后往 <code>compilation.assets</code> 添加这个新的文件。</li></ul><p>插件完成后，最后将写好的插件放到 webpack 配置中，这个包含文件清单的文件就会在每次打包的时候自动生成了。</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/FileListPlugin.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileListPlugin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">    <span class="comment">// 获取插件配置项</span></span><br><span class="line">        <span class="keyword">this</span>.filename = options &amp;&amp; options.filename ? options.filename : <span class="string">'FILELIST.md'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        <span class="comment">// 注册 compiler 上的 emit 钩子</span></span><br><span class="line">        compiler.hooks.emit.tapAsync(<span class="string">'FileListPlugin'</span>, (compilation, cb) =&gt; &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通过 compilation.assets 获取文件数量</span></span><br><span class="line">            <span class="keyword">let</span> len = <span class="built_in">Object</span>.keys(compilation.assets).length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加统计信息</span></span><br><span class="line">            <span class="keyword">let</span> content = <span class="string">`# <span class="subst">$&#123;len&#125;</span> file<span class="subst">$&#123;len&gt;<span class="number">1</span>?<span class="string">'s'</span>:<span class="string">''</span>&#125;</span> emitted by webpack\n\n`</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过 compilation.assets 获取文件名列表</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> filename <span class="keyword">in</span> compilation.assets) &#123;</span><br><span class="line">                content += <span class="string">`- <span class="subst">$&#123;filename&#125;</span>\n`</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 往 compilation.assets 中添加清单文件</span></span><br><span class="line">            compilation.assets[<span class="keyword">this</span>.filename] = &#123;</span><br><span class="line">            <span class="comment">// 写入新文件的内容</span></span><br><span class="line">                source: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> content;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 新文件大小（给 webapck 输出展示用）</span></span><br><span class="line">                size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> content.length;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行回调，让 webpack 继续执行</span></span><br><span class="line">            cb();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = FileListPlugin;</span><br></pre></td></tr></table></figure><h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><p>在 webpack.config.js 中配置我们自己写的plugin：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> MyPlugin(),</span><br><span class="line">    <span class="keyword">new</span> FileListPlugin(&#123;</span><br><span class="line">        filename: <span class="string">'_filelist.md'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><code>npm run build</code> 执行，可以看到生成了 <code>_filelist.md</code> 文件：</p><p><img src="/images/webpack-plugin2.jpg" alt="webpack-plugin2.jpg"></p><p>打开 <code>dist</code> 目录，可以看到<code>_filelist.md</code> 文件中列出了 webpack 打包后的文件：</p><p><img src="/images/webpack-plugin3.jpg" alt="webpack-plugin3.jpg"></p><p>成功！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文总结了 webpack plugin 的工作原理、wepack底层执行的基本流程以及介绍了 tapable 和常用的 hooks，最后通过两个小例子演示了如何自己开发一个webpack插件。</p><p>开发插件并非难如登天的事情，当遇到通过配置无法解决的问题，又一时找不到好的插件时，不如试试自己编写一个插件来解决，相信我，你会越来越强的！</p><p>本文的源码均可在这里获取：<a href="https://github.com/yc111/webpack-plugin" target="_blank" rel="noopener">https://github.com/yc111/webpack-plugin</a></p><p>欢迎交流～</p><p>Happy New Year！</p><p>–</p><p>参考<br><a href="https://webpack.js.org/api/compiler-hooks/" target="_blank" rel="noopener">https://webpack.js.org/api/compiler-hooks/</a><br><a href="https://webpack.js.org/api/compilation-hooks/" target="_blank" rel="noopener">https://webpack.js.org/api/compilation-hooks/</a><br><a href="https://webpack.js.org/api/parser/" target="_blank" rel="noopener">https://webpack.js.org/api/parser/</a><br><a href="https://github.com/yc111/webpack/tree/master/lib" target="_blank" rel="noopener">https://github.com/yc111/webpack/tree/master/lib</a><br><a href="https://webpack.js.org/contribute/writing-a-plugin/" target="_blank" rel="noopener">https://webpack.js.org/contribute/writing-a-plugin/</a><br><a href="https://github.com/webpack/tapable#tapable" target="_blank" rel="noopener">https://github.com/webpack/tapable#tapable</a><br><a href="https://webpack.js.org/concepts/#plugins" target="_blank" rel="noopener">https://webpack.js.org/concepts/#plugins</a><br><a href="https://webpack.js.org/api/plugins/" target="_blank" rel="noopener">https://webpack.js.org/api/plugins/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> webpack </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack配置本地loader的四种方法</title>
      <link href="/2020/01/04/webpack%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0loader%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2020/01/04/webpack%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0loader%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通常我们配置 loader 只需直接使用 loader 的名字，不用关心 loader 的路径。那是因为通过 npm 或者 yarn 安装的 loader 都会安装在 node_modules 目录下，而 webpack 默认所有第三方模块都会去 node_modules 里找。</p><p>当我们要使用本地 loader (例如测试自己开发的loader)，而这些模块不在 node_modules 里的时候，就需要告诉 webpack 存放 loader 的位置。</p></blockquote><a id="more"></a><p>在 webpack4.0 里，一共有四种方法配置本地loader：</p><h2 id="1-在配置-rules-的时候直接指定-loader-的绝对路径"><a href="#1-在配置-rules-的时候直接指定-loader-的绝对路径" class="headerlink" title="1. 在配置 rules 的时候直接指定 loader 的绝对路径"></a>1. 在配置 <code>rules</code> 的时候直接指定 loader 的绝对路径</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 在这里配置绝对路径</span></span><br><span class="line">       use: path.resolve(__dirname, <span class="string">'loaders/myLoader.js'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-或者在-resolveLoader-里配置-alias-别名"><a href="#2-或者在-resolveLoader-里配置-alias-别名" class="headerlink" title="2. 或者在 resolveLoader 里配置 alias 别名"></a>2. 或者在 resolveLoader 里配置 alias 别名</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">  <span class="comment">// 配置 resolveLoader.alias</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      myLoader: path.resolve(__dirname, <span class="string">'loaders/myLoader.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'myLoader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-还可以在-resolveLoader-里配置-modules-属性"><a href="#3-还可以在-resolveLoader-里配置-modules-属性" class="headerlink" title="3. 还可以在 resolveLoader 里配置 modules 属性"></a>3. 还可以在 resolveLoader 里配置 modules 属性</h2><p>将放置 loader 的目录告诉 webpack。当 webpack 在默认目录下找不到指定 loader 时，会自动去这个目录查找。<code>resolveLoader.modules</code> 是个数组，可以配置多个路径。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">  <span class="comment">// 配置 resolveLoader.modules</span></span><br><span class="line">    modules: [<span class="string">'node_modules'</span>, path.resolve(__dirname, <span class="string">'loaders'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'myLoader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-还可以使用-npm-link"><a href="#4-还可以使用-npm-link" class="headerlink" title="4. 还可以使用 npm link"></a>4. 还可以使用 <code>npm link</code></h2><ul><li>把 loader 从当前项目抽离出来，构建独立工程。</li><li>在 loader 工程目录下执行 <code>npm link</code>;</li><li>回到原项目目录，执行 <code>npm link xxx</code> (xxx为loader的名称)。</li><li>最后，在原项目使用时，直接使用名称即可 (跟 npm install 的 loader 一样使用)。</li></ul><blockquote><p>如果对 <code>npm link</code> 原理感兴趣，可以看一看这篇文章 <a href="https://champyin.com/2019/08/27/npm-link%E8%AF%A6%E8%A7%A3/">npm link详解</a>。</p></blockquote><p>–<br>GOOD LUCK！</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装axios</title>
      <link href="/2019/12/23/%E5%B0%81%E8%A3%85axios/"/>
      <url>/2019/12/23/%E5%B0%81%E8%A3%85axios/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/wrap-axios-cover.png" alt="wrap-axios-cover.png"></p><blockquote><p><code>axios</code> 是一个轻量的 <code>HTTP客户端</code>，它基于 <code>XMLHttpRequest</code> 服务来执行 HTTP 请求，支持丰富的配置，支持 <code>Promise</code>，支持浏览器端和 <code>Node.js</code> 端。自Vue2.0起，尤大大（Vue作者尤雨溪）宣布取消对 <code>vue-resource</code> 的官方推荐，转而推荐 <code>axios</code>。现在 <code>axios</code> 已经成为大部分 Vue 开发者的首选。（ 如果你还不熟悉 <code>axios</code>，可以在<a href="http://www.axios-js.com/zh-cn/docs" target="_blank" rel="noopener">这里</a>查看它的API。）</p><p><code>axios</code> 的API很友好，你完全可以很轻松地在项目中直接使用。不过随着项目规模增大，如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都就地写一遍，得疯！这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。</p><p>为了提高我们的代码质量，我们应该在项目中二次封装一下 <code>axios</code> 再使用。</p></blockquote><a id="more"></a><p>那么，怎么封装 <code>axios</code> 呢？</p><h1 id="原来的样子"><a href="#原来的样子" class="headerlink" title="原来的样子"></a>原来的样子</h1><p>封装前，先来看下，不封装的情况下，一个实际项目中axios请求的样子。大概是长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">axios(&apos;http://localhost:3000/data&apos;, &#123;</span><br><span class="line">  method: &apos;GET&apos;,</span><br><span class="line">  timeout: 1000,</span><br><span class="line">  withCredentials: true,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;application/json&apos;,</span><br><span class="line">    Authorization: &apos;xxx&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  transformRequest: [function (data, headers) &#123;</span><br><span class="line">    return data;</span><br><span class="line">  &#125;],</span><br><span class="line">  // 其他请求配置...</span><br><span class="line">&#125;)</span><br><span class="line">.then((data) =&gt; &#123;</span><br><span class="line">  // todo: 真正业务逻辑代码</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line">  if (err.response.status === 401) &#123;</span><br><span class="line">  // handle authorization error</span><br><span class="line">  &#125;</span><br><span class="line">  if (err.response.status === 403) &#123;</span><br><span class="line">  // handle server forbidden error</span><br><span class="line">  &#125;</span><br><span class="line">  // 其他错误处理.....</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到在这段代码中，页面代码逻辑只在第15行处，上方的一大块请求配置代码和下方一大块响应错误处理代码，几乎跟页面功能没有关系，而且每个请求中这些内容都差不多，甚至有的部分完全一样。想象一下，每发一次请求都来这么一下，十几个请求一写，会是什么盛况？</p><h1 id="封装步骤"><a href="#封装步骤" class="headerlink" title="封装步骤"></a>封装步骤</h1><p>封装的本质就是在待封装的内容外面添加各种东西，然后把它们作为一个新的整体呈现给使用者，以达到扩展和易用的目的。</p><p>封装<code>axios</code>要做的事情，就是把所有HTTP请求共用的配置，事先都在axios上配置好，预留好必要的参数和接口，然后把它作为新的axios返回。</p><p>接下来我们借助一个demo实现一个具有良好扩展性的<code>axios</code>封装。</p><p>demo目录结构如下(由Vue-cli 3.0 生成)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|--public/</span><br><span class="line">|--mock/</span><br><span class="line">|   |--db.json  # 我新建的接口模拟数据</span><br><span class="line">|--src/</span><br><span class="line">|   |--assets/</span><br><span class="line">|   |--components/</span><br><span class="line">|   |--router/</span><br><span class="line">|   |--store/</span><br><span class="line">|   |--views/</span><br><span class="line">|       |--Home.Vue</span><br><span class="line">|   |--App.vue</span><br><span class="line">|   |--main.js</span><br><span class="line">|   |--theme.styl</span><br><span class="line">|--package.json</span><br><span class="line">|...</span><br></pre></td></tr></table></figure></p><h2 id="封装目标"><a href="#封装目标" class="headerlink" title="封装目标"></a>封装目标</h2><p>我希望在 Home 页，发起 axios 请求时就像调用一个只有少量参数的方法一样简单，这样我就可以专注业务代码了。</p><h2 id="1-将-axios-封装到一个独立的文件"><a href="#1-将-axios-封装到一个独立的文件" class="headerlink" title="1. 将 axios 封装到一个独立的文件"></a>1. 将 axios 封装到一个独立的文件</h2><ul><li><p>在src下创建 utils/http.js 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">mkdir utils</span><br><span class="line">touch http.js</span><br></pre></td></tr></table></figure></li><li><p>引入 axios</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/http.js</span><br><span class="line"></span><br><span class="line">import axios from &apos;axios&apos;;</span><br></pre></td></tr></table></figure></li><li><p>创建一个类<br>你也可以用函数来封装，我只是觉得类更语义化而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//src/utils/http.js</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">class NewAxios &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给不同环境配置不同请求地址<br>根据 <code>process.env.NODE_ENV</code> 配置不同的 <code>baseURL</code>，使项目只需执行相应打包命令，就可以在不同环境中自动切换请求主机地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/http.js</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">const getBaseUrl = (env) =&gt; &#123;</span><br><span class="line">  let base = &#123;</span><br><span class="line">    production: &apos;/&apos;,</span><br><span class="line">    development: &apos;http://localhost:3000&apos;,</span><br><span class="line">    test: &apos;http://localhost:3001&apos;,</span><br><span class="line">  &#125;[env];</span><br><span class="line">  if (!base) &#123;</span><br><span class="line">    base = &apos;/&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class NewAxios &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.baseURL = getBaseUrl(process.env.NODE_ENV);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置超时时间<br>timeout属性，我一般设置10秒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/http.js</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">class NewAxios &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    //...</span><br><span class="line">    this.timeout = 10000;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置允许携带凭证<br>widthCredentials属性设为true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/http.js</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">class NewAxios &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    //...</span><br><span class="line">    this.withCredentials = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给这个类创建实例上的方法request<br>在 <code>request</code> 方法里，创建新的axios实例，接收请求配置参数，处理参数，添加配置，返回axios实例的请求结果（一个promise对象）。<br>你也可以不创建，直接使用默认导出的axios实例，然后把所有配置都放到它上面，不过这样一来整个项目就会共用一个axios实例。虽然大部分项目下这样够用没问题，但是有的项目中不同服务地址的请求和响应结构可能完全不同，这个时候共用一个实例就没办法支持了。所以为了封装可以更通用，更具灵活性，我会使用axios的create方法，使每次发请求都是新的axios实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/http.js</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">class NewAxios &#123;</span><br><span class="line">  //...</span><br><span class="line">  request(options) &#123;</span><br><span class="line">    // 每次请求都会创建新的axios实例。</span><br><span class="line">    const instance = axios.create();</span><br><span class="line">    const config = &#123; // 将用户传过来的参数与公共配置合并。</span><br><span class="line">      ...options,</span><br><span class="line">      baseURL: this.baseURL,</span><br><span class="line">      timeout: this.timeout,</span><br><span class="line">      withCredentials: this.withCredentials,</span><br><span class="line">    &#125;;</span><br><span class="line">    // 配置拦截器，支持根据不同url配置不同的拦截器。</span><br><span class="line">    this.setInterceptors(instance, options.url);</span><br><span class="line">    return instance(config); // 返回axios实例的执行结果</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为拦截器配置内容比较多，所以封装成一个内部函数了。</p></blockquote></li><li><p>配置请求拦截器<br>在发送请求前对请求参数做的所有修改都在这里统一配置。比如统一添加token凭证、统一设置语言、统一设置内容类型、指定数据格式等等。做完后记得返回这个配置，否则整个请求不会进行。<br>我这里就配置一个token。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/http.js</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">class NewAxios &#123;</span><br><span class="line">  //...</span><br><span class="line">  // 这里的url可供你针对需要特殊处理的接口路径设置不同拦截器。</span><br><span class="line">  setInterceptors = (instance, url) =&gt; &#123; </span><br><span class="line">    instance.interceptors.request.use((config) =&gt; &#123; // 请求拦截器</span><br><span class="line">      // 配置token</span><br><span class="line">      config.headers.AuthorizationToken = localStorage.getItem(&apos;AuthorizationToken&apos;) || &apos;&apos;;</span><br><span class="line">      return config;</span><br><span class="line">    &#125;, err =&gt; Promise.reject(err));</span><br><span class="line">  &#125;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置响应拦截器<br>在请求的<code>then</code>或<code>catch</code>处理前对响应数据进行一轮预先处理。比如过滤响应数据，更多的，是在这里对各种响应错误码进行统一错误处理，还有断网处理等等。<br>我这里就判断一下403、请求超时和断网。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/http.js</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">class NewAxios &#123;</span><br><span class="line">  //...</span><br><span class="line">  setInterceptors = (instance, url) =&gt; &#123;</span><br><span class="line">    //...</span><br><span class="line">    instance.interceptors.response.use((response) =&gt; &#123; // 响应拦截器</span><br><span class="line">      // todo: 想根据业务需要，对响应结果预先处理的，都放在这里</span><br><span class="line">      console.log();</span><br><span class="line">      return response;</span><br><span class="line">    &#125;, (err) =&gt; &#123;</span><br><span class="line">      if (err.response) &#123; // 响应错误码处理</span><br><span class="line">        switch (err.response.status) &#123;</span><br><span class="line">          case &apos;403&apos;:</span><br><span class="line">            // todo: handler server forbidden error</span><br><span class="line">            break;</span><br><span class="line">            // todo: handler other status code</span><br><span class="line">          default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&apos;err.response: &apos;, err);</span><br><span class="line">        return Promise.reject(err.response);</span><br><span class="line">      &#125;</span><br><span class="line">      if (err.request) &#123; // 请求超时处理</span><br><span class="line">        if (err.request.readyState === 4 &amp;&amp; err.request.status === 0) &#123;</span><br><span class="line">          // 当一个请求在上面的timeout属性中设置的10秒内还没结束，则触发超时错误</span><br><span class="line">          // todo handler request timeout error</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&apos;err.request: &apos;, err);</span><br><span class="line">        return Promise.reject(err.request);</span><br><span class="line">      &#125;</span><br><span class="line">      if (!window.navigator.online) &#123; // 断网处理</span><br><span class="line">        // todo: jump to offline page</span><br><span class="line">        return -1;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&apos;err: &apos;, err);</span><br><span class="line">      return Promise.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>另外，在拦截器里，还适合放置loading等缓冲效果：在请求拦截器里显示loading，在响应拦截器里移除loading。这样所有请求就都有了一个统一的loading效果。</p><ul><li>默认导出新的实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/http.js</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">export default new NewAxios();</span><br></pre></td></tr></table></figure></li></ul><p>最后完整的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// src/utils/http.js</span><br><span class="line"></span><br><span class="line">import axios from &apos;axios&apos;;</span><br><span class="line"></span><br><span class="line">const getBaseUrl = (env) =&gt; &#123;</span><br><span class="line">  let base = &#123;</span><br><span class="line">    production: &apos;/&apos;,</span><br><span class="line">    development: &apos;http://localhost:3000&apos;,</span><br><span class="line">    test: &apos;http://localhost:3001&apos;,</span><br><span class="line">  &#125;[env];</span><br><span class="line">  if (!base) &#123;</span><br><span class="line">    base = &apos;/&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class NewAxios &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.baseURL = getBaseUrl(process.env.NODE_ENV);</span><br><span class="line">    this.timeout = 10000;</span><br><span class="line">    this.withCredentials = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setInterceptors = (instance, url) =&gt; &#123;</span><br><span class="line">    instance.interceptors.request.use((config) =&gt; &#123;</span><br><span class="line">      // 在这里添加loading</span><br><span class="line">      // 配置token</span><br><span class="line">      config.headers.AuthorizationToken = localStorage.getItem(&apos;AuthorizationToken&apos;) || &apos;&apos;;</span><br><span class="line">      return config;</span><br><span class="line">    &#125;, err =&gt; Promise.reject(err));</span><br><span class="line"></span><br><span class="line">    instance.interceptors.response.use((response) =&gt; &#123;</span><br><span class="line">      // 在这里移除loading</span><br><span class="line">      // todo: 想根据业务需要，对响应结果预先处理的，都放在这里</span><br><span class="line">      return response;</span><br><span class="line">    &#125;, (err) =&gt; &#123;</span><br><span class="line">      if (err.response) &#123; // 响应错误码处理</span><br><span class="line">        switch (err.response.status) &#123;</span><br><span class="line">          case &apos;403&apos;:</span><br><span class="line">            // todo: handler server forbidden error</span><br><span class="line">            break;</span><br><span class="line">            // todo: handler other status code</span><br><span class="line">          default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(err.response);</span><br><span class="line">      &#125;</span><br><span class="line">      if (!window.navigator.online) &#123; // 断网处理</span><br><span class="line">        // todo: jump to offline page</span><br><span class="line">        return -1;</span><br><span class="line">      &#125;</span><br><span class="line">      return Promise.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  request(options) &#123;</span><br><span class="line">    // 每次请求都会创建新的axios实例。</span><br><span class="line">    const instance = axios.create();</span><br><span class="line">    const config = &#123; // 将用户传过来的参数与公共配置合并。</span><br><span class="line">      ...options,</span><br><span class="line">      baseURL: this.baseURL,</span><br><span class="line">      timeout: this.timeout,</span><br><span class="line">      withCredentials: this.withCredentials,</span><br><span class="line">    &#125;;</span><br><span class="line">    // 配置拦截器，支持根据不同url配置不同的拦截器。</span><br><span class="line">    this.setInterceptors(instance, options.url);</span><br><span class="line">    return instance(config); // 返回axios实例的执行结果</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default new NewAxios();</span><br></pre></td></tr></table></figure></p><p>现在 <code>axios</code> 封装算是完成了80%。我们还需要再进一步把axios和接口结合再封装一层，才能达到我在一开始定的封装目标。</p><h2 id="2-使用新的-axios-封装API"><a href="#2-使用新的-axios-封装API" class="headerlink" title="2. 使用新的 axios 封装API"></a>2. 使用新的 axios 封装API</h2><ul><li>在 src 目录下新建 <code>api</code> 文件夹。把所有涉及HTTP请求的接口统一集中到这个目录来管理。</li><li>新建 <code>home.js</code>。我们需要把接口根据一定规则分好类，一类接口对应一个js文件。这个分类可以是按页面来划分，或者按模块等等。为了演示更直观，我这里就按页面来划分了。实际根据自己的需求来定。</li><li><p>使用新的 axios 封装API（固定url的值，合并用户传过来的参数），然后命名导出这些函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/api/home.js </span><br><span class="line"></span><br><span class="line">import axios from &apos;@/utils/http&apos;;</span><br><span class="line">export const fetchData = options =&gt; axios.request(&#123;</span><br><span class="line">  ...options,</span><br><span class="line">  url: &apos;/data&apos;,</span><br><span class="line">&#125;);</span><br><span class="line">export default &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在 api 目录下新建 <code>index.js</code>，把其他文件的接口都在这个文件里汇总导出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// src/api/index.js</span><br><span class="line"></span><br><span class="line">export * from &apos;./home&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>这层封装将我们的新的axios封装到了更简洁更语义化的接口方法中。 </p></blockquote></li></ul><p>现在我们的目录结构长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">|--public/</span><br><span class="line">|--mock/</span><br><span class="line">|   |--db.json  # 接口模拟数据</span><br><span class="line">|--src/</span><br><span class="line">|   |--api/     # 所有的接口都集中在这个目录下</span><br><span class="line">|       |--home.js  # Home页面里涉及到的接口封装在这里</span><br><span class="line">|       |--index.js # 项目中所有接口调用的入口</span><br><span class="line">|   |--assets/</span><br><span class="line">|   |--components/</span><br><span class="line">|   |--router/</span><br><span class="line">|   |--store/</span><br><span class="line">|   |--utils/</span><br><span class="line">|       |--http.js  # axios封装在这里</span><br><span class="line">|   |--views/</span><br><span class="line">|       |--Home.Vue</span><br><span class="line">|   |--App.vue</span><br><span class="line">|   |--main.js</span><br><span class="line">|   |--theme.styl</span><br><span class="line">|--package.json</span><br><span class="line">|...</span><br></pre></td></tr></table></figure></p><h1 id="使用封装后的axios"><a href="#使用封装后的axios" class="headerlink" title="使用封装后的axios"></a>使用封装后的axios</h1><p>现在我们要发HTTP请求时，只需引入 <code>api</code> 下的 <code>index.js</code> 文件就可以调用任何接口了，并且用的是封装后的 <code>axios</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// src/views/Home.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;h1&gt;This is home page&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// @ is an alias to /src</span><br><span class="line">import &#123; fetchData &#125; from &apos;@/api/index&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;home&apos;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    fetchData()  // axios请求在这里</span><br><span class="line">      .then((data) =&gt; &#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch((err) =&gt; &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>axios请求被封装在<code>fetchData</code>函数里，页面请求压根不需要出现任何<code>axios API</code>，悄无声息地发起请求获取响应，就像在调用一个简单的 <code>Promise</code> 函数一样轻松。并且在页面中只需专注处理业务功能，不用被其他事物干扰。</p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>运行 <code>npm run serve</code> 启动项目，执行 <code>npm run mock</code> 启动服务mock接口。</p><p>现在打开 <code>localhost:8080</code> 可以看到home页面。打开浏览器控制台，可以看到打印的请求响应结果：<br><img src="/images/wrap-axios.jpg" alt="wrap-axios.jpg"></p><p>简洁，优雅。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>封装思想是前端技术中很有用的思想，简单的axios及接口封装，就可以让我们可以领略到它的魅力。</li><li>封装 <code>axios</code> 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案。</li><li>BTW：以上封装给大家提供了一个封装好的axios和api框架，经过以上过程封装好的 <code>axios</code>，可以不局限于 Vue，React 项目同样可以拿去使用，它适用任何前端项目。</li></ol><p>本文的代码可以在这里获取：<a href="https://github.com/yc111/wrap-axios" target="_blank" rel="noopener">https://github.com/yc111/wrap-axios</a></p><p>欢迎交流～</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
            <tag> full stack </tag>
            
            <tag> vue </tag>
            
            <tag> http </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax vs Axios vs Fetch</title>
      <link href="/2019/12/20/Ajax-vs-Axios-vs-Fetch/"/>
      <url>/2019/12/20/Ajax-vs-Axios-vs-Fetch/</url>
      
        <content type="html"><![CDATA[<blockquote><p>发HTTP请求是JS前端应用最常见的任务之一。实现HTTP请求有非常多解决方案，目前主流的几个解决方案有 ajax、axios 和 fetch。哪个好？如何选？下面对这几个方案进行一个简单的对比分析。</p></blockquote><a id="more"></a><ul><li><p>ajax： jQuery库中的异步HTTP请求API。基本语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(url[, settings])</span><br></pre></td></tr></table></figure></li><li><p>axios： 轻量的HTTP客户端，支持浏览器端和 <code>Node.js</code> 端。基本语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios(url[, options]).then().catch()</span><br></pre></td></tr></table></figure></li><li><p>fetch： Web原生的HTTP请求API。基本语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(url[, options]).then().catch()</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>可以看到 axios 和 fetch 的基本用法非常一致，不过在面对稍复杂一些的需求时使用还是有差别的。</p></blockquote><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p> ajax 和 axios 属于第三方库，它们底层都是基于 <code>XMLHttpRequest</code>，而 fetch 是web原生的 <code>JS API</code>，是 <code>web标准</code> 的一部分。从性能上讲，原生API fetch 有天然的性能优势：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch &gt; axios = ajax</span><br></pre></td></tr></table></figure></p><h1 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h1><p>在处理异步的方式上，ajax 基于回调，axios 和 fetch 都是基于 Promise，因此代码会比 ajax 更简洁，更优雅。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios = fetch &gt; ajax</span><br></pre></td></tr></table></figure></p><blockquote><p>jQuery3.0之后，$.ajax()也支持了<code>$.ajax().done().fail().always()</code>的链式调用方式（内部基于<code>Defferred</code>对象实现）。</p></blockquote><h1 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h1><p>在功能上，axios 支持了很多实用的功能封装，比如请求和响应拦截器等等。fetch 则是纯粹的HTTP请求API，不支持额外的功能，你需要自己重写 fetch方法 来实现请求拦截。ajax 也不支持额外的功能。从易用和实用上讲，axios 无疑是占优势的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios &gt; fetch &gt; ajax</span><br></pre></td></tr></table></figure></p><h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><p>兼容性方面，jQuery 是比较早期的库，所以 ajax 对低版本的浏览器支持较好。axios 由于使用了 Promise (ECMAScript2015特性)，在一些低版本浏览器中支持的不好，比如IE8和更低的IE浏览器。fetch 只在比较新的现代浏览器中支持，并且所有IE都不支持。从浏览器兼容上讲：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax &gt; axios &gt; fetch</span><br></pre></td></tr></table></figure></p><p>不过现在旧版本浏览器以及IE浏览器已经在慢慢淘汰，浏览器兼容的顾虑会越来越少，兼容性越来越不重要。所以就放心大胆地使用新的技术吧。</p><h1 id="一些不成熟的建议和看法"><a href="#一些不成熟的建议和看法" class="headerlink" title="一些不成熟的建议和看法"></a>一些不成熟的建议和看法</h1><ul><li>ajax 依然有它的市场，现在依然有很多的依赖 jQuery 库的项目，在 $.ajax 就够用了的情况下，没必要非要引入 axios。</li><li>在尤大大的推荐下，Vue 项目一般都搭配 axios 使用，但是不要陷入 “Vue 只能使用 axios”，或者 “axios 只能在 Vue 中使用” 的误区。</li><li>以后的大趋势依然是原生web。使用原生的好处之一就是，不依赖外部，不必再加载额外模块，效率高。所以当原生web标准支持越来越多草案后，第三方的库也就没有存在的必要了，以后 fetch 的使用率会越来越高。</li></ul><blockquote><p>不过从历史规律看来，第三方永远比标准发展的快…</p></blockquote><p>最后我想说，没有最好，只有最合适。而只有了解这些技术的特点，才可以让技术选型不再随意或者跟风。</p><p>–<br>FIGHTING！</p><p>参考：<br><a href="https://api.jquery.com/jQuery.ajax/" target="_blank" rel="noopener">jQuery ajax API</a><br><a href="http://www.axios-js.com/zh-cn/docs/" target="_blank" rel="noopener">Axios 官网</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">Fetch API MDN</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> axios </tag>
            
            <tag> fetch </tag>
            
            <tag> full stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack中的publicPath</title>
      <link href="/2019/12/05/webpack%E4%B8%AD%E7%9A%84publicPath/"/>
      <url>/2019/12/05/webpack%E4%B8%AD%E7%9A%84publicPath/</url>
      
        <content type="html"><![CDATA[<blockquote><p>webpack的常用基本配置我们可能已经耳熟能详，比如  <code>input</code>,<code>output</code>,<code>module</code>,<code>plugins</code>,<code>devServer</code>的配置等等。而在这些基本配置中，其实还有一些细节参数，它可以帮助我们更好的定制化打包的目录结构，但它可能并不是那么好理解，比如publicPath。</p></blockquote><a id="more"></a><p>webpack官网这么解释：<br><code>publicPath</code>配置项在很多场景下都非常有用，它允许你给你的应用中的所有静态资源指定一个基本路径。</p><blockquote><p>The publicPath configuration option can be quite useful in a variety of scenarios. It allows you to specify the base path for all the assets within your application.</p></blockquote><p>有些抽象，我总结了下，它大概做的事情就是：<strong>可以帮我们处理资源引用的url路径问题：为生成的资源自动添加特定路径前缀。</strong></p><h1 id="什么时候需要使用publicPath"><a href="#什么时候需要使用publicPath" class="headerlink" title="什么时候需要使用publicPath?"></a>什么时候需要使用<code>publicPath</code>?</h1><h2 id="1-打包出来的文件有特定目录结构划分时"><a href="#1-打包出来的文件有特定目录结构划分时" class="headerlink" title="1. 打包出来的文件有特定目录结构划分时"></a>1. 打包出来的文件有特定目录结构划分时</h2><p>webpack打包出来的文件，默认都统一放在<code>output</code>配置的<code>path</code>路径下，项目稍大一点，这个目录中的文件就比较杂乱了，我们可能会希望给这些文件进行归类。当然我们可以粗暴一点通过<code>filename</code>来指定一个子目录。但是，如果在这这个子目录中，文件还有层级，就需要配置相应 plugin 或者 loader 的 <code>publicPath</code> 了。</p><p>例如<code>file-loader</code>，我们可以配置它的<code>outputPath</code> 自定义生成文件存放在<code>output.path</code>的哪个子目录，并且配置它的 <code>publicPath</code> 指定资源路径前缀：<br>在<code>file-loader</code>中<code>publicPath</code>的值可以是<code>string</code>和<code>function</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.(png|jpe?g|gif)$/i,</span><br><span class="line">      loader: &apos;file-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        outputPath: &apos;media&apos;, // string</span><br><span class="line">        publicPath: &apos;media&apos;, // string</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，编译打包后的图片资源就会放在<code>dist/media</code>目录下（假设你设置的output path为dist），并且所有引用到图片的资源路径都会自动加上前缀 <code>media/</code>。</p><p>如果想对不同的图片添加不同的路径前缀，可以使用函数来定义<code>publicPath</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.(png|jpe?g|gif)$/i,</span><br><span class="line">      loader: &apos;file-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        publicPath: (url, resourcePath, context) =&gt; &#123;</span><br><span class="line">          // `resourcePath` 是这个资源的本地绝对路径</span><br><span class="line">          // `context` 是存放这个资源的目录，或者是`context`配置项的值</span><br><span class="line">          // 想获取相对路径可以这样：</span><br><span class="line">          // const relativePath = path.relative(context, resourcePath);</span><br><span class="line"></span><br><span class="line">          // 将符合下面条件的png图片url添加前缀 `other_public_path`</span><br><span class="line">          if (/my-custom-image\.png/.test(resourcePath)) &#123;</span><br><span class="line">            return `other_public_path/$&#123;url&#125;`;</span><br><span class="line">          &#125;</span><br><span class="line">          // 将符合下面条件的图片url添加前缀 `image_output_path`</span><br><span class="line">          if (/images/.test(context)) &#123;</span><br><span class="line">            return `image_output_path/$&#123;url&#125;`;</span><br><span class="line">          &#125;</span><br><span class="line">          // 其他图片url添加前缀 `public_path`</span><br><span class="line">          return `public_path/$&#123;url&#125;`;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样编译打包出来的图片url，就会根据你的设置，分别加上 <code>other_public_path</code>、<code>image_output_path</code>和<code>public_path</code>前缀了（当然这几个目录的名称你自己来定），是不是很不错？</p><h2 id="2-生产模式要求index首页不在根目录下"><a href="#2-生产模式要求index首页不在根目录下" class="headerlink" title="2. 生产模式要求index首页不在根目录下"></a>2. 生产模式要求index首页不在根目录下</h2><p>例如在某些生产模式下，要求产出的文件目录类似这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--assets/</span><br><span class="line">|    |--index.js</span><br><span class="line">|    |--vendor.js</span><br><span class="line">|--page/</span><br><span class="line">     |--index.html</span><br></pre></td></tr></table></figure></p><p>那么可以这么配置webpack：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// webpack.prod.js file</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;assets/[name].js&apos;, </span><br><span class="line">    path: resolve(__dirname, &apos;../&apos;, &apos;dist&apos;),</span><br><span class="line">    publicPath: &apos;../&apos; // 相对HTML页面的路径</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [ </span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: &apos;../public/index.html&apos;,</span><br><span class="line">        filename: &apos;pages/index.html&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><p>编译后，在<code>index.html</code>中<code>index.js</code>的引用就会变成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=../assets/index.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>在<code>output</code>中<code>publicPath</code>的值可以是以下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 以下几种之一</span><br><span class="line">    publicPath: &apos;https://cdn.example.com/assets/&apos;, // CDN (一定是HTTPS)</span><br><span class="line">    publicPath: &apos;//cdn.example.com/assets/&apos;, // CDN (HTTPS协议)</span><br><span class="line">    publicPath: &apos;/assets/&apos;, // 相对服务端跟目录</span><br><span class="line">    publicPath: &apos;assets/&apos;, // 相对 HTML 页面文件</span><br><span class="line">    publicPath: &apos;../assets/&apos;, // 相对 HTML 页面文件</span><br><span class="line">    publicPath: &apos;&apos;, // 相对 HTML 页面文件 (与HTML同一目录)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="3-生产模式下的静态资源在CDN上托管时"><a href="#3-生产模式下的静态资源在CDN上托管时" class="headerlink" title="3. 生产模式下的静态资源在CDN上托管时"></a>3. 生产模式下的静态资源在CDN上托管时</h2><p>例如在某些生产模式下，静态文件都由<code>www.xx.com/assets</code>来托管<br>那么可以在 webpack 中这么配置 publicPath：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// webpack.prod.js file</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;assets/[name].js&apos;, </span><br><span class="line">    path: resolve(__dirname, &apos;../&apos;, &apos;dist&apos;),</span><br><span class="line">    publicPath: &apos;https://www.xx.com/assets&apos; // CDN URL</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>编译后，在 index.html 中 index.js 的引用就会变成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=https://www.xx.com/assets/index.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在<code>devServer</code>中也有<code>publicPath</code>配置，默认它是获取<code>output</code>的<code>publicPath</code>的值。<br>要提一下，webpack-dev-server生成的文件是不会放在硬盘的，而是在内存中，所以看不到。只有在请求资源的时候，可以证明文件的存在。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer &#123;</span><br><span class="line">  publicPath: &apos;/assets/&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>一定要在string的前后都放上<code>/</code>。</p></blockquote><p>需要注意的是，<code>devServer</code>中还有一个叫做<code>contentBase</code>的参数，这个参数如果配置的不好，跟<code>publicPath</code>一搭配，很可能会导致请求不到页面（我也是被这个坑了很久）。这个地方如果出问题，基本上原因在于<code>contentBase</code>设置的路径范围太小了，去掉<code>contentBase</code>配置，或者给它配置多个路径，把输出目录包含进来，就可以解决问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer &#123;</span><br><span class="line">  contentBase: [path.resolve(__dirname, &apos;../assets&apos;), path.resolve(__dirname, &apos;../dist&apos;)], // contentBase可以放多个路径</span><br><span class="line">  publicPath: &apos;/assets/&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>–<br>GOOD LUCK!</p><p>参考：<br><a href="https://webpack.js.org/guides/public-path/" target="_blank" rel="noopener">https://webpack.js.org/guides/public-path/</a><br><a href="https://www.npmjs.com/package/file-loader" target="_blank" rel="noopener">https://www.npmjs.com/package/file-loader</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack优化之happypack</title>
      <link href="/2019/11/29/webpack%E4%BC%98%E5%8C%96%E4%B9%8Bhappypack/"/>
      <url>/2019/11/29/webpack%E4%BC%98%E5%8C%96%E4%B9%8Bhappypack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上篇文章<a href="https://champyin.com/2019/11/15/webpack%E4%BC%98%E5%8C%96%E4%B9%8B%E7%8E%A9%E8%BD%AC%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E5%92%8C%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%E6%8F%90%E5%8F%96/">webpack优化之玩转代码分割和公共代码提取</a>从代码维度出发，为生产环节进行了优化（通过提取公用代码减小打包结果体积，提升线上体验）。而在开发大型前端项目时，经过一段时间的开发维护和不断迭代，随着业务功能增多，就算提取了公共代码，项目体积仍会越来越大（如果不从产品层面优化，这是无法避免的），这意味着编译打包时间会越来越久、从修改代码到看到效果的等待时间越来越长。为了更好的开发体验，这次我们来为开发环节做一些事情。</p></blockquote><a id="more"></a><h1 id="How？"><a href="#How？" class="headerlink" title="How？"></a>How？</h1><p>我们可以试试使用happypack。虽然这个包有点老了，作者也不怎么维护了（汗。。（因为他不怎么使用javascript了，他推荐了thread-loader，有空研究下）</p><h1 id="Happypack"><a href="#Happypack" class="headerlink" title="Happypack"></a>Happypack</h1><p><a href="https://www.npmjs.com/package/happypack" target="_blank" rel="noopener">Happypack</a> 是一个webpack插件，它可以帮助我们实现多线程打包，提升webpack打包性能，减少开发者等待打包的时间，从而提升开发体验，提高开发效率。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Happypack的使用非常简单，只需3步：</p><ol><li><p>安装happypack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D happypack</span><br></pre></td></tr></table></figure></li><li><p>修改<code>rules</code>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">rest: /\.js$/,</span><br><span class="line">use: &apos;Happypack/loader?id=js&apos; //id用于在接下来的插件中引用，便于识别对谁进行多线程打包</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在webpack插件中 new happypack<br>把原来在<code>rules</code>中配置的<code>use</code>参数放到happypack插件参数中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Happypack(&#123;</span><br><span class="line">id: &apos;js&apos;,</span><br><span class="line">use :[&#123;</span><br><span class="line">loader: &apos;babel-loader&apos;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>最后大致长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const Happypack = require(&apos;happypack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">mode: &apos;development&apos;,</span><br><span class="line">entry: xxx,</span><br><span class="line">output: xxx,</span><br><span class="line">module: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">rest: /\.js$/,</span><br><span class="line">use: &apos;Happypack/loader?id=js&apos;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">new Happypack(&#123;</span><br><span class="line">id: &apos;js&apos;,</span><br><span class="line">use :[&#123;</span><br><span class="line">loader: &apos;babel-loader&apos;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果还要对其他类型的文件进行多线程打包，可以继续替换和new就行（注意id的对应）。</p><blockquote><p>happypack适用于比较大的项目，如果项目比较小，使用happypack可能会花更长时间，因为开线程需要消耗一些性能。</p></blockquote><p>–<br>GOOD LUCK！</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack优化之玩转代码分割和公共代码提取</title>
      <link href="/2019/11/15/webpack%E4%BC%98%E5%8C%96%E4%B9%8B%E7%8E%A9%E8%BD%AC%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E5%92%8C%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%E6%8F%90%E5%8F%96/"/>
      <url>/2019/11/15/webpack%E4%BC%98%E5%8C%96%E4%B9%8B%E7%8E%A9%E8%BD%AC%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E5%92%8C%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%E6%8F%90%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/webpack-optimize-cover2.png" alt="webpack-optimize-cover2.png"></p><blockquote><p>开发多页应用的时候，如果不对webpack打包进行优化，当某个模块被多个入口模块引用时，它就会被打包多次（在最终打包出来的某几个文件里，它们都会有一份相同的代码）。当项目业务越来越复杂，打包出来的代码会非常冗余，文件体积会非常庞大。大体积文件会增加编译时间，影响开发效率；如果直接上线，还会拉长请求和加载时长，影响网站体验。作为一个追求极致体验的攻城狮，是不能忍的。所以在多页应用中优化打包尤为必要。那么如何优化webpack打包呢？</p></blockquote><a id="more"></a><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>在一切开始前，有必要先理清一下这三个概念：</p><ul><li>module: 模块，在webpack眼里，任何可以被导入导出的文件都是一个模块。</li><li>chunk: chunk是webpack拆分出来的：<ul><li>每个入口文件都是一个chunk</li><li>通过 import、require 引入的代码也是</li><li>通过 splitChunks 拆分出来的代码也是</li></ul></li><li>bundle: webpack打包出来的文件，也可以理解为就是对chunk编译压缩打包等处理后的产出。</li></ul><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><p>首先，简单分析下，我们刚才提到的打包问题：</p><ul><li>核心问题就是：多页应用打包后代码冗余，文件体积大。</li><li>究其原因就是：相同模块在不同入口之间没有得到复用，bundle之间比较独立。</li></ul><p>弄明白了问题的原因，那么大致的解决思路也就出来了：</p><ul><li>我们在打包的时候，应该把不同入口之间，共同引用的模块，抽离出来，放到一个公共模块中。这样不管这个模块被多少个入口引用，都只会在最终打包结果中出现一次。————解决代码冗余。</li><li>另外，当我们把这些共同引用的模块都堆在一个模块中，这个文件可能异常巨大，也是不利于网络请求和页面加载的。所以我们需要把这个公共模块再按照一定规则进一步拆分成几个模块文件。————减小文件体积。</li><li>至于如何拆分，方式因人而异，因项目而异。我个人的拆分原则是：<ul><li>业务代码和第三方库分离打包，实现代码分割；</li><li>业务代码中的公共业务模块提取打包到一个模块；</li><li>第三方库最好也不要全部打包到一个文件中，因为第三方库加起来通常会很大，我会把一些特别大的库分别独立打包，剩下的加起来如果还很大，就把它按照一定大小切割成若干模块。</li></ul></li></ul><h2 id="optimization-splitChunks"><a href="#optimization-splitChunks" class="headerlink" title="optimization.splitChunks"></a>optimization.splitChunks</h2><p>webpack提供了一个非常好的内置插件帮我们实现这一需求：<code>CommonsChunkPlugin</code>。不过在 webpack4 中<code>CommonsChunkPlugin</code>被删除，取而代之的是<code>optimization.splitChunks</code>, 所幸的是<code>optimization.splitChunks</code>更强大！</p><h2 id="三、-实现"><a href="#三、-实现" class="headerlink" title="三、 实现"></a>三、 实现</h2><p>通过一个多页应用的小demo，我们一步一步来实现上述思路的配置。</p><p>demo目录结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|--public/</span><br><span class="line">|   |--a.html</span><br><span class="line">|   |--index.html</span><br><span class="line">|--src/</span><br><span class="line">|   |--a.js</span><br><span class="line">|   |--b.js</span><br><span class="line">|   |--c.js</span><br><span class="line">|   |--index.js</span><br><span class="line">|--package.json</span><br><span class="line">|--webpack.config.js</span><br></pre></td></tr></table></figure></p><p>代码逻辑很简单，<code>index</code>模块中引用了 <code>a</code> 和 <code>b</code> 2个模块，<code>a</code> 模块中引用了 <code>c</code> 模块和 <code>jquery</code>库，<code>b</code> 模块中也引用了 <code>c</code> 模块和 <code>jquery</code> 库，<code>c</code> 是一个独立的模块没有其他依赖。</p><p>index.js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">import a from &apos;./a.js&apos;;</span><br><span class="line">import b from &apos;./b.js&apos;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&apos;index-------&apos;);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p><p>a.js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">require(&apos;./c.js&apos;);</span><br><span class="line">const $ = require(&apos;jquery&apos;)</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&apos;a-------&apos;);</span><br><span class="line">&#125;</span><br><span class="line">module.exports = fn();</span><br></pre></td></tr></table></figure></p><p>b.js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//b.js</span><br><span class="line">require(&apos;./c.js&apos;);</span><br><span class="line">const $ = require(&apos;jquery&apos;)</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&apos;b-------&apos;);</span><br><span class="line">&#125;</span><br><span class="line">module.exports = fn();</span><br></pre></td></tr></table></figure></p><p>c.js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//c.js</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&apos;c-------&apos;);</span><br><span class="line">&#125;</span><br><span class="line">module.exports = fn();</span><br></pre></td></tr></table></figure></p><h3 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1. 基本配置"></a>1. 基本配置</h3><p>webpack先不做优化，只做基本配置看看效果。项目配置了2个入口，搭配<code>html-webpack-plugin</code>实现多页打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: &apos;./src/index.js&apos;,</span><br><span class="line">        a: &apos;./src/a.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;[name].js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./public/index.html&apos;,</span><br><span class="line">            filename: &apos;index.html&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./public/a.html&apos;,</span><br><span class="line">            filename: &apos;a.html&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在开发模式下运行webpack：<br><img src="/images/webpack-normal-build.jpg" alt="webpack-normal-build.jpg"></p><p>可以看到，打包出两个html和两个体积很大的（300多K）的文件<code>a.js</code>,<code>index.js</code>。</p><p>进入dist目录检查js文件：</p><ul><li><code>a.js</code>里包含<code>c</code>模块代码和<code>jquery</code>代码</li><li><code>index.js</code>里包含<code>a</code>模块、<code>b</code>模块、<code>c</code>模块和<code>jquery</code>代码</li></ul><p>看，同样的代码<code>c</code>和<code>jquery</code>被打包了2遍。</p><h3 id="2-初步添加splitChunks优化配置"><a href="#2-初步添加splitChunks优化配置" class="headerlink" title="2. 初步添加splitChunks优化配置"></a>2. 初步添加splitChunks优化配置</h3><p>首先解决相同代码打包2次的问题，我们需要让webpack把<code>c</code>和<code>jquery</code>提取出来打包为公共模块。</p><p>在webpack配置文件添加splitChunks：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">            default: &#123;</span><br><span class="line">                name: &apos;common&apos;,</span><br><span class="line">                chunks: &apos;initial&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="cacheGroups"><a href="#cacheGroups" class="headerlink" title="- cacheGroups"></a>- cacheGroups</h4><ul><li><code>cacheGroups</code>是<code>splitChunks</code>配置的核心，对代码的拆分规则全在<code>cacheGroups</code>缓存组里配置。</li><li>缓存组的每一个属性都是一个配置规则，我这里给他的<code>default</code>属性进行了配置，属性名可以不叫default可以自己定。属性的值是一个对象，里面放的我们对一个代码拆分规则的描述。</li></ul><h4 id="name"><a href="#name" class="headerlink" title="- name"></a>- name</h4><ul><li>name：提取出来的公共模块将会以这个来命名，可以不配置，如果不配置，就会生成默认的文件名，大致格式是<code>index～a.js</code>这样的。</li></ul><h4 id="chunks"><a href="#chunks" class="headerlink" title="- chunks"></a>- chunks</h4><ul><li>chunks：指定哪些类型的chunk参与拆分，值可以是string可以是函数。如果是string，可以是这个三个值之一：<code>all</code>,<code>async</code>,<code>initial</code>，<code>all</code>代表所有模块，<code>async</code>代表只管异步加载的, <code>initial</code>代表初始化时就能获取的模块。如果是函数，则可以根据chunk参数的name等属性进行更细致的筛选。</li></ul><p>再次打包：<br><img src="/images/webpack-optimize-build.jpg" alt="webpack-optimize-build.jpg"></p><p>可以看到<code>a.js</code>,<code>index.js</code>从300多K减少到6点几K。同时增加了一个<code>common.js</code>文件，并且两个打包入口都自动添加了<code>common.js</code>这个公共模块：</p><p><img src="/images/webpack-optimize-build2.jpg" alt="webpack-optimize-build2.jpg"></p><p>进入dist目录，依次查看这3个js文件：</p><ul><li><code>a.js</code>里不包含任何模块的代码了，只有webpack生成的默认代码。</li><li><code>index.js</code>里同样不包含任何模块的代码了，只有webpack生成的默认代码。</li><li><code>common.js</code>里有<code>a</code>,<code>b</code>,<code>c</code>,<code>index</code>,<code>jquery</code>代码。</li></ul><p>发现，提是提取了，但是似乎跟我们预料的不太一样，所有的模块都跑到<code>common.js</code>里去了。</p><p>这是因为我们没有告诉webpack（<code>splitChunks</code>）什么样的代码为公共代码，<code>splitChunks</code>默认任何模块都会被提取。</p><h4 id="minChunks"><a href="#minChunks" class="headerlink" title="- minChunks"></a>- minChunks</h4><p><code>splitChunks</code>是自带默认配置的，而缓存组默认会继承这些配置，其中有个<code>minChunks</code>属性：</p><ul><li>它控制的是每个模块什么时候被抽离出去：当模块被不同entry引用的次数大于等于这个配置值时，才会被抽离出去。</li><li>它的默认值是1。也就是任何模块都会被抽离出去（入口模块其实也会被webpack引入一次）。</li></ul><p>我们上面没有配置<code>minChunks</code>，只配置了<code>name</code>和<code>chunk</code>两个属性，所以<code>minChunks</code>的默认值 <code>1</code> 生效。也难怪所有的模块都被抽离到<code>common.js</code>中了。</p><p>优化一下，在缓存组里配置<code>minChunks</code>覆盖默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">            default: &#123;</span><br><span class="line">                name: &apos;common&apos;,</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                minChunks: 2  //模块被引用2次以上的才抽离</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后运行webpack<br><img src="/images/webpack-optimize-build3.jpg" alt="webpack-optimize-build3.jpg"></p><p>可以看到有2个文件的大小发生了变化：<code>common.js</code>由314K减小到311K，<code>index.js</code>由6.22K增大到7.56K。</p><p>进入dist目录查看：</p><ul><li><code>a.js</code>里依然不包含任何模块的代码（正常，因为<code>a</code>作为模块被<code>index</code>引入了一次，又作为入口被webpack引入了一次，所以<code>a</code>是有2次引用的）。</li><li><code>index.js</code>里出现了<code>b</code>和<code>index</code>模块的代码了。</li><li><code>common.js</code>里只剩<code>a</code>,<code>c</code>,和<code>jquery</code>模块的代码。</li></ul><p>现在我们把共同引用的模块<code>a</code>, <code>c</code>, <code>jquery</code>，从<code>a</code>和<code>index</code>这两个入口模块里抽取到<code>common.js</code>里了。有点符合我们的预期了。</p><h3 id="3-配置多个拆分规则"><a href="#3-配置多个拆分规则" class="headerlink" title="3. 配置多个拆分规则"></a>3. 配置多个拆分规则</h3><h4 id="3-1-实现代码分离，拆分第三方库"><a href="#3-1-实现代码分离，拆分第三方库" class="headerlink" title="3.1 实现代码分离，拆分第三方库"></a>3.1 实现代码分离，拆分第三方库</h4><p>接下来，我希望公共模块<code>common.js</code>中，业务代码和第三方模块jquery能够剥离开来。</p><p>我们需要再添加一个拆分规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">    minSize: 30,  //提取出的chunk的最小大小</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">            default: &#123;</span><br><span class="line">                name: &apos;common&apos;,</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                minChunks: 2,  //模块被引用2次以上的才抽离</span><br><span class="line">                priority: -20</span><br><span class="line">            &#125;,</span><br><span class="line">            vendors: &#123;  //拆分第三方库（通过npm|yarn安装的库）</span><br><span class="line">            test: /[\\/]node_modules[\\/]/,</span><br><span class="line">                name: &apos;vendor&apos;,</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                priority: -10</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我给cacheGroups添加了一个vendors属性（属性名可以自己取，只要不跟缓存组下其他定义过的属性同名就行，否则后面的拆分规则会把前面的配置覆盖掉）。</p><h4 id="minSize"><a href="#minSize" class="headerlink" title="- minSize"></a>- minSize</h4><p>minSize设置的是生成文件的最小大小，单位是字节。如果一个模块符合之前所说的拆分规则，但是如果提取出来最后生成文件大小比minSize要小，那它仍然不会被提取出来。这个属性可以在每个缓存组属性中设置，也可以在splitChunks属性中设置，这样在每个缓存组都会继承这个配置。这里由于我的demo中文件非常小，为了演示效果，我把minSize设置为30字节，好让公共模块可以被提取出来，正常项目中不用设这么小。</p><h4 id="priority"><a href="#priority" class="headerlink" title="- priority"></a>- priority</h4><p>priority属性的值为数字，可以为负数。作用是当缓存组中设置有多个拆分规则，而某个模块同时符合好几个规则的时候，则需要通过优先级属性priority来决定使用哪个拆分规则。优先级高者执行。我这里给业务代码组设置的优先级为-20，给第三方库组设置的优先级为-10，这样当一个第三方库被引用超过2次的时候，就不会打包到业务模块里了。</p><h4 id="test"><a href="#test" class="headerlink" title="- test"></a>- test</h4><p>test属性用于进一步控制缓存组选择的模块，与chunks属性的作用有一点像，但是维度不一样。test的值可以是一个正则表达式，也可以是一个函数。它可以匹配模块的绝对资源路径或chunk名称，匹配chunk名称时，将选择chunk中的所有模块。我这里用了一个正则<code>/[\\/]node_modules[\\/]/</code>来匹配第三方模块的绝对路径，因为通过npm或者yarn安装的模块，都会存放在node_modules目录下。</p><p>运行一下webpack：<br><img src="/images/webpack-optimize-build4.jpg" alt="webpack-optimize-build4.jpg"></p><p>可以看到新产生了一个叫<code>vendor.js</code>的文件（name属性的值），同时<code>common.js</code>文件体积由原来的311k减少到了861bytes！</p><p>进入dist目录，检查js文件：</p><ul><li><code>a.js</code>里不包含任何模块代码。</li><li><code>common.js</code>只包含<code>a</code>和<code>c</code>模块的代码。</li><li><code>index.js</code>只包含<code>b</code>和<code>index</code>模块的代码。</li><li><code>vendor.js</code>只包含<code>jquery</code>模块的代码。</li></ul><p>现在，我们在上一步的基础上，成功从<code>common.js</code>里把第三方库<code>jquery</code>抽离出来放到了<code>vendor.js</code>里。</p><h4 id="3-2-拆分指定文件"><a href="#3-2-拆分指定文件" class="headerlink" title="3.2 拆分指定文件"></a>3.2 拆分指定文件</h4><p>如果我们还想把项目中的某一些文件单独拎出来打包（比如工程本地开发的组件库），可以继续添加拆分规则。比如我的src下有个<code>locallib.js</code>文件要单独打包，假设<code>a.js</code>中引入了它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">require(&apos;./c.js&apos;);</span><br><span class="line">require(&apos;./locallib.js&apos;);  //引入自己本地的库</span><br><span class="line">const $ = require(&apos;jquery&apos;)</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&apos;a-------&apos;);</span><br><span class="line">&#125;</span><br><span class="line">module.exports = fn();</span><br></pre></td></tr></table></figure></p><p>可以这么配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        minSize: 30,  //提取出的chunk的最小大小</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">            default: &#123;</span><br><span class="line">                name: &apos;common&apos;,</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                minChunks: 2,  //模块被引用2次以上的才抽离</span><br><span class="line">                priority: -20</span><br><span class="line">            &#125;,</span><br><span class="line">            vendors: &#123;  //拆分第三方库（通过npm|yarn安装的库）</span><br><span class="line">            test: /[\\/]node_modules[\\/]/,</span><br><span class="line">                name: &apos;vendor&apos;,</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                priority: -10</span><br><span class="line">            &#125;,</span><br><span class="line">            locallib: &#123;  //拆分指定文件</span><br><span class="line">            test: /(src\/locallib\.js)$/,</span><br><span class="line">                name: &apos;locallib&apos;,</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                priority: -9</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我在缓存组下又新增了一个拆分规则，通过test正则指定我就要单独打包<code>src/locallib.js</code>文件，并且把优先级设置为-9，这样当它被多次引用时，不会进入其他拆分规则组，因为另外两个规则的优先级都比它要低。</p><p>运行webpack打包后：<br><img src="/images/webpack-optimize-build5.jpg" alt="webpack-optimize-build5.jpg"></p><p>可以看到新产生了一个<code>locallib.js</code>文件。进入dist目录查看：</p><ul><li><code>a.js</code>里不包含任何模块代码。</li><li><code>common.js</code>只包含<code>a</code>和<code>c</code>模块的代码。</li><li><code>index.js</code>只包含<code>b</code>和<code>index</code>模块的代码。</li><li><code>vendor.js</code>只包含<code>jquery</code>模块的代码。</li><li><code>locallib.js</code>里只包含<code>locallib</code>模块的代码。</li></ul><p>现在我们又在上一步的基础上独立打包了一个指定的模块<code>locallib.js</code>。    </p><p>至此，我们就成功实现了抽离公共模块、业务代码和第三方代码剥离、独立打包指定模块。</p><p>对比一下，优化前，打包出来js一共有633KB：<br><img src="/images/webpack-before-optimize.png" alt="webpack-before-optimize.png"></p><p>优化后，打包出来js一共不到330KB：<br><img src="/images/webpack-after-optimize.png" alt="webpack-after-optimize.png"></p><p>优化打包后的文件分类清晰，体积比优化前缩小了几乎50%，有点小完美是不是！击掌！这还只是我举的一个简单例子，在实际多页应用中，优化力度说不定还不止这么多。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>webpack很强大，以上只是冰山一角，但是只要掌握了上述<code>optimization.splitChunks</code>的核心配置，我们就可以几乎随心所欲地按照自己的想法来拆分优化代码控制打包文件了，是不是很酷？</p><p>用webpack玩转代码拆分，你也可以！</p><p>本文的完整webpack配置和demo源码可以在这里获取：<br><a href="https://github.com/yc111/webpack-optimize-demo" target="_blank" rel="noopener">https://github.com/yc111/webpack-optimize-demo</a></p><p>欢迎一起探讨～</p><p>如果觉得这些依然不能满足你的需求，还想更精(bian)细(tai)地定制打包规则，可以到<a href="https://webpack.js.org/plugins/split-chunks-plugin/#optimizationsplitchunks" target="_blank" rel="noopener">webpack官网</a>查看<code>optimization.splitChunks</code>的更多配置。</p><p>–<br>GOODLUCK！</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> webpack </tag>
            
            <tag> splitChunks </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack如何不打包第三方模块</title>
      <link href="/2019/11/13/webpack%E5%A6%82%E4%BD%95%E4%B8%8D%E6%89%93%E5%8C%85%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/11/13/webpack%E5%A6%82%E4%BD%95%E4%B8%8D%E6%89%93%E5%8C%85%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在一些前端工程中，不是所有的模块都需要打包到最终的生产中，例如开发UI库，我们不需要把依赖的基础框架和库打进去（比如vue，react，jquery等），因为它们在业务工程中会肯定会被引入，没必要在UI库中打包，而且打包进来不仅让UI库体积庞大，还可能在业务工程中引发版本依赖冲突。那么如何让工程在打包中避开某些不希望被打包的第三方模块呢？</p></blockquote><a id="more"></a><p>webpack的<code>externals</code>可以帮到你，它的配置非常简单。</p><h2 id="external的配置"><a href="#external的配置" class="headerlink" title="external的配置"></a>external的配置</h2><p>在webpack的配置文件中添加<code>externals</code>属性，把你不希望打包在最终结果中的包写进去就行了，你的其他代码不需要任何更改，头部的 import、require 什么的都不用变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">externals: &#123;</span><br><span class="line">jquery: &apos;jquery&apos;,</span><br><span class="line">react: &apos;react&apos;,</span><br><span class="line">&apos;react-dom&apos;: &apos;react-dom&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再build打包的时候，你会发现打包出来的文件体积小了很多很多，打开编译后的文件看就会发现指定的第三方库都从代码中剔除了。</p><p>–<br>GOODLUCK！</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie、session</title>
      <link href="/2019/11/09/cookie%E3%80%81session/"/>
      <url>/2019/11/09/cookie%E3%80%81session/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Cookie是什么？它的工作原理是什么？Session是什么？它跟Cookie有什么区别？</p></blockquote><a id="more"></a><p>Web应用是基于Http协议的，Http协议是无状态协议，因此没办法把同一个用户的两次请求关联起来，用户必须每操作一次就要登录一次。为了支持客户端与服务器之间的交互，我们需要一种技术为交互存储状态，Cookie和Session就应运而生。</p><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><ul><li><p>Cookie：<br>Cookie由W3C组织提出。Cookie属于http协议标准，它是一段小信息，由服务器创建，以文本形式存储在客户端（浏览器）。用于存储一些服务器需要的用户信息数据，最大4KB。</p></li><li><p>Session：<br>Session不属于任何协议，只是一个域对象，由服务器创建，保存在服务器上（默认是服务器内存，也可以存存redies或其他数据库如mogo等）。用于存储一些客户端会话数据，没有大小限制。</p></li><li><p>会话：<br>用户打开浏览器访问某个网站，在这个网站上浏览任意页面，访问完成后将浏览器关闭的过程称为一次会话。Cookie和Session都属于常见的会话技术。会话技术是用于解决在会话过程中数据的保存问题。</p></li></ul><h1 id="二、Cookie的工作原理"><a href="#二、Cookie的工作原理" class="headerlink" title="二、Cookie的工作原理"></a>二、Cookie的工作原理</h1><p>服务器收到客户端请求，如果服务器需要记录该用户状态：</p><ol><li>则可以创建一个Cookie，放上用户信息，然后把Cookie信息附在Response Header（响应头）里，传给客户端（浏览器）。</li><li>浏览器收到响应后，会自动把这个Cookie保存到本地。</li><li>当客户端再次向该网站发出http请求时，浏览器会自动往Request Header（请求头）里添加这个Cookie。</li><li>服务器收到后，就可以根据请求里的Cookie字段，辨认用户状态等，也可以根据需要修改Cookie的内容。</li></ol><p>另外：</p><ul><li>JavaScript能够任意读写Cookie，所以浏览器也可以改Cookie的内容，因此Cookie被视为不安全的。</li><li>Cookie中的信息一般都需要先经过加密。</li><li>Cookie不能跨域，但可以通过设置Cookie的domain参数来支持跨子域名（注意domain必须以<code>.</code>开头）。</li><li>很多浏览器都限制一个站点最多保存20个Cookie。</li></ul><blockquote><p>在浏览器想获取Cookie，可以通过<code>document.cookie</code>，获取该网站的所有Cookie。</p></blockquote><h4 id="Cookie生命周期"><a href="#Cookie生命周期" class="headerlink" title="Cookie生命周期"></a>Cookie生命周期</h4><p>只要设置了正常的有效期，浏览器会把Cookie保存到硬盘，关闭再打开浏览器，Cookie依然有效，直到超过设定的失效时间。Cookie有两种方式设置有效期，也可以称为生命周期。</p><p><strong>maxAge</strong></p><ul><li>单位秒，设置的是从现在起，往后多久失效。</li><li>如果为正数，则该Cookie在maxAge秒后失效。</li><li>如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。这种称为会话Cookie。</li><li>如果为0，表示删除该Cookie。</li><li>默认为-1，即默认在浏览器关闭后，Cookie就失效。</li></ul><p><strong>expires</strong></p><ul><li>可以设置一个绝对时间点，到达时间点即失效。</li><li>可以设置为整天数，表示expires天后失效。</li><li>如果设置的是一个过去的时间，那么这个Cookie会被立即删掉，立即失效。</li></ul><h1 id="三、Session的工作原理"><a href="#三、Session的工作原理" class="headerlink" title="三、Session的工作原理"></a>三、Session的工作原理</h1><p>服务器收到客户端请求，如果服务器需要记录该用户状态：</p><ol><li>则服务器可以产生一个Session，同时会生成一个唯一的sessionId，</li><li>服务器将这个sesionId通过<code>set-cookie</code>的放到Cookie中，借用Cookie的方式传给客户端，</li><li>客户端接收到响应后，浏览器会把Cookie保存，也就同时保存了sessionId。</li><li>当用户再次向该网站发出http请求时，浏览器的自动附加Cookie机制，让服务器收到带sessionId的Cookie，然后服务器通过sessionId来匹配用户状态，比如是否登录等。</li></ol><p>另外：</p><ul><li>因为Session存在服务端，所以它不能被客户端获取和修改，因此比Cookie安全些。</li><li>因为在服务端，Session没有跨域问题。</li><li>如果客户端禁用了Cookie的话，服务器还可以通过重写URL的方式把Session传给客户端。</li><li>由浏览器窗口内的链接、脚本等打开的新窗口，这类子窗口会共享父窗口的Cookie，因此也会共享一个Session。</li></ul><h4 id="Session生命周期"><a href="#Session生命周期" class="headerlink" title="Session生命周期"></a>Session生命周期</h4><ul><li>Session在用户第一次访问服务器的时候创建。</li><li>Session生成后，只要用户继续访问，服务器就会认为该用户的Session活跃（active）了一次，然后更新Session的最后访问时间，维护该Session。</li><li>如果正常关闭服务器，Session会序列化到硬盘。当服务器重新启动时，会执行反序列化。</li><li>一般包含Session信息的Cookie会设置失效时间为0，即浏览器进程有效时间，这种情况当浏览器关闭，Cookie失效，服务器在收到下一次请求后，就会销毁Session。</li><li>为了获取更高的存取速度，服务器一般把Session存在内存里。每个用户都有一个独立的Seesion，为了防止内存溢出，服务器会把长时间没有活跃的Session从内存中删除。这个时间就是Session的超时时间。另外，如果服务器宕机，Session也就销毁了</li><li>当Session被存在了数据库，则它的生命周期由Cookie的失效时间决定：如果此时服务器宕机，只要开机后数据库没有发生不可逆的破坏，Cookie时间没过期，那么Session继续保持；当Cookie过期，服务器将Session从数据库移除。</li></ul><p>–<br>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie</a><br><a href="https://blog.csdn.net/fangaoxin/article/details/6952954" target="_blank" rel="noopener">https://blog.csdn.net/fangaoxin/article/details/6952954</a><br><a href="https://www.cnblogs.com/zhuanzhuanfe/p/8010854.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuanzhuanfe/p/8010854.html</a><br><a href="http://www.itheima.com/news/20180831/150322.html" target="_blank" rel="noopener">http://www.itheima.com/news/20180831/150322.html</a><br><a href="https://blog.csdn.net/pingfan592/article/details/88388045" target="_blank" rel="noopener">https://blog.csdn.net/pingfan592/article/details/88388045</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过webpack定义全局模块</title>
      <link href="/2019/11/08/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87webpack%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/11/08/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87webpack%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不知道大家在开发中有没有遇到这种情况，就是在很多模块里都要用到某一个库，于是在这些模块里都要不厌其烦地import一遍。页面少也还好，当项目庞大到一定程度，就有些讨厌了。有没有办法不要每次使用前都import，而是有个全局的引入，在其他任何地方直接使用就行了呢？有，webpack可以帮我们，它的内置插件ProvidePlugin就是为这个而生的。</p></blockquote><a id="more"></a><h2 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h2><p>在webpack配置文件中配置 webpack.ProvidePlugin 插件。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new webpack.ProvidePlugin(&#123;</span><br><span class="line">identifier: &apos;modulename&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>如果像上面一样，直接指定模块名，确保你的模块就在当前目录下，或者是通过npm、yarn安装的。因为这么写，默认模块路径为当前目录<code>./**</code>和<code>node_modules</code>，webpack只会从这两个目录去加载模块（先找当前目录，找不到找node_modules目录）。</p></blockquote><p>另外如果是导入ES6modules，需要指定模块的默认导出属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new webpack.ProvidePlugin(&#123;</span><br><span class="line">identifier: [&apos;modulename&apos;,&apos;propertyname&apos;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>你也可以自己指定模块的完整绝对路径。这样你的模块可以放在工程的任何目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new webpack.ProvidePlugin(&#123;</span><br><span class="line">identifier: path.resolve(__dirname, somepath ,&apos;modulename&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>例如我在项目中要用到jQuery, Vue, mili(项目中的自己开发的工具模块)，这几个模块在很多地方都要使用，我就可以把他们申明在 ProvidePlugin 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">new webpack.ProvidePlugin(&#123;</span><br><span class="line">$: &apos;jquery&apos;,</span><br><span class="line">&apos;window.$&apos;: &apos;jquery&apos;,</span><br><span class="line">Vue: [&apos;vue/dist/vue.esm.js&apos;, &apos;default&apos;],</span><br><span class="line">mili: path.resolve(__dirname, &apos;src&apos;, &apos;mili&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><p>ProvidePlugin是webpack内置的插件，在里面申明过的模块变量名，都可以在工程中任何模块中直接独立使用。因为webpack编译后，在代码中遇到独立出现的这些全局变量名时，会去自动加载它对应的模块，并把这个模块导出的内容（或者导出的某个指定的属性）赋给这个模块变量名。</p><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3. 应用"></a>3. 应用</h2><p>当我在ProvidePlugin中申明过全局模块变量后，在其他模块，我可以直接使用它们，而不用在头部import了。<br>例如就上面例子中我申明了<code>$</code>, <code>window.$</code>, <code>Vue</code>, <code>mili</code> 四个全局模块变量，我就可以直接这么使用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// any module file</span><br><span class="line">// free to use $, window.$, Vue, mili，without importing them.</span><br><span class="line"></span><br><span class="line">let &#123;Message&#125; = mili;</span><br><span class="line">let $toot = $(&apos;#root&apos;);</span><br><span class="line">let $ele = window.$(&apos;#container&apos;);</span><br><span class="line">Vue.prototype.$bus = new Vue;</span><br></pre></td></tr></table></figure></p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>除了webpack.ProvidePlugin，还有其他方法实现全局模块变量，当作番外简单介绍一下吧。</p><h3 id="1-html引用"><a href="#1-html引用" class="headerlink" title="1. html引用"></a>1. html引用</h3><p>我们还可以通过在<code>index.html</code>模版中通过<code>script</code>标签引入全局模块。这个模块的路径可以是CDN地址，也可以是本地路径。<br>然后在每个模块中就都能使用这个模块了。</p><h4 id="引用CDN"><a href="#引用CDN" class="headerlink" title="引用CDN"></a>引用CDN</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//index.html file</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><h4 id="引用本地"><a href="#引用本地" class="headerlink" title="引用本地"></a>引用本地</h4><p>前提是这个文件在项目发布的时候服务器上要有，所以记得在webpack上配置 copy-webpack-plugin 插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//index.html file</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script src=&quot;/vendor/jquery_3.4.1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></p><p>这样在其他模块都可以直接使用<code>window.$</code>和<code>$</code>了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(window.$);</span><br><span class="line">console.log($);</span><br></pre></td></tr></table></figure></p><h3 id="2-expose-loader"><a href="#2-expose-loader" class="headerlink" title="2. expose-loader"></a>2. expose-loader</h3><p><a href="https://www.npmjs.com/package/expose-loader" target="_blank" rel="noopener">expose-loader</a> 虽然是一个比较老的包，但是依然可用。它的作用是给全局对象window添加模块。</p><p>先安装：<code>npm i -S expose-loader</code></p><h4 id="可以内联使用"><a href="#可以内联使用" class="headerlink" title="可以内联使用"></a>可以内联使用</h4><p>在入口文件导入全局模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;expose-loader?$!jquery&apos;);</span><br></pre></td></tr></table></figure></p><p>或则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import $ from &apos;expose-loader?$!jquery&apos;;</span><br></pre></td></tr></table></figure></p><h4 id="也可以在webpack中配置"><a href="#也可以在webpack中配置" class="headerlink" title="也可以在webpack中配置"></a>也可以在webpack中配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">rulers: [</span><br><span class="line">&#123;</span><br><span class="line">test: require.resolve(&apos;jquery&apos;),</span><br><span class="line">use: &#123;</span><br><span class="line">loader: &apos;expose-loader&apos;,</span><br><span class="line">options: &apos;$&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论使用哪种方式，最后在任何模块都可以通过<code>window.$</code>来使用jquery了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(window.$);</span><br></pre></td></tr></table></figure></p><p>–<br>GOODLUCK!</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何利用webpack定义全局常量</title>
      <link href="/2019/11/06/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8webpack%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F/"/>
      <url>/2019/11/06/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8webpack%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在前端开发过程中，我们在不同的工程阶段，对代码会有不同的要求。比如在开发阶段，我们希望代码能更快地实时编译，自动刷新，可以调试定位源码；在接口测试阶段，我们希望可以不修改源码，只通过修改某个配置，就可以无缝切换接口地址或者上下文，以及决定请求是否携带token；在发布代码时，我们希望输出的代码体积尽可能小，代码可以各种压缩，各种分离打包等等。为了让一套代码适应不同工程阶段的需求，我们通常会刻意制造开发、测试、生产几种编译模式。然后我们通过webpack做一些配置，使得webpack在编译阶段可以识别出当前是什么模式，从而产生不同的编译行为，达到不同的编译效果。<br>而这个配置，就是webpack.DefinePlugin。它是webpack的内置插件，用于提供自定义全局常量功能。</p></blockquote><a id="more"></a><h2 id="1-配置方法"><a href="#1-配置方法" class="headerlink" title="1. 配置方法"></a>1. 配置方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js file</span><br><span class="line">plugins: [</span><br><span class="line">new webpack.DifinePlugin(&#123;</span><br><span class="line">DEVELOPMENT: &apos;&quot;dev&quot;&apos;, // JSON.stringify(&apos;dev&apos;)</span><br><span class="line">&apos;process.env.NODE_ENV&apos;: JSON.stringify(process.env.NODE_ENV)</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><p>tip1: 定义全局常量时，常量的值会需要被字符串化，需要注意的是，如果写成字符串格式，必须在单引号内再套一对双引号（或者反过来在双引号内套单引号），才能彻底字符串化，或者直接使用JSON.stringify。</p></li><li><p>tip2: 如果要为process的某个属性定义值，尽量使用<code>&#39;process.env.NODE_ENV&#39;: JSON.stringify(process.env.NODE_ENV)</code>而不要使用<code>process: { env: { NODE_ENV: JSON.stringify(&#39;production&#39;) } }</code>，因为后面的做法会覆盖process对象，会影响其他模块的兼容性（因为其他模块也可能会对它赋值）。</p></li></ul><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><p>webpack.DefinePlugin中定义的常量，它会在编译时，内联地加入代码中，相当于原地替换，所以在项目的源码任何js模块中都可以直接使用这些常量。</p><h2 id="3-全局常量使用场景"><a href="#3-全局常量使用场景" class="headerlink" title="3. 全局常量使用场景"></a>3. 全局常量使用场景</h2><p>通过webpack.DefinePlugin配置常量的意义在于，我们可以保存一些在编译时产生的变量的值，然后在编译完的运行态中，获取和使用这个常量，来做一些事情。</p><p>‘process.env.NODE_ENV’是比较常用的常量，它是我们区分不同编译模式的关键，在编译以外的代码中，我们很多时候也需要拿这个值来实现一些切换，主要目的是为了让开发、测试更方便和高效。</p><p>场景举例：<br>定义’process.env.NODE_ENV’常量，在前端发请求的时候，根据’process.env.NODE_ENV’这个常量设置不同的请求路径格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch(process.env.NODE_ENV) &#123;</span><br><span class="line">case &apos;dev&apos;:</span><br><span class="line">baseUrl = &apos;localhost:8000&apos;;</span><br><span class="line">return;</span><br><span class="line">case &apos;test&apos;:</span><br><span class="line">baseUrl = &apos;10.22.22.21:3000&apos;;</span><br><span class="line">return;</span><br><span class="line">case &apos;prod&apos;:</span><br><span class="line">baseUrl = &apos;10.69.32.101&apos;;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>–<br>GOODLUCK!</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack解决跨域的几种方法</title>
      <link href="/2019/11/05/webpack%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2019/11/05/webpack%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作为前端攻城狮，经常要面临的问题就是跨域，不论是调自己mock服务的数据，还是真实前后台联调。因为接口服务与前端工程通常都是独立的工程，而前端有很多协议需要遵循<code>同源策略</code>（后端则不需要）。解决跨域的方法有很多，可以在服务端配置，也可以在前端解决。作为前端开发者，我更偏向在前端把跨域解决掉，别问我为什么，我就是喜欢这种不依赖后端的感觉[傲娇脸]。</p></blockquote><a id="more"></a><p>PS：我使用webpack构建工程，我的方法都是基于webpack的大前提下。如果你是用的其他构建工具，或者是没有使用构建工具的工程环境，我的方法可能不能适用。</p><h1 id="不能操控服务端代码的情况"><a href="#不能操控服务端代码的情况" class="headerlink" title="不能操控服务端代码的情况"></a>不能操控服务端代码的情况</h1><p>当你不能操控服务端代码时（比如前后端联调），你可以通过webpack配置代理。</p><h2 id="1-通过-http-proxy-代理"><a href="#1-通过-http-proxy-代理" class="headerlink" title="1. 通过 http-proxy 代理"></a>1. 通过 http-proxy 代理</h2><p>在webpack配置文件 <code>webpack.config.js</code> 中添加 <code>devServer</code> 配置。然后配置它的 <code>proxy</code> 属性，webpack-dev-server 在起服务后，会把匹配的本地请求转到 <code>proxy</code> 里配置的服务器上去请求，通过服务端的转发，实现跨域。 </p><ul><li><p>有点抽象，举个栗子：</p><p>我的前端工程服务端口8000。<br>我要联调的服务端口3000，域名‘champyin.com’。</p><p>我在前端这么发请求：xhr.open(‘GET, ‘/api/students’, true);<br>那么我其实发的请求完整url为 <code>http://localhost:8000/api/students</code>,<br>直接发肯定是报错的，因为我的本地是没有这个接口的。</p><p>现在我在webpack这么配置代理，给<code>/api</code>配置一个映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">proxy: &#123;</span><br><span class="line">&apos;/api&apos;: &apos;http://champyin.com:3000&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>npm run dev</code> 重启下前端工程，webpack-dev-server 在遇到’/api/students’这种以<code>/api</code>开头的请求的时候，它不再往本地发了，而是向对应的<code>http://champyin.com:3000</code>发请求。这是一种后端的请求转发，而后端没有跨域问题。这个时候，虽然在浏览器查看网络请求的时候，会看到前端发的请求地址是<code>http://localhost:8000/api/students</code>，但其实它的背后真正获取响应的请求是<code>http://champyin.com:3000/api/students</code>。</p></li><li><p>灵活的<code>proxy</code>配置<br>很多时候，后端的接口不一定都有一个统一的前缀，这个时候，如果还按照上面的方法，那就要对每个不同的接口名配置一个映射，而且后台一旦增加接口，这里也要跟着加，每个映射的值还都是一样的，又麻烦又冗余。其实，webpack已经考虑了这一点，每一个映射规则的value可以是一个对象，并提供 <code>pathRewrite</code> 参数来重置请求的上下文。</p><p>复用一下上面的例子，只不过服务端稍有不同，服务端提供的接口没有统一的<code>/api</code>前缀，而是直接的接口名：<code>/students</code>、<code>/classes</code>、<code>/grades</code></p><p>这个时候，proxy 可以这么配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">proxy: &#123;</span><br><span class="line">&apos;/api&apos;: &#123;</span><br><span class="line">target: &apos;http://champyin.com:3000&apos;,</span><br><span class="line">pathRewrite: &#123;</span><br><span class="line">&apos;/api&apos;: &apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的前端请求依然保留<code>/api</code>前缀不用变，而在转发之前，这个前缀会自动被重置去掉。</p><p>现在我在前端依然这么发请求：xhr.open(‘GET, ‘/api/students’, true);<br>即我发的请求完整url为 <code>http://localhost:8000/api/students</code>,<br>而经过代理后的最终url为 <code>http://champyin.com:3000/students</code></p><p>这样，就不用因为后台接口不规范，而影响我们的前端代码的质量了。</p><blockquote><p>当然，这个只是在联调模式可以这么做，真正生产环境的时候，还是要后台统一规范，或者部署一个中间层做这种代理转发。</p></blockquote></li></ul><p><br></p><h1 id="可以操控服务端代码的情况"><a href="#可以操控服务端代码的情况" class="headerlink" title="可以操控服务端代码的情况"></a>可以操控服务端代码的情况</h1><p>当你可以控制服务端代码时（比如自己mock数据），你还可以通过以下的方法避免跨域（变相地解决跨域）</p><h2 id="2-在dev-server内mock数据"><a href="#2-在dev-server内mock数据" class="headerlink" title="2. 在dev-server内mock数据"></a>2. 在dev-server内mock数据</h2><p>webpack-dev-server内部其实是自己起了一个express来做服务。<br>webpack的devServer配置提供了一个<code>before</code>方法，在启动服务之前，这个方法会被执行，我们可以把我们mock数据的逻辑写在这里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">before(app) &#123;</span><br><span class="line">app.get(&apos;/api/sdutents&apos;, (req, res) =&gt; &#123;</span><br><span class="line">res.json(&#123;name: &apos;champyin&apos;, score: 100&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>这个before方法会传一个参数供我们使用，这个参数就是webpack-dev-server内部起的express对象。</p></blockquote><p>重启前端工程时，我们的mock服务也就启动了。这时，我们的mock接口跟前端其实在同一服务也就是webpack-dev-server的express服务下，也就不存在跨域了。</p><h2 id="2-在服务端启动webpack"><a href="#2-在服务端启动webpack" class="headerlink" title="2. 在服务端启动webpack"></a>2. 在服务端启动webpack</h2><p>假设后端我们的express mock接口代码长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">let app = express();</span><br><span class="line">app.get(&apos;/api/students&apos;, (req, res) =&gt; &#123;</span><br><span class="line">res.json(&#123;name: &apos;champyin&apos;, score: 100&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">console.log(&apos;server is on 3000&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>现在我们要把webpack构建放到后端来起。在后端起webpack需要用到叫做<code>webpack-dev-middleware</code>的中间件，整体逻辑大致是：<br>获取webpack模块 -&gt; 获取webpack配置文件 -&gt; 将配置文件传给webpack执行，获得compiler实例 -&gt; 把compiler实例传给webpack-dev-middleware中间件，然后整个交给express作为express中间件执行 -&gt; done!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// bin/www.js file</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">const webpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;);</span><br><span class="line"></span><br><span class="line">let webpackConf = require(&apos;../webpack.config.js&apos;);</span><br><span class="line">let compiler = webpack(webpackConf);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line">app.use(webpackDevMiddleWare(compiler));</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">console.log(&apos;server is on 3000&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>现在启动前端工程就不是<code>npm run dev</code>了，而是<code>node bin/www.js</code>。</p><p>这时，我们的前端就跟后端复用了同一个服务，自然也就不存在跨域了。</p><blockquote><p>其实这相当于在改后端了，不过这个后端是前端可以控制的，所以也算是前端的扩展了。另外，如果可以改后端的话，还可以直接在express里面通过设置请求头来实现跨域，不过这个就跟webpack没有关系了，就不在这里细讲了。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一种方法是我们提倡的跨域配置，配置代理。首选推荐。<br>第二和第三种方法其实是在你能控制后端工程的情况下，把前后端工程合并成一个工程了，区别是第二种方法相当于把后端接口移到前端工程来起，第三种方法是把前端工程构建移到后端工程来起。避免了跨域，也算是变相地解决跨域的方案吧，在某些轻量的工程里可以快速搭建调试环境。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> webpack </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-promise</title>
      <link href="/2019/11/05/es6-promise/"/>
      <url>/2019/11/05/es6-promise/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自从2015年 ES6（ECMAScript 6）正式发布以来，许多JS新特性让我们的前端开发更加语意化，更加高效。在享受新特性给我们带来的便利的同时，在各类前端框架和业务代码满天飞的同时，我觉得仍有必要不间断地去了解和总结原生JS的底层机制、原理及其优缺点。就从Promise开始。</p></blockquote><a id="more"></a><h1 id="Promise总结"><a href="#Promise总结" class="headerlink" title="Promise总结"></a>Promise总结</h1><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">console.log(1)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(2);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(data =&gt; &#123;</span><br><span class="line">console.log(data); </span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(3);</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">其中 1 和 3 是立即输出，2 是1秒后输出。</span><br></pre></td></tr></table></figure><h3 id="Promise的本质"><a href="#Promise的本质" class="headerlink" title="Promise的本质"></a>Promise的本质</h3><p>它是一个类。它是异步编程的一种解决方案。<br>它的链式调用方式，在一定程度上可以解决JS中的多层异步回调嵌套问题（也叫回调地狱）。</p><h3 id="Promise的特征"><a href="#Promise的特征" class="headerlink" title="Promise的特征"></a>Promise的特征</h3><p>1 . 一个Promise对象有三个状态：pending，fulfilled，rejected。<br>   只能当状态是pending时，这个状态才能改变，并且状态一旦发生改变，就不能再改变。</p><p>2 . Promise实例化时接受一个函数作为参数，这个函数会立即执行。<br>   这个函数暴露两个参数，分别是resolve，reject，这两个参数同样也是函数。</p><p>3 . 每个Promise对象都有一个then方法。</p><p>4 . resolve和reject都接收一个参数，这个参数将被在内部进行一些必要处理，其返回结果会传到下一个then中。</p><p>5 . 必须在这个Promise实例中调用resolve或则reject或者throw new Error，才会往下走，即then中的方法才会被执行。</p><p>6 . 一个Promise对象可以多次then，也可以连续then（链式调用），每次then都会返回一个新的Promise对象。</p><p>7 . then也接收两个参数，是两个回调函数，分别对应处理成功和失败的业务。</p><p>8 . then的回调函数中，使用return进入下一个then的成功、使用throw new Error 等报错，进入下一个then的失败。不显示写return，则默认return undefined，也是进入下一个then的成功。</p><p>9 . then是微任务，所以then中的方法会在同步代码执行后再执行。</p><p>10 . 如果Promise实例中resolve了一个Promise，Promise内部会取这个Promise的then的结果，如果还是一个Promise，继续取，直到获得一个非Promise的值，然后把这个值返回。</p><p>11 . Promise的then可以穿透，即如果中间的then没有写成功或者失败的处理，则结果会一直往下传，直到有then处理。</p><h3 id="Promise实例上的方法和静态方法"><a href="#Promise实例上的方法和静态方法" class="headerlink" title="Promise实例上的方法和静态方法"></a>Promise实例上的方法和静态方法</h3><p>Promise实例上的方法：</p><ul><li>then<br>处理回调的函数。then的链式调用，是异步有序的，写在前面的会先执行。</li><li>catch<br>本质是 <code>.then(null, rejectCallback)</code> 的别名，用于处理错误。</li><li>finally<br>ES2018 中的新特性。不管Promise成功还是失败，都会执行的操作。</li></ul><p>Promise静态方法：</p><ul><li>resolve<br>将现有对象转为Promise对象的快捷方法。</li><li>reject<br>产生一个状态为 rejected 的Promise实例。</li><li>all<br>将多个Promise实例装包成一个Promise实例，同步获取多个异步操作的结果，只有所有Promise实例的状态都为 fulfilled，这个Promise才会成功，并且返回一个数组，里面按序存放异步操作的结果。只要一个Promise被reject，整个Promise都reject。</li><li>race<br>将多个Promise实例包装成一个Promise实例，谁先改变状态，整个Promise就采用谁的状态和返回值。</li><li>any<br>目前是一个stage3提案。接受一组Promise实例，如果谁先变成 fulfilled，整个Promise fulfilled，如果都 rejected，整个都失败。</li></ul><h3 id="Promise的缺点"><a href="#Promise的缺点" class="headerlink" title="Promise的缺点"></a>Promise的缺点</h3><p>Promise不能彻底解决回调地狱，因为它也是基于回调来实现的。</p><p>解决方案：<br>结合async+await，彻底解决异步回调地狱问题。</p><h1 id="自己实现一版Promise"><a href="#自己实现一版Promise" class="headerlink" title="自己实现一版Promise"></a>自己实现一版Promise</h1><p>现在的大部分IDE和浏览器都已经内置原生Promise，不过你也可以不使用原生Promise，选择自己写一个Promise。</p><p>但如果你的Promise想跟原生Promise混用，或者想让别人使用，最好先通过 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">promiseA+规范</a> 的测试。</p><h3 id="如何测试自己的Promise是否符合PromiseA-规范"><a href="#如何测试自己的Promise是否符合PromiseA-规范" class="headerlink" title="如何测试自己的Promise是否符合PromiseA+规范"></a>如何测试自己的Promise是否符合PromiseA+规范</h3><ul><li><p>step1. 在代码中添加测试代码<br>在自己的 <code>Promise.js</code> 里，给Promise添加一个deferred静态方法，在里面new一个自己的Promise 实例，把自己的Promise实例和实例上的resolve、reject挂上去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.deferred = () =&gt; &#123;</span><br><span class="line">let dfd = &#123;&#125;;</span><br><span class="line">dfd.promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">dfd.resolve = resolve;</span><br><span class="line">dfd.reject = reject;</span><br><span class="line">&#125;)</span><br><span class="line">return dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>step2. 安装 promsises-aplus-tests 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D primises-aplus-tests</span><br></pre></td></tr></table></figure></li><li><p>step3. 运行脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  npx promises-aplus-test ./ Promise.js</span><br><span class="line">  </span><br><span class="line">&gt; npx 是 npm 8.5 以上具有的功能。</span><br></pre></td></tr></table></figure></li></ul><p>如果一切顺利，会在一片绿勾之后，得到<code>872 passing (16s)</code>这样的信息，这说明，你的Promise已经符合PromiseA+规范，即符合基本要求，可以放心使用了。</p><p>不间断补充更新中。</p><p>–<br>GoodLuck!</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git进阶之合并多次commit</title>
      <link href="/2019/10/28/git%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%90%88%E5%B9%B6%E5%A4%9A%E6%AC%A1commit/"/>
      <url>/2019/10/28/git%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%90%88%E5%B9%B6%E5%A4%9A%E6%AC%A1commit/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们开发一个功能，不是一时半会可以完成的时候，为了保护代码不丢失，通常会把这次的修改先 commit，等到这个功能完全做好，再 push。不过这样一来，就会有很多零碎的 commit 记录，这会使远程的提交历史显得杂乱。</p><p>必要的时候，我们需要将这些相近的 commit 合并为一个 commit 再 push。当然了，如果你想合并远程的 commit 也是可以的，但请一定要提前跟团队里的其他人说一声，免得有人也在跟你做同样的事情，导致没必要的代码冲突（所以合并 commit 尽量在 push 前）。</p></blockquote><a id="more"></a><p>操作步骤：</p><h2 id="1-git-log-查看commit节点id"><a href="#1-git-log-查看commit节点id" class="headerlink" title="1. git log 查看commit节点id"></a>1. git log 查看commit节点id</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>参数<code>--oneline</code>可以让你的commit log在一行输出，比较紧凑，coimmit id也以简短的位数展示，比较便于查看。<br>找到你要保留的那条commit的上一条commit（这样可以保证你要保留的那一条commit出现在pick清单的顶部），复制这条commit的id。</p><h2 id="2-git-rebase-变基"><a href="#2-git-rebase-变基" class="headerlink" title="2. git rebase 变基"></a>2. git rebase 变基</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i [commit_id]</span><br></pre></td></tr></table></figure><p><code>[commit_id]</code>就放你在第1步复制的那个值。<br>然后就会进入rebase界面，类似这样：</p><p><img src="/images/git-rebase.jpg" alt="git-rebase.jpg"></p><p>注意：观察头部的commit清单，确保你要保留的那条commit出现在内。一切顺利的话，它会出现在顶部第一条。</p><h2 id="3-修改-pick-为-squash"><a href="#3-修改-pick-为-squash" class="headerlink" title="3. 修改 pick 为 squash"></a>3. 修改 <code>pick</code> 为 <code>squash</code></h2><p>vi指令<code>i</code>进入编辑模式，修改你不想保留的commit记录前的 <code>pick</code> 为 <code>squash</code>(或者<code>s</code>)。<code>git</code> 会把前面为 <code>squash</code>的commit记录与它的上一条记录合并为一条。</p><p>注意要确保第一条为 <code>pick</code>，因为<code>squash</code>的作用是把commit合并到上一个提交，所以必须保证至少第一个提交被<code>pick</code>。</p><blockquote><p>如果你不小心把所有的<code>pick</code>都改为了<code>s</code>，然后保存退出，会收到一个错误提示：<code>cannot &#39;squash&#39; without a previous commit</code>。不要怕，根据它的下一个提示操作就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can fix this with &apos;git rebase --edit-todo&apos; and then run &apos;git rebase --continue&apos;.</span><br><span class="line">Or you can abort the rebase with &apos;git rebase --abort&apos;.</span><br></pre></td></tr></table></figure></p></blockquote><p>尽管它提示了2种方法来处理，我还是推荐你使用<code>git rebase --abort</code>，然后重来一次rebase，这样最稳妥。</p><h2 id="4-处理合并后的commit-message"><a href="#4-处理合并后的commit-message" class="headerlink" title="4. 处理合并后的commit message"></a>4. 处理合并后的commit message</h2><p>如果第3步顺利的话，<code>esc</code>之后，<code>:</code>进入指令模式，输入vi指令<code>wq</code>，保存并退出vi界面，然后会进入另一个vi界面，在这里它会把你合并的这些commit的日志列出来，便于你编辑。<br>同样使用vi指令<code>i</code>进入编辑模式，编辑完后，<code>esc</code>+<code>:</code>+<code>wq</code>回车退出。然后会出现<code>Successfully rebased and updated refs/heads/xxx.</code>说明commit合并成功了。</p><h2 id="5-如果修改的是远程的commit，则强制push一把"><a href="#5-如果修改的是远程的commit，则强制push一把" class="headerlink" title="5. 如果修改的是远程的commit，则强制push一把"></a>5. 如果修改的是远程的commit，则强制push一把</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>如果你还没push，只是处理本地的commit，则不需要这一步。否则，就需要把这次的rebase强制覆盖远程分支。</p><h2 id="done！"><a href="#done！" class="headerlink" title="done！"></a>done！</h2><p>现在可以<code>git log --oneline</code>看下，是不是commit数量已经减少了，并且你指定的那些commit都合并为了一条，message就是你在第4步处理的内容。</p><p>GoodLuck！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> rebase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack error 之 TypeError: Cannot read property &#39;properties&#39; of undefined</title>
      <link href="/2019/10/17/Webpack-error-%E4%B9%8B-TypeError-Cannot-read-property-properties-of-undefined/"/>
      <url>/2019/10/17/Webpack-error-%E4%B9%8B-TypeError-Cannot-read-property-properties-of-undefined/</url>
      
        <content type="html"><![CDATA[<blockquote><p>老项目重新 npm install 的坑，问题原因比较隐蔽，记录一下。</p></blockquote><a id="more"></a><h1 id="操作背景"><a href="#操作背景" class="headerlink" title="操作背景"></a>操作背景</h1><ul><li>去年建的项目，webpack4.4.1，webpack-cli2.0.12。</li><li>今天在另一台电脑，把项目clone下来，然后npm install, 执行build打包的时候，立即报错。</li><li>两台电脑node环境相同。<br>完整报错如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/node_modules/webpack-cli/bin/config-yargs.js:89</span><br><span class="line">describe: optionsSchema.definitions.output.properties.path.description,</span><br><span class="line">                                           ^</span><br><span class="line"></span><br><span class="line">TypeError: Cannot read property &apos;properties&apos; of undefined</span><br><span class="line">    at module.exports (/Users/yinchuan/Documents/学习/学习笔记/test/code-lib/webpack-library-example/node_modules/webpack-cli/bin/config-yargs.js:89:48)</span><br><span class="line">    at /Users/yinchuan/Documents/学习/学习笔记/test/code-lib/webpack-library-example/node_modules/webpack-cli/bin/webpack.js:60:27</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/yinchuan/Documents/学习/学习笔记/test/code-lib/webpack-library-example/node_modules/webpack-cli/bin/webpack.js:515:3)</span><br><span class="line">    at Module._compile (module.js:652:30)</span><br><span class="line">    at Object.Module._extensions..js (module.js:663:10)</span><br><span class="line">    at Module.load (module.js:565:32)</span><br><span class="line">    at tryModuleLoad (module.js:505:12)</span><br><span class="line">    at Function.Module._load (module.js:497:3)</span><br><span class="line">    at Module.require (module.js:596:17)</span><br><span class="line">    at require (internal/module.js:11:18)</span><br></pre></td></tr></table></figure></li></ul><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><ol><li><p>看提示，是webpack-cli报错，于是进webpack-cli相应目录查看<br><img src="/images/webpack-cli-config-yargs.js-line89.jpg" alt="webpack-cli-config-yargs.js-line89.jpg"></p><p>不知为啥没有获得 webapack 配置参数的 output 属性。</p></li><li><p>简单百度了一下，有人说是webpack和webpack-cli版本不对应导致，安装一下最新的webpack-cli即可解决。<br>也没太注意，就直接重新安装了webpack-cli，为了webpack也跟它匹配，连webpack一起重装了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure></li></ol><p>安装完就直接build了，但是还是报同样的错。</p><p>于是开始各种尝试，直接<code>npx webpack</code>用默认配置打包、用配置文件<code>webpack.config.js</code>打包、把工程简化到就一句console.log、把webpack配置精简到就entry和output… 排除了文件路径，代码逻辑问题，webpack和webpack-cli也都是最新的，还是没用。</p><p>最后再次百度，发现有人提到他把 webpack-cli 从2.x升级到3.x就好了，原因是 webpack 在 4.20.0 之后，需要 webpack-cli3.1.1 搭配使用。。。<br><img src="/images/webapck-release-v4.20.0.jpg" alt="webapck-release-v4.20.0.jpg"></p><blockquote><p><a href="https://github.com/webpack/webpack/releases/tag/v4.20.0" target="_blank" rel="noopener">https://github.com/webpack/webpack/releases/tag/v4.20.0</a></p></blockquote><p>我突然想到 npm package 的版本前面的那个符号有限制版本的作用，可能我以为我的webpack-cli是最新的，但其实并没有呢？</p><p>赶紧去检查了下我的本地webpack和webpack-cli版本，OHG！果然！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;webpack&quot;: &quot;^4.41.2&quot;,</span><br><span class="line">&quot;webpack-cli&quot;: &quot;^2.1.5&quot;</span><br></pre></td></tr></table></figure></p><p>刚才的重新安装后，webpack-cli并没有更新到3.x。</p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>所以问题原因终于找到：<br><code>webpack4.20.0</code>之后，需要 <code>webpack-cli3.1.1</code> 搭配使用，而现在是<code>webpack4.41.2 + webpack-cli2.1.5</code>，所以开始报开头贴出来的错。</p><p>而我以为我装了最新的实际却没有给我装最新的cli，原因是：<br>坑爹的 <code>^</code> ，这个符号会限制你在不指定package版本的install时，安装的是不超过当前大版本的最新版本。<br>所以<code>&quot;webpack-cli&quot;: &quot;^2.0.12&quot;</code>这句，限制了我直接install的<code>webpack-cli</code>版本不会超过3.0.0 。</p><blockquote><p>更多npm包版本的语意可以到官网 <a href="https://docs.npmjs.com/misc/semver" target="_blank" rel="noopener">https://docs.npmjs.com/misc/semver</a> 查阅。</p></blockquote><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>强制安装：<br><code>npm i -D webpack-cli@latest</code><br>或者在 package.json 删除<code>&quot;webpack-cli&quot;: &quot;^2.0.12&quot;</code>这句后，再使用普通安装：<br><code>npm i -D webpack-cli</code>。</p><p>再运行<code>npm run build</code> 打包，OK了～</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>不要以为重新安装一下就一定是安装最新的包。</li><li>不要忽视 npm package 的版本号前缀，它的语意很重要。</li><li>一定要关注webpack这些打包工具的release动态和特性变化，这对你的项目中如果改变了webpack的版本导致的问题很有帮助。</li><li>webpack 4.20.0 以上，需要 webpack-cli3.1.1 搭配使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> webpack-cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js操作数据库之MongoDB+mongoose篇</title>
      <link href="/2019/10/10/node.js%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMongoDB+mongoose%E7%AF%87/"/>
      <url>/2019/10/10/node.js%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMongoDB+mongoose%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/nodejs+mongodb+mongoose-cover2.png" alt="nodejs+mongodb+mongoose-cover2.png"></p><blockquote><p><code>node.js</code> 的出现，使得用前端语法(javascript)开发后台服务成为可能，越来越多的前端因此因此接触后端，甚至转向全栈发展。后端开发少不了数据库的操作。<code>MongoDB</code> 是一个基于分布式文件存储的开源数据库系统。本文为大家详细介绍了如何用 <code>node.js</code> + <code>mongoose</code> 玩转 <code>MongoDB</code> 。希望能帮到有需要的人。</p><p>由于我用Mac开发，以下所有操作都是在Mac下进行。</p></blockquote><a id="more"></a><h1 id="一、-环境搭建"><a href="#一、-环境搭建" class="headerlink" title="一、 环境搭建"></a>一、 环境搭建</h1><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><blockquote><p>有 node 环境的可以跳过。</p></blockquote><p><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">nodejs官网</a>提供了 macOS 安装包，直接下载安装即可。现在 nodejs 稳定版已经到了 <code>12.11.1</code> 。</p><h2 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h2><p><a href="https://www.mongodb.com" target="_blank" rel="noopener">MongoDB</a> 是为现代应用程序开发人员和云时代构建的基于文档的通用分布式数据库。</p><blockquote><p>上个月（9月） macOS 包管理器 Homebrew 宣布移除 MongoDB 。原因是去年10月 MongoDB 宣布将其开源许可证从 <code>GNU AGPLv3</code> 切换到 <code>SSPL（Server Side Public License）</code>，以此回应 AWS 等云厂商将 MongoDB 以服务的形式提供给用户而没有回馈社区的行为，MongoDB 希望从软件即服务上获取收入。Homebrew 认为 MongoDB 已经不再属于开源范畴…</p></blockquote><p>言归正传，由于上述原因，我们不能直接使用 <code>brew install mongodb</code> 来安装 MongoDB 了。好在 MongoDB 自己维护了一个定制化的 <a href="https://github.com/mongodb/homebrew-brew" target="_blank" rel="noopener">Homebrew tap</a>。并在 <a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/#install-mongodb-community-edition" target="_blank" rel="noopener">Install MongoDB Community Edition</a> 更新了安装步骤。</p><p>Mac下 MongoDB 的最新安装步骤如下：</p><h4 id="1-首先安装-Homebrew"><a href="#1-首先安装-Homebrew" class="headerlink" title="1. 首先安装 Homebrew"></a>1. 首先安装 <a href="https://brew.sh/#install" target="_blank" rel="noopener">Homebrew</a></h4><p>Homebrew 是 macOS 的包管理器。因为 OSX 默认不包含 Homebrew brew 包，所以要先安装，已经安装过的可以跳过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><p>  安装过程会有点长，终端输出信息超过一屏，这里我只截取了头尾两部分。<br>  <img src="/images/mg-install-homebrew.jpg" alt="mg-install-homebrew.jpg"><br>  <img src="/images/mg-install-homebrew-2.jpg" alt="mg-install-homebrew-2.jpg"></p><h4 id="2-然后获取下-MongoDB-Homebrew-Tap"><a href="#2-然后获取下-MongoDB-Homebrew-Tap" class="headerlink" title="2. 然后获取下 MongoDB Homebrew Tap"></a>2. 然后获取下 MongoDB Homebrew Tap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap mongodb/brew</span><br></pre></td></tr></table></figure><p>  <img src="/images/mg-tap-mongodb-brew.jpg" alt="mg-tap-mongodb-brew.jpg"></p><h4 id="3-最后安装-MongoDB-CE（社区版）"><a href="#3-最后安装-MongoDB-CE（社区版）" class="headerlink" title="3. 最后安装 MongoDB CE（社区版）"></a>3. 最后安装 MongoDB CE（社区版）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mongodb-community@4.2</span><br></pre></td></tr></table></figure><p>  <img src="/images/mg-brew-install-mongodb.jpg" alt="mg-brew-install-mongodb.jpg"></p><p>现在你的 Mac 上就已经安装好 MongoDB 环境了。</p><h2 id="安装mongoose"><a href="#安装mongoose" class="headerlink" title="安装mongoose"></a>安装mongoose</h2><blockquote><p>node.js 是可以直接操作 MongoDB 的，但是通过 MongoDB 命令语法直接编写 MongoDB 验证、数据类型转换和业务逻辑模版比较繁琐。所以我们使用了 mongoose。</p></blockquote><p><a href="https://mongoosejs.com/" target="_blank" rel="noopener">mongoose</a> 是 MongoDB 的一个对象模型工具，它对 MongoDB 的常用方法进行了封装，让 node.js 操作 MongoDB 更加优雅简洁。</p><p>刚才的 node.js 和 MongoDB 都是安装在全局环境，mongoose 则是安装在你的项目下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-project</span><br><span class="line">npm i -S mongoose</span><br></pre></td></tr></table></figure></p><p><img src="/images/mg-install-mongoose.jpg" alt="mg-install-mongoose.jpg"></p><p>现在，你的开发环境就已经全部安装好了。</p><h1 id="二、启动MongoDB服务"><a href="#二、启动MongoDB服务" class="headerlink" title="二、启动MongoDB服务"></a>二、启动MongoDB服务</h1><p>要操作 MongoDB ，首先要启动它。<br>有两种方式启动 MongoDB 服务：</p><h4 id="1-在前台运行"><a href="#1-在前台运行" class="headerlink" title="1. 在前台运行"></a>1. 在前台运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --config /usr/local/etc/mongod.conf</span><br></pre></td></tr></table></figure><p>  前台运行的好处就是，可以查看一些反馈和日志，便于调试。另外如果要关闭服务，只需要在终端按 <code>control + c</code> 键即可。<br>  <img src="/images/mg-run-mongodb-in-foreground.jpg" alt="mg-run-mongodb-in-foreground.jpg"></p><h4 id="2-也可以作为-macOS-服务，在后台运行"><a href="#2-也可以作为-macOS-服务，在后台运行" class="headerlink" title="2. 也可以作为 macOS 服务，在后台运行"></a>2. 也可以作为 macOS 服务，在后台运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start mongodb-community@4.2</span><br></pre></td></tr></table></figure><p>  后台运行的好处是开机就自动启动，随时可以使用。<br>  <img src="images/mg-run-mongodb-as-a-server.jpg" alt="mg-run-mongodb-as-a-server.jpg">这种启动方式，如果要关闭服务，可以通过 <code>stop</code> 命令：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services stop mongodb-community@4.2</span><br></pre></td></tr></table></figure></p><p>  <img src="/images/mg-stop-mongodb-service.jpg" alt="mg-stop-mongodb-service.jpg"></p><p>现在，你的 MongoDB 数据库已经开启了。</p><h1 id="三、操作MongoDB"><a href="#三、操作MongoDB" class="headerlink" title="三、操作MongoDB"></a>三、操作MongoDB</h1><p>操作之前先解释一下MongoDB和mongoose里的一些核心概念。<br><strong>MongoDB</strong></p><ul><li>MongoDB 中的数据记录是一种 <code>BSON</code> 格式的文件（BSON是一种用二进制描述的JSON文件格式）。</li><li>MongoDB 将<code>文件</code>存储在<code>集合</code>中，将<code>集合</code>存储在<code>数据库</code>中。</li><li>MongoDB 的数据库、集合都不用手动创建。</li><li><code>集合collection</code>: 相当于关系型数据库中的<code>表table</code>。</li><li><code>文件document</code>: MongoDB 的数据记录单位，相当于关系型数据库中的<code>记录row</code>。</li></ul><p><strong>mongoose</strong></p><ul><li><code>schema</code>: 在 mongoose 中，所有的东西都来源于一个 <code>schema</code>，每个<code>schema</code> 映射了一个 MongoDB 的<code>集合</code>，它定义了这个<code>集合</code>中的<code>文档</code>的骨架。</li><li><code>model</code>: 一个<code>文件</code>的构造器，通过编译<code>schema</code>得到，一个<code>model</code>的实例就是一个<code>文件</code>，<code>model</code>负责从 MongoDB 数据库中创建和读取<code>文档</code>。</li></ul><p>更多mongoose概念可以在<a href="https://mongoosejs.com/docs/guides.html" target="_blank" rel="noopener">mongoose guide</a>中查阅。</p><p>数据库操作：</p><h2 id="1-使用-mongoose-连接-MongoDB"><a href="#1-使用-mongoose-连接-MongoDB" class="headerlink" title="1. 使用 mongoose 连接 MongoDB"></a>1. 使用 mongoose 连接 MongoDB</h2><p>在项目中创建 <code>connection.js</code> 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// connection.js file</span><br><span class="line">const mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">const conn = mongoose.createConnection(</span><br><span class="line"></span><br><span class="line">  // 连接地址，MongoDB 的服务端口为27017</span><br><span class="line">  // dbtest是我要使用的数据库名，当往其中写数据时，MongoDB 会自动创建一个名为dbtest的数据库，不用事先手动创建。</span><br><span class="line">  &apos;mongodb://127.0.0.1:27017/dbtest&apos;, </span><br><span class="line"></span><br><span class="line">  // 一些兼容配置，必须加，你不写运行的时候会提示你加。</span><br><span class="line">  &#123;</span><br><span class="line">    useNewUrlParser: true,</span><br><span class="line">    useUnifiedTopology: true</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">conn.on(&apos;open&apos;, () =&gt; &#123;</span><br><span class="line">console.log(&apos;打开 mongodb 连接&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">conn.on(&apos;err&apos;, (err) =&gt; &#123;</span><br><span class="line">console.log(&apos;err:&apos; + err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node conection.js</span><br></pre></td></tr></table></figure></p><p><img src="/images/mg-connection.jpg" alt="mg-connection.jpg"></p><p>可以看到打印出“打开 mongodb 连接”，并且运行一直在等待。</p><p>这说明现在已经成功连接上 MongoDB 了，接下来可以开始操作数据库了。</p><p>为了方便扩展起见，我们先对 <code>connection.js</code> 改造一下，让它作为模块导出，这样就可以在其他地方导入复用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// connection.js file</span><br><span class="line">const mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">const conn = mongoose.createConnection(</span><br><span class="line">  &apos;mongodb://127.0.0.1:27017/dbtest&apos;,</span><br><span class="line">  &#123;</span><br><span class="line">    useNewUrlParser: true,</span><br><span class="line">    useUnifiedTopology: true</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">conn.on(&apos;open&apos;, () =&gt; &#123;</span><br><span class="line">console.log(&apos;打开 mongodb 连接&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">conn.on(&apos;err&apos;, (err) =&gt; &#123;</span><br><span class="line">console.log(&apos;err:&apos; + err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = conn; //commonJs 语法，导出conn模块。</span><br></pre></td></tr></table></figure></p><h2 id="2-添加操作"><a href="#2-添加操作" class="headerlink" title="2. 添加操作"></a>2. 添加操作</h2><blockquote><p><code>save | create</code> 方法<br>新建<code>insert.js</code>文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// insert.js file</span><br><span class="line">let mongoose = require(&apos;mongoose&apos;);</span><br><span class="line"></span><br><span class="line">// 导入连接模块</span><br><span class="line">let connection = require(&apos;./connection&apos;);</span><br><span class="line"></span><br><span class="line">// 创建schema</span><br><span class="line">let StudentSchema = new mongoose.Schema(&#123;</span><br><span class="line">   name: String,</span><br><span class="line">   age: Number</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 通过connection和schema创建model</span><br><span class="line">let StudentModel = connection.model(&apos;Student&apos;, StudentSchema);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 通过实例化model创建文档</span><br><span class="line">let studentDoc = new StudentModel(&#123;</span><br><span class="line">    name: &apos;zhangsan&apos;,</span><br><span class="line">    age: 20</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 将文档插入到数据库，save方法返回一个Promise对象。</span><br><span class="line">studentDoc.save().then((doc) =&gt; &#123;</span><br><span class="line">    console.log(doc)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node insert.js</span><br></pre></td></tr></table></figure></p><p>为了更直观看到操作数据库的结果，推荐大家安装一个数据库可视化工具：<a href="https://robomongo.org" target="_blank" rel="noopener">Robo3T</a>，下载<a href="https://robomongo.org/download" target="_blank" rel="noopener">mac版</a>安装即可。<br><img src="/images/mg-robo3T-download2.jpg" alt="mg-robo3T-download2.jpg"></p><p>点击 Robo3T 左上角连接我们的数据库后，可以看到 MongoDB 自动帮我们生成了数据库和集合，并且已经插入了一条记录：<br><img src="/images/mg-insert.jpg" alt="mg-insert.jpg"></p><p>或者还可以直接通过Model的create方法直接插入数据，返回的也是一个Promise：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StudentModel.create(&#123;</span><br><span class="line">    name: &apos;lisi&apos;,</span><br><span class="line">    age: 19</span><br><span class="line">&#125;).then((doc) =&gt; &#123;</span><br><span class="line">    console.log(doc)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="3-读取操作"><a href="#3-读取操作" class="headerlink" title="3. 读取操作"></a>3. 读取操作</h2><blockquote><p><code>find</code> 方法<br>为更加合理复用代码，我们先把 StudentSchema 和 StudentModel 抽离出来：</p></blockquote><p>新建<code>StudentSchema.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// StudentSchema.js file</span><br><span class="line">const mongoose = require(&apos;mongoose&apos;);</span><br><span class="line"></span><br><span class="line">let StudentSchema = mongoose.Schema(&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: Number</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = StudentSchema;</span><br></pre></td></tr></table></figure></p><p>新建<code>StudentModel.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// StudentModel.js file</span><br><span class="line">const connection = require(&apos;./connection&apos;);</span><br><span class="line">const StudentSchema = require(&apos;./StudentSchema&apos;);</span><br><span class="line"></span><br><span class="line">let StudentModel = connection.model(&apos;Student&apos;, StudentSchema);</span><br><span class="line"></span><br><span class="line">module.exports = StudentModel;</span><br></pre></td></tr></table></figure></p><p>然后新建<code>query.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// query.js file</span><br><span class="line">const StudentModel = require(&apos;./StudentModel&apos;);</span><br><span class="line"></span><br><span class="line">// 富查询条件，对象格式，键值对，下面为查询 name 为 lisi 的记录</span><br><span class="line">StudentModel.find(&#123;name: &apos;lisi&apos;&#125;).then(doc =&gt; &#123;</span><br><span class="line">    console.log(doc);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node query.js</span><br></pre></td></tr></table></figure></p><p><img src="/images/mg-guery.jpg" alt="mg-guery.jpg"></p><p>可以看到name为“lisi”的记录被打印了出来。</p><p>如果想查询整个集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 不放查询条件即查询所有的记录</span><br><span class="line">StudentModel.find(&#123;&#125;).then(doc =&gt; &#123;</span><br><span class="line">    console.log(doc);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="/images/mg-guery-all.jpg" alt="mg-guery-all.jpg"></p><p>可以看到集合中的所有记录被打印了出来。</p><h2 id="4-更新操作"><a href="#4-更新操作" class="headerlink" title="4. 更新操作"></a>4. 更新操作</h2><blockquote><p><code>update|updateOne|updateMany</code> 方法</p></blockquote><p>新建<code>update.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// update.js file</span><br><span class="line">const StudentModel = require(&apos;./StudentModel&apos;);</span><br><span class="line"></span><br><span class="line">// update 方法接收2个参数，第一个是查询条件，第二个是修改的值</span><br><span class="line">// 下面把name为lisi的记录，将他的age修改为80</span><br><span class="line">StudentModel.update(&#123;name: &apos;lisi&apos;&#125;, &#123;age: 80&#125;).then(result =&gt; &#123;</span><br><span class="line">    console.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>进入 Robo3T，可以看到数据被更改（切换到表格模式更加直观）：<br><img src="/images/mg-update2.jpg" alt="mg-update2.jpg"></p><p>不过在终端，提示<code>DeprecationWarning: collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.</code><br><img src="/images/mg-update.jpg" alt="mg-update.jpg"></p><p>意思是建议我们使用 <code>updateOne</code>、<code>updateMany</code>或者<code>bulkWrite</code></p><p>update 更新查询到的所有结果，方法已经不提倡使用，已被updateMany替代。<br>updateOne 如果查询到多条结果，只更新第一条记录。<br>upateMany 更新查询到的所有结果。<br>bulkWrite 提供可控执行顺序的批量写操作。</p><p>为了代码的健壮性，我们应该根据建议将update方法换成updateMany方法。</p><p>另外，终端的输出<code>{ n: 1, nModified: 1, ok: 1 }</code>的意思是：</p><ul><li>“n: 1”：查询到1条记录。</li><li>“nModified: 1”：需要修改1条记录。（如果修改值和原始值相同，则需要修改的就是0条）</li><li>“ok: 1”：修改成功1条。</li></ul><h2 id="5-删除操作"><a href="#5-删除操作" class="headerlink" title="5. 删除操作"></a>5. 删除操作</h2><blockquote><p><code>remove|removeOne|removeMany|bulkWrite</code> 方法</p></blockquote><p>新建<code>remote.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// remove.js file</span><br><span class="line">const StudentModel = require(&apos;./StudentModel&apos;);</span><br><span class="line"></span><br><span class="line">// delete 方法接收1个参数，就是查询条件</span><br><span class="line">// 下面把name为lisi的记录删除</span><br><span class="line">StudentModel.remove(&#123;name:&apos;lisi&apos;&#125;).then((result) =&gt; &#123;</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>进入 Robo3T，可以看到集合里已经没有name为lisi的记录了：<br><img src="/images/mg-remove2.jpg" alt="mg-remove2.jpg"></p><p>在看终端的输出，跟update类似，也提示建议使用新的方法代替。<br><img src="/images/mg-remove.jpg" alt="mg-remove.jpg"></p><p>意思是建议我们使用 <code>removeOne</code>、<code>removeMany</code>或者<code>bulkWrite</code></p><p>remove 删除查询到所有结果，方法已经不提倡使用，已被removeMany替代。<br>removeOne 如果查询到多条结果，只删除第一条记录。<br>removeMany 删除查询到所有结果。<br>bulkWrite 提供可控执行顺序的批量写操作。</p><p>另外，终端的输出<code>{ n: 1, ok: 1, deletedCount: 1 }</code>的意思跟update的类似，就不累述了。</p><p>现在我们已经成功地对 MongoDB 数据库进行了 CRUD（添加、读取、更新、删除）操作。欢呼～</p><p>更多高级操作，可以到<a href="https://mongoosejs.com/docs/api/" target="_blank" rel="noopener">mongoose API 文档</a>中查阅。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>梳理一下，主要讲了这些内容：</p><ol><li><code>node.js+MongoDB+mongoose</code> 在Mac下的环境搭建，注意使用最新的 <code>MongoDB</code> 的安装方式。</li><li>在Mac下如何启动和关闭 <code>MongoDB</code> 服务。</li><li>介绍了 <code>MongoDB</code> 和 <code>mongoose</code> 的基本核心概念。</li><li>使用 mongoose 连接以及增删改查 MongoDB 操作。可以使用 <code>Robo3T</code> 来更直观地观察数据库。</li></ol><p>前端也能玩转数据库开发。<br>欢迎交流～</p><blockquote><p>文章源码地址：<a href="https://github.com/yc111/mongodb-demo" target="_blank" rel="noopener">https://github.com/yc111/mongodb-demo</a></p></blockquote><p>相关网站：<br><a href="https://brew.sh/#install" target="_blank" rel="noopener">Homebrew官网</a><br><a href="https://docs.mongodb.com" target="_blank" rel="noopener">MongoDB官网</a><br><a href="https://mongoosejs.com" target="_blank" rel="noopener">monggose官网</a><br><a href="https://robomongo.org" target="_blank" rel="noopener">Robo3T官网</a><br><a href="http://www.zmtests.com/information/20190904165326" target="_blank" rel="noopener">macOS 包管理器 Homebrew 移除 MongoDB</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> node </tag>
            
            <tag> MongoDB </tag>
            
            <tag> mongoose </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github项目徽标</title>
      <link href="/2019/10/05/github%E9%A1%B9%E7%9B%AE%E5%BE%BD%E6%A0%87/"/>
      <url>/2019/10/05/github%E9%A1%B9%E7%9B%AE%E5%BE%BD%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>GitHub徽标，GitHub Badge，你也可以叫它徽章。就是在项目README中经常看到的那些表明构建状态或者版本等信息的小图标。就像这样：<img src="/images/github-badge.jpg" alt="github-badge.jpg">这些好看的小图标不仅简洁美观，而且包含了清晰易读的信息，在README中使用小徽标能够为自己的项目说明增色不少！如何给自己的项目加上小徽标呢？</p></blockquote><a id="more"></a><h2 id="一、关于徽标"><a href="#一、关于徽标" class="headerlink" title="一、关于徽标"></a>一、关于徽标</h2><ol><li>徽标图片分左右两部分，左边是标题，右边是内容，就像是键值对。</li><li>GitHub徽标官网是 <a href="https://shields.io/" target="_blank" rel="noopener">https://shields.io/</a></li><li>图标规范<br><img src="/images/badge-rule.png" alt="badge-rule.png"></li></ol><h2 id="二、如何添加动态徽标"><a href="#二、如何添加动态徽标" class="headerlink" title="二、如何添加动态徽标"></a>二、如何添加动态徽标</h2><p>动态徽标是指如果项目状态发生变化，会自动更新状态的徽标，它能保证用户看到的信息就是项目当前的真实状态。</p><p>常用的动态徽标有：</p><ul><li>持续集成状态</li><li>项目版本信息</li><li>代码测试覆盖率</li><li>项目下载量</li><li>贡献者统计等等</li></ul><p>这里以<code>Travis CI</code> 的持续集成状态为例。没有接触过 <code>Travis CI</code>的可以看我的上一篇文章 <a href="https://champyin.com/2019/09/27/%E5%88%A9%E7%94%A8Travis-CI-GitHub%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/">利用Travis CI+GitHub实现持续集成和自动部署</a></p><ol><li><p>登录 <code>Travis CI</code>，进入配置过构建的项目，在项目名称的右边有个 <code>build passing</code> 或者 <code>build failing</code> 徽标。</p></li><li><p>点击它，在弹出框中，就可以看到 <code>Travis CI</code> 为你提供的各种格式的徽章地址了。</p></li><li><p>你可以根据需要选择格式，imageUrl格式大概是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.travis-ci.org/&#123;your-name&#125;/&#123;your-repo-name&#125;.svg?branch=master</span><br></pre></td></tr></table></figure><p>markdown格式大概是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![Build Status](https://www.travis-ci.org/&#123;your-name&#125;/&#123;your-repo-name&#125;.svg?branch=master)](https://www.travis-ci.org/&#123;your-name&#125;/&#123;your-repo-name&#125;)</span><br></pre></td></tr></table></figure></li><li><p>简单起见，我选择 <code>markdown</code> 格式。将内容复制后，打开项目的README文档，在顶部位置粘贴。</p></li><li><p>经过前4步，小徽章就搞定了。将README文档push到远程，刷新GitHub页面，过一会，就会看到README上面已经有了持续集成状态图标了。之所以要过一会才加载出来，是因为它要动态从 <code>Travis CI</code> 平台获取状态。<img src="/images/build-passing.png" alt="build-passing.png"> </p></li></ol><h2 id="三、如何自定义徽标"><a href="#三、如何自定义徽标" class="headerlink" title="三、如何自定义徽标"></a>三、如何自定义徽标</h2><p><a href="https://shields.io/" target="_blank" rel="noopener">shields.io</a> 提供了自定义徽标的功能。</p><h4 id="徽标图标格式"><a href="#徽标图标格式" class="headerlink" title="徽标图标格式"></a>徽标图标格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://img.shields.io/badge/&#123;徽标标题&#125;-&#123;徽标内容&#125;-&#123;徽标颜色&#125;.svg</span><br></pre></td></tr></table></figure><h4 id="带链接的徽标"><a href="#带链接的徽标" class="headerlink" title="带链接的徽标"></a>带链接的徽标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![](https://img.shields.io/badge/&#123;徽标标题&#125;-&#123;徽标内容&#125;-&#123;徽标颜色&#125;.svg)](&#123;linkUrl&#125;)</span><br></pre></td></tr></table></figure><h4 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h4><ul><li>徽标标题：徽标左边的文字</li><li>徽标内容：徽标右边的文字</li><li>徽标颜色：徽标右边的背景颜色，可以是颜色的16进制值，也可以是颜色英文。支持的颜色英文如下：<br><img src="/images/shields.io-color.jpg" alt="shields.io-color.jpg"></li></ul><p>变量之间用 <code>-</code> 连接。将这3个变量替换为你需要的内容即可生成一个自定义的徽标。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>例如下面这个是我的博客的徽标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![](https://img.shields.io/badge/blog-@champyin-red.svg)](https://champyin.com)</span><br></pre></td></tr></table></figure></p><p>效果：<br><a href="https://champyin.com"><img src="https://img.shields.io/badge/blog-@champyin-red.svg" alt=""></a><br>点击该徽标会打开对应的url地址，即直接跳到我的博客。</p><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>除了上面所说的3个参数，<a href="https://shields.io/" target="_blank" rel="noopener">shields.io</a> 还提供了一些 <code>query string</code> 来控制徽标样式。使用方式跟浏览器 URL 的 query string 一致：徽标图标地址?{参数名}={参数值}，多个参数用 <code>&amp;</code> 连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://img.shields.io/badge/&#123;徽标标题&#125;-&#123;徽标内容&#125;-&#123;徽标颜色&#125;.svg?&#123;参数名1&#125;=&#123;参数值1&#125;&amp;&#123;参数名2&#125;=&#123;参数值2&#125;</span><br></pre></td></tr></table></figure></p><p>常用的 <code>query string</code> 参数有：</p><ul><li>style：控制徽标主题样式，style的值可以是：  <code>plastic</code> | <code>flat</code> | <code>flat-square</code> | <code>social</code> 。</li><li>label：用来强制覆盖原有徽标的标题文字。</li><li>colorA：控制左半部分背景颜色，只能用16进制颜色值作为参数，不能使用颜色英文。</li><li>colorB：控制右半部分背景颜色。</li></ul><p>以style参数为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/badge/blog-@champyin-orange.svg?style=plastic)</span><br></pre></td></tr></table></figure></p><p><code>plastic</code> 立体效果：<br><img src="https://img.shields.io/badge/blog-@champyin-orange.svg?style=plastic" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/badge/blog-@champyin-yellow.svg?style=flat)</span><br></pre></td></tr></table></figure><p><code>flat</code> 扁平化效果，也是默认效果：<br><img src="https://img.shields.io/badge/blog-@champyin-yellow.svg?style=flat" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/badge/blog-@champyin-success.svg?style=flat-square)</span><br></pre></td></tr></table></figure><p><code>flat-square</code> 扁平 + 去圆角效果：<br><img src="https://img.shields.io/badge/blog-@champyin-success.svg?style=flat-square" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/badge/blog-@champyin-blue.svg?style=social)</span><br></pre></td></tr></table></figure><p><code>social</code> 社交样式效果：<br><img src="https://img.shields.io/badge/blog-@champyin-blue.svg?style=social" alt=""></p><p>还有很多参数，用法类似。更多信息可以到<a href="https://shields.io/" target="_blank" rel="noopener">shields.io</a>查阅。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>徽标简洁又不失内容，使用简单又不失灵活。如果你的项目还没有使用过徽标，那么不妨试试给你的项目中试试添加一个，你会爱上它。</p><blockquote><p>建议：徽标的使用也是门艺术，徽标不是越多越好。应该根据项目性质合理添加，放的太多会失去徽标的简洁本意。</p></blockquote><p>–<br>GOOD LUCK！</p><p>欢迎转载，转载请注明出处：<br><a href="https://champyin.com/2019/10/05/github%E9%A1%B9%E7%9B%AE%E5%BE%BD%E6%A0%87/">https://champyin.com/2019/10/05/github%E9%A1%B9%E7%9B%AE%E5%BE%BD%E6%A0%87/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> badge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Travis CI+GitHub实现持续集成和自动部署</title>
      <link href="/2019/09/27/%E5%88%A9%E7%94%A8Travis-CI-GitHub%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/09/27/%E5%88%A9%E7%94%A8Travis-CI-GitHub%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/github+travis-cover.png" alt="github+travis-cover.png"></p><blockquote><p>这次的主题是如何利用Travis CI+GitHub实现持续集成和自动部署，通过我的一些研究和实战经验，希望可以帮到有需要的朋友。</p></blockquote><a id="more"></a><p>如果你手动部署过项目，一定会深感持续集成的必要性，因为手动部署实在又繁琐又耗时又没技术含量，九段部署流程基本固定，依然容易出错。</p><p>如果你很熟悉持续集成，一定会同意这样的观点：“使用它已经成为一种标配”。</p><blockquote><p>什么是持续集成<br>Continuous Integration(CI) is a development practice that requires developers to integrate code into a shared repository several times a day. Each check-in is then verified by an automated build, allowing teams to detect problems early.<br>———ThoughtWorks<br>翻译过来就是：持续集成是一个开发行为，它要求开发者每天多次将代码集成到一个共享的仓库，每次提交都会被自动构建所检查，团队可因此提前检测出问题。</p></blockquote><p>持续集成的工具非常多，例如用java语言开发的Jenkins，由于其可以在多台机器上进行分布式地构建和负载测试的特性，很多大公司都在使用它。</p><p>但是Jenkins的不加修饰的界面界面让我有些嫌弃… </p><p>随着GitHub的发展，出现了越来越多支持GitHub的CI/CD产品。在GitHub市场上，可以看到，已经支持的持续集成服务提供商已超过300多家。<a href="https://github.com/marketplace/category/continuous-integration" target="_blank" rel="noopener">详情</a>。<br>选择Travis CI，是因为身边很多朋友的推荐。<br><img src="/images/github-continuous-integration.jpg" alt="github continuous integration.jpg"></p><h2 id="什么是Travis-CI"><a href="#什么是Travis-CI" class="headerlink" title="什么是Travis CI"></a>什么是Travis CI</h2><p>Travis CI是用Ruby语言开发的一个开源的分布式持续集成服务，用于自动构建和测试在GitHub托管的项目。支持包括Javascript、Node.js、Ruby等20多种程序语言。对于开源项目免费提供CI服务。你也可以买他的收费版，享受更多的服务。</p><blockquote><p>Travis CI目前有两个官网，分别是 <a href="https://travis-ci.org" target="_blank" rel="noopener">https://travis-ci.org</a> 和 <a href="https://travis-ci.com" target="_blank" rel="noopener">https://travis-ci.com</a> 。<br><a href="https://travis-ci.org" target="_blank" rel="noopener">https://travis-ci.org</a> 是旧平台，已经逐渐往新平台 <a href="https://travis-ci.com" target="_blank" rel="noopener">https://travis-ci.com</a> 上迁移了。对于私有仓库的免费自动构建，Travis CI在新平台上给予了支持。</p></blockquote><p>GitHub-&gt;Marketplace-&gt;Apps-&gt;Travis CI<br><img src="/images/travis-CI-0.jpg" alt="travis-CI-0.jpg"></p><h2 id="一、获取GitHub-Access-Token"><a href="#一、获取GitHub-Access-Token" class="headerlink" title="一、获取GitHub Access Token"></a>一、获取GitHub Access Token</h2><p>Travis CI在自动部署的时候，需要push内容到仓库的某个分支，而访问GitHub仓库需要用户授权，授权方式就是用户提供 Access Token 给Travis CI。<br>获取token的位置：GitHub-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens。<br>勾选<code>repo</code>下的所有项，以及<code>user</code>下的<code>user:email</code>后，生成一个token，复制token值。</p><blockquote><p>注意：这个token只有现在可以看到，再次进入就看不到了，而且是再也看不到了，忘记了就只能重新生成了，所以要记住保管好。</p></blockquote><p><img src="/images/personal-access-token-variable.jpg" alt="personal-access-token-variable.jpg"></p><h2 id="二、使用GitHub账号登录Travis"><a href="#二、使用GitHub账号登录Travis" class="headerlink" title="二、使用GitHub账号登录Travis"></a>二、使用GitHub账号登录Travis</h2><p>进入<a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis官网</a>，用GitHub账号登录。（我目前使用的是它的旧平台）<br><img src="/images/travis-CI-1.jpg" alt="travis-ci-1.jpg"></p><p>登录后，会在Travis里看到自己GitHub账号下所有的public open source repo。</p><h2 id="三、开启对项目的监控"><a href="#三、开启对项目的监控" class="headerlink" title="三、开启对项目的监控"></a>三、开启对项目的监控</h2><p>选择目标项目，打开右侧开关。<br><img src="/images/travis-CI-4.jpg" alt="travis-CI-4.jpg"></p><h2 id="四、配置travis"><a href="#四、配置travis" class="headerlink" title="四、配置travis"></a>四、配置travis</h2><ul><li>点击开关右侧Settings，进入该项目的travis配置页</li><li>勾选触发条件<br><img src="/images/travis-CI-7.jpg" alt="travis-CI-7.jpg"></li><li>设置全局变量<br><img src="/images/travis-CI-8.jpg" alt="travis-CI-8.jpg"></li><li>第一步获取的access token，必须设置<br>设置好的变量可以在配置文件中以 ${变量名}来引用。<br><img src="/images/travis-CI-9.jpg" alt="travis-CI-9.jpg"></li></ul><h2 id="五、在项目根目录添加-travis-yml配置文件"><a href="#五、在项目根目录添加-travis-yml配置文件" class="headerlink" title="五、在项目根目录添加.travis.yml配置文件"></a>五、在项目根目录添加<code>.travis.yml</code>配置文件</h2><blockquote><p>注意文件名以<code>.</code>开头。</p></blockquote><p>Travis CI的一次构建分两个步骤：</p><ol><li>install安装，安装任何所需的依赖</li><li>script脚本，运行构建脚本</li></ol><p><strong>Travis CI提供了一些构建生命周期的“钩子”</strong> </p><p>完整的 Travis CI 构建生命周期：</p><ol><li>OPTIONAL Install <code>apt addons</code></li><li>OPTIONAL Install <code>cache components</code></li><li><code>before_install</code></li><li><code>install</code></li><li><code>before_script</code></li><li><code>script</code></li><li>OPTIONAL <code>before_cache</code>(for cleaning up cache)</li><li><code>after_success</code> or <code>after_failure</code></li><li>OPTIONAL <code>before_deploy</code></li><li>OPTIONAL <code>deploy</code></li><li>OPTIONAL <code>after_deploy</code></li><li><code>after_script</code></li></ol><p>在 <code>before_install</code>、<code>before_script</code>之前，或者<code>after_script</code>之后，都可以运行自定义命令，详细资料可参考官方文档：<a href="https://docs.travis-ci.com/user/job-lifecycle/" target="_blank" rel="noopener">Job Lifecycle</a></p><p>我在<code>footprint</code>项目中的<code>.travis.yml</code>完整配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">language: node_js #设置语言</span><br><span class="line"></span><br><span class="line">node_js: &quot;10.16.3&quot; #设置语言版本</span><br><span class="line"></span><br><span class="line">cache:</span><br><span class="line">  directories:</span><br><span class="line">    - node_modules #缓存依赖</span><br><span class="line"></span><br><span class="line"># S: Build Lifecycle</span><br><span class="line">install:</span><br><span class="line">  - npm i</span><br><span class="line"></span><br><span class="line">script:</span><br><span class="line">  - npm run build</span><br><span class="line"></span><br><span class="line">after_script前5句是把部署分支的.git文件夹保护起来，用于保留历史部署的commit日志，否则部署分支永远只有一条commit记录。</span><br><span class="line">#命令里面的变量都是在Travis CI里配置过的。</span><br><span class="line">after_script:</span><br><span class="line">  - git clone https://$&#123;GH_REF&#125; .temp</span><br><span class="line">  - cd .temp</span><br><span class="line">  - git checkout gh-pages</span><br><span class="line">  - cd ../</span><br><span class="line">  - mv .temp/.git dist</span><br><span class="line">  - cd dist</span><br><span class="line">  - git config user.name &quot;$&#123;U_NAME&#125;&quot;</span><br><span class="line">  - git config user.email &quot;$&#123;U_EMAIL&#125;&quot;</span><br><span class="line">  - git add .</span><br><span class="line">  - git commit -m &quot;:construction_worker:- Build &amp; Deploy by Travis CI&quot;</span><br><span class="line">  - git push --force --quiet &quot;https://$&#123;Travis_Token&#125;@$&#123;GH_REF&#125;&quot; gh-pages:$&#123;D_BRANCH&#125;</span><br><span class="line"># E: Build LifeCycle</span><br><span class="line"></span><br><span class="line"># 只有指定的分支提交时才会运行脚本</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br></pre></td></tr></table></figure></p><h2 id="Done！"><a href="#Done！" class="headerlink" title="Done！"></a>Done！</h2><p>将 <code>.travis.yml</code> push 到远程，可以看到 travis 开始构建编译了。并且之后每次push代码，travis 都会自动执行<code>.travis.yml</code>里配置的脚本任务了。</p><ul><li>自动编译：<br><img src="/images/travis-CI-6.jpg" alt="travis-CI-10.jpg"></li><li>构建完，travis 会根据我的配置，自动部署到 GitHub：<br><img src="/images/travis-CI-10.jpg" alt="travis-CI-6.jpg"></li></ul><h2 id="And-One-More-Thing"><a href="#And-One-More-Thing" class="headerlink" title="And One More Thing"></a>And One More Thing</h2><p>构建成功后，我们就可以在自己的GitHub项目里添加<code>build</code>徽章了。<br>方法：在Travis里，点击项目右侧的徽章，即可获取小徽章地址，将地址放在README.md文档中即可。<br><img src="/images/travis-CI-12.jpg" alt="travis-CI-12.jpg"><br>效果：<br><img src="/images/travis-CI-11.jpg" alt="travis-CI-11.jpg"></p><p>–<br>GOOD LUCK！</p><p>欢迎转载，转载请注明出处：<br><a href="https://champyin.com/2019/09/27/%E5%88%A9%E7%94%A8Travis-CI-GitHub%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/#more">https://champyin.com/2019/09/27/%E5%88%A9%E7%94%A8Travis-CI-GitHub%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/#more</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> travis </tag>
            
            <tag> CI/CD </tag>
            
            <tag> yml </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用echarts展示旅行足迹</title>
      <link href="/2019/09/27/%E5%88%A9%E7%94%A8echarts%E5%B1%95%E7%A4%BA%E6%97%85%E8%A1%8C%E8%B6%B3%E8%BF%B9/"/>
      <url>/2019/09/27/%E5%88%A9%E7%94%A8echarts%E5%B1%95%E7%A4%BA%E6%97%85%E8%A1%8C%E8%B6%B3%E8%BF%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直有个环游世界的梦，周游列国，体验不同国家的人类文明，寻山访水，体验造物主大自然的伟大造化。毕竟人生不止眼前的苟且，还有诗和远方。这么多年以来，陆续走过了一些地方，每到一个地方，都让我离梦想又近了一些。虽然我知道这比起环游世界来说，还差不知道多少个山头，但是我一直在往这个梦努力，靠近。希望终有一天，我可以笑着对自己说，你做到了！</p><p>6年前，因为工作的原因，我接触过地图应用的开发，从那时起，我对地图的热爱就埋在了心底。今年年中我带爸妈旅了旅游，去了一些我没去过的地方，我好想有个地图可以让我点亮一下，记录一下我到过的新的“领土”。搜了下市面上已经存在的地图应用，都不是我想要的，唯一比较符合我的需求的是百度旅游里面的一个小功能，叫做足迹地图，但是似乎早就停止了维护，数据停留在2016年。。。</p><p>找不到趁手的工具，那就自己打造一把。是啊，为什么不自己开发一个呢？说干就干。</p></blockquote><a id="more"></a><h2 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h2><p>首先用 <code>cyt-cli</code> 快速搭建项目框架。<a href="https://www.npmjs.com/package/cyt-cli" target="_blank" rel="noopener">cyt-cli地址</a></p><blockquote><p><code>cyt-cli</code> 是一款可以快速创建前端工程的脚手架，具有比较完善的webpack4配置，目前支持纯js、vue、react等语言版本。<br>如果没有安装 <code>cyt-cli</code> ，先全局安装一下：<code>npm i -g cyt-cli</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cyt-cli create footprint</span><br><span class="line">✔ fetching template ...</span><br><span class="line">? please choose a template to create roject (Use arrow keys)</span><br><span class="line">❯ swan-template </span><br><span class="line">  swan-vue-template </span><br><span class="line">  swan-react-template</span><br></pre></td></tr></table></figure><p>因为想快速做出雏形来，所以使用最简单的模版就行，选择第一个 <code>swan-template</code>。<br>等待一会，工程就搭建好了。<br>生成的工程目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">|--build/ # webpack配置文件</span><br><span class="line">|    |-- webpack.base.js</span><br><span class="line">|    |-- webpack.dev.js</span><br><span class="line">|    |-- webpack.prod.js</span><br><span class="line">|--public/ # 首页模版</span><br><span class="line">|    |-- index.html</span><br><span class="line">|--src/</span><br><span class="line">|    |-- assets/ # 静态资源，比如中国地图数据</span><br><span class="line">|    |-- components/ # 项目组件</span><br><span class="line">|    |       |--  foo.js</span><br><span class="line">|    |       |--  bar.js</span><br><span class="line">|    |-- icon/ # 字体图标</span><br><span class="line">|    |-- images/ # 图片资源</span><br><span class="line">|    |-- theme/ # 样式文件</span><br><span class="line">|    |-- index.js # 项目入口</span><br><span class="line">|--.babel.js # babel配置</span><br><span class="line">|--.browserslistrc.json # 浏览器支持规则</span><br><span class="line">|--.gitignore </span><br><span class="line">|--package.json</span><br><span class="line">|--postcss.config.js # postcss插件配置</span><br><span class="line">|--README.md</span><br></pre></td></tr></table></figure></p><p>安装一下依赖包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd footprint</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure></p><h2 id="地图选型"><a href="#地图选型" class="headerlink" title="地图选型"></a>地图选型</h2><p>地图展示我选择了 <code>echarts</code>。 <a href="https://echarts.apache.org" target="_blank" rel="noopener">echarts官网</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save echarts</span><br></pre></td></tr></table></figure></p><h2 id="应用开发"><a href="#应用开发" class="headerlink" title="应用开发"></a>应用开发</h2><p>我的核心需求很简单，就是可以把我去过的国家、省、市在地图上展示出来即可。<br>先实现国内的省，开发逻辑很简单：</p><h3 id="1-引入echarts"><a href="#1-引入echarts" class="headerlink" title="1.引入echarts"></a>1.引入<code>echarts</code></h3><p>按需引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import echarts from &apos;echarts/lib/echarts&apos;;</span><br><span class="line">import &apos;echarts/lib/chart/map&apos;;</span><br><span class="line">import &apos;echarts/lib/component/tooltip&apos;;</span><br><span class="line">import &apos;echarts/lib/component/title&apos;;</span><br><span class="line">import &apos;echarts/lib/component/visualMap&apos;;</span><br><span class="line">import &apos;echarts/lib/component/legend&apos;;</span><br><span class="line">import &apos;echarts/lib/component/toolbox&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="2-处理用户数据"><a href="#2-处理用户数据" class="headerlink" title="2.处理用户数据"></a>2.处理用户数据</h3><p>给<code>series</code>的<code>data</code>用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">let handleData = function(rawdata) &#123;</span><br><span class="line">    rowData.forEach(item =&gt; &#123;</span><br><span class="line">        item.value = FREQUENCY[item.value]</span><br><span class="line">        if (item.value !== NEVER) &#123;</span><br><span class="line">            item.label = &#123; show: true, color: LEBEL_COLOR &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (item.value === NEVER) &#123;</span><br><span class="line">            never.push(item);</span><br><span class="line">        &#125; else if (item.value === ONECE) &#123;</span><br><span class="line">            onece.push(item);</span><br><span class="line">        &#125; else if (item.value === AFEWTIMES) &#123;</span><br><span class="line">            afewtimes.push(item);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            usually.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    series = [usually, afewtimes, onece, never].map((item, index) =&gt; &#123;</span><br><span class="line">        let temp = &#123;</span><br><span class="line">            type: &apos;map&apos;,</span><br><span class="line">            map: mapType,</span><br><span class="line">            roam: true,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">                emphasis: &#123; label: &#123; show: true &#125; &#125;,</span><br><span class="line">                areaColor: &apos;#fff&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        temp.name = legendData[index];</span><br><span class="line">        temp.data = item;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleData(userData);</span><br></pre></td></tr></table></figure></p><h3 id="3-注册map"><a href="#3-注册map" class="headerlink" title="3.注册map"></a>3.注册<code>map</code></h3><p>echarts有个registerMap方法，echarts.registerMap(mapName, geoJson, specialAreas).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- mapName：地图名称，一定要与option-&gt;series-&gt;map对应的值相同。</span><br><span class="line">- geoJson：GeoJson格式的数据，具体格式见 http://geojson.org/。</span><br><span class="line">- specialAreas：可选。将地图中的部分区域缩放到合适的位置，可以使得整个地图的显示更加好看。</span><br></pre></td></tr></table></figure></p><p>geoJson是地理信息数据，一般都很大，当然通过异步获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">util.get(&apos;assets/china.json&apos;).then(data =&gt; &#123;</span><br><span class="line">    let chinaJson = data;</span><br><span class="line">    myChart.hideLoading();</span><br><span class="line">    // 注册地图</span><br><span class="line">    echarts.registerMap(mapName, chinaJson, &#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>ECharts3提供的矢量地图数据，在4版本后已经不提供下载服务了。官网的解释是“由于部分数据不符合国家《测绘法》规定”。不过，只要不商用，这些矢量数据还是可以使用的。有需要可以到我这里获取<a href="https://github.com/yc111/echarts3-geojson" target="_blank" rel="noopener">https://github.com/yc111/echarts3-geojson</a></p></blockquote><h3 id="4-配置option显示地图"><a href="#4-配置option显示地图" class="headerlink" title="4.配置option显示地图"></a>4.配置option显示地图</h3><p>注册地图后进行其他配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 指定图表的配置项和数据</span><br><span class="line">let option = &#123;</span><br><span class="line">    color: _color,</span><br><span class="line">    title: _title,</span><br><span class="line">    tooltip: _tooltip,</span><br><span class="line">    legend: _legend,</span><br><span class="line">    visualMap: _visualMap,</span><br><span class="line">    toolbox: _toolbox,</span><br><span class="line">    series: series</span><br><span class="line">&#125;;</span><br><span class="line">// 使用刚指定的配置项和数据显示图表</span><br><span class="line">myChart.setOption(option);</span><br></pre></td></tr></table></figure></p><h2 id="添加Travis-CI持续集成"><a href="#添加Travis-CI持续集成" class="headerlink" title="添加Travis CI持续集成"></a>添加Travis CI持续集成</h2><p>花了大概一天时间，雏形做好（感觉很大一部分时间在调地图颜色…）。我把项目部署在了github page上，但是每次build之后，都要手动部署，太麻烦。</p><p>于是我用 Travis CI 给项目做了持续集成，现在只要代码一提交，就会自动部署了。</p><p>具体关于Travis的详细配置，可以参考我的另一篇文章：<a href="https://champyin.com/2019/09/27/%E5%88%A9%E7%94%A8Travis-CI-GitHub%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/">利用Travis CI+GitHub实现持续集成和自动部署</a></p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p>项目预览地址：<a href="http://champyin.com/footprint/">http://champyin.com/footprint/</a><br><img src="/images/footprint.jpg" alt="footprint.jpg"><br>暂时还比较简陋，并且只支持省。以后我会把世界地图，和城市地图都加进来（毕竟也是出过境的人，哈哈），实现地图下钻，并且优化用户数据设置，不断完善下去。</p><p>项目源码地址：<a href="https://github.com/yc111/footprint" target="_blank" rel="noopener">https://github.com/yc111/footprint</a><br>欢迎star。如果你喜欢，可以fork本项目，然后打造属于你自己的足迹应用。</p><p>–<br>欢迎转载，转载请注明出处：<br><a href="https://champyin.com/2019/09/27/%E5%88%A9%E7%94%A8echarts%E5%B1%95%E7%A4%BA%E6%97%85%E8%A1%8C%E8%B6%B3%E8%BF%B9/">https://champyin.com/2019/09/27/%E5%88%A9%E7%94%A8echarts%E5%B1%95%E7%A4%BA%E6%97%85%E8%A1%8C%E8%B6%B3%E8%BF%B9/</a></p><p>本文同步发表于：<br><a href="https://juejin.im/post/5d955f716fb9a04ded311224" target="_blank" rel="noopener">利用echarts展示旅行足迹 | 掘金</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> echarts </tag>
            
            <tag> map </tag>
            
            <tag> footprint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode 常用快捷键</title>
      <link href="/2019/09/21/vscode-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/09/21/vscode-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>基于当前项目路径打开外部终端(MAC中)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift + command + c</span><br></pre></td></tr></table></figure></p><p>查看vscode快捷键的方法：</p><ol><li>在vscode中<code>shift+command+p</code>打开vscode命令行，输入<code>keyboard</code>搜索：<br><img src="/images/vscode-keyboard.jpg" alt="vscode-keyboard.jpg"></li></ol><ol><li>在结果中点击 <code>Preferences: Open Keyboard Shortcuts</code>：<br><img src="/images/vscode-keyboard-shortcuts.jpg" alt="vscode-keyboard-shortcuts.jpg"></li></ol><ol><li>可以搜索指定的关键字搜索，例如输入<code>terminal</code>搜索：<br><img src="/images/vscode-keyboard-shortcuts-teminal.jpg" alt="vscode-keyboard-shortcuts-teminal.jpg"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode中如何使编辑器根据屏幕宽度自动换行</title>
      <link href="/2019/09/20/vscode%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%BC%96%E8%BE%91%E5%99%A8%E6%A0%B9%E6%8D%AE%E5%B1%8F%E5%B9%95%E5%AE%BD%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/"/>
      <url>/2019/09/20/vscode%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%BC%96%E8%BE%91%E5%99%A8%E6%A0%B9%E6%8D%AE%E5%B1%8F%E5%B9%95%E5%AE%BD%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>vscode中默认是不会自动换行的，也就是说当你查看一个压缩后的代码后，只会显示一行。。。很难看出内容的多少也不利于查找定位内容。</p></blockquote><a id="more"></a><p>在vscode中可以设置是否自动换行，进入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code -&gt; Preference -&gt; Settings</span><br></pre></td></tr></table></figure></p><p>然后在配置界面，搜索 <code>word-wrap</code>，找到 <code>Editor: Word Wrap</code> 选项：<br><img src="/images/vscode-set-work-wrap1.jpg" alt=""></p><p>将<code>off</code>改成<code>on</code>即可。<br><img src="/images/vscode-set-work-wrap2.jpg" alt=""></p><p>–<br>GoodLuck!</p>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何配置多个ssh key</title>
      <link href="/2019/08/29/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key/"/>
      <url>/2019/08/29/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们都知道在使用git管理代码时，要推送代码到远程仓库时，为了不想每次都输入账号密码，会配置一下ssh key。但是如果你有多个github账号，或者同时还有gitlab或者是gitee账号，我在推送到这三个账号的仓库都不想输入用户名密码，可不可以把github上使用的ssh key跟其他的账号共享呢？我没有这样试过，不过即便是可以，也不太安全吧。最好的做法就是为这些账号分别创建ssh key，分别配置。</p><p>配置单个SSH key，可以参考：<a href="https://champyin.com/2018/04/07/配置git环境之设置SSH-key/">配置git环境之设置SSH key</a>。<br>而配置多个SSH key未必都熟悉。其实方法也很简单：</p></blockquote><a id="more"></a><h4 id="1-生成ssh-key"><a href="#1-生成ssh-key" class="headerlink" title="1. 生成ssh key"></a>1. 生成ssh key</h4><p>第一个，给github用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &apos;xxx@abc.com&apos; -f ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure></p><p>第二个，给gitee用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &apos;xxx@edf.com&apos; -f ~/.ssh/gitee_id_rsa</span><br></pre></td></tr></table></figure></p><p>由于指定了文件名，可以一路回车，不用输入密码。<br>然后～/.ssh目录下会出现4个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">github_id_rsa</span><br><span class="line">github_id_rsa.pub</span><br><span class="line">gitee_id_rsa</span><br><span class="line">gitee_id_rsa.pub</span><br></pre></td></tr></table></figure></p><h3 id="2-在～-ssh-目录下创建config文件。"><a href="#2-在～-ssh-目录下创建config文件。" class="headerlink" title="2. 在～/.ssh 目录下创建config文件。"></a>2. 在～/.ssh 目录下创建config文件。</h3><p>打开～/.ssh目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open ~/.ssh</span><br></pre></td></tr></table></figure></p><p>编辑config文件，写入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># github</span><br><span class="line">Host github.com # host名字可以随意，自己能识别就好，我这里直接使用了网站域名</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br><span class="line"></span><br><span class="line"># gitee</span><br><span class="line">Host my.gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/gitee_id_rsa</span><br></pre></td></tr></table></figure></p><h3 id="3-将为不同账号生成的公钥，填入各自网站的ssh-key配置中。"><a href="#3-将为不同账号生成的公钥，填入各自网站的ssh-key配置中。" class="headerlink" title="3. 将为不同账号生成的公钥，填入各自网站的ssh key配置中。"></a>3. 将为不同账号生成的公钥，填入各自网站的ssh key配置中。</h3><p>可以通过cat查看公钥内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/github_id_rsa.pub</span><br></pre></td></tr></table></figure></p><h3 id="4-检测配置成没成功"><a href="#4-检测配置成没成功" class="headerlink" title="4. 检测配置成没成功"></a>4. 检测配置成没成功</h3><p>检测方法：<code>ssh -T git@Host</code>, Host 就是你之前在config文件中配置的Host 的值。<br>检测github的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>检测gitee的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@my.gitee.com</span><br></pre></td></tr></table></figure></p><p>如果有提示问要不要把这个RSA host key 添加到 <code>konwn_host</code> 列表中，选择yes。<br>最后如果看到类似如下的提示，说明配置成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxxx! You&apos;ve successfully authenticated,but...... access.</span><br></pre></td></tr></table></figure></p><h3 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h3><blockquote><p>科普：SSH：Secure Shell，是建立在应用层基础上的安全协议。github要求推送代码的用户是合法的，所以每次推送都需要输入账号和密码，用于验证你是否为合法用户，为了省去每次都要输入密码的步骤，采用ssh公钥秘钥，也就是ssh key来验证，公钥放到github上，推送代码时，git会检测你本地的私钥是否跟github上的公钥配对。ssh key可以理解为你的身份标识，公钥放在github上表明你是这个项目的一个开发人员，公钥匙可以被截获的，但是私钥在本地别人就无法截获，ssh key可以保证每次传输都是安全的。</p></blockquote><p>Have a nice day!</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm link详解</title>
      <link href="/2019/08/27/npm-link%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/27/npm-link%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>npm install</code> 可以把发布在 npmjs 平台上的模块包下载到本地，<code>npm install -g</code> 可以把包下下来的同时，还帮我们配置好全局变量，让我们可以直接使用命令而不是通过 node 来执行或者配置 <code>package.json</code> 的 script 脚本来 run。</p><p>但这仅限于已经发布的包，那对于未发布的包，要怎么测试使用呢？难道要把一个未经测试的包发布上去然后 install 下来测试？当然不能这么做，也不用这么做。npm 官方早已考虑到了这一点，给我们提供了测试本地的包的工具指令：<code>npm link</code>。</p></blockquote><a id="more"></a><h3 id="npm-link原理"><a href="#npm-link原理" class="headerlink" title="npm link原理"></a>npm link原理</h3><p><code>npm link</code> 可以帮助我们模拟包安装后的状态，它会在系统中做一个快捷方式映射，让本地的包就好像install过一样，可以直接使用。</p><p>在mac中，我们在终端可以直接敲的命令，其实是在执行<code>/usr/local/bin</code>目录下的脚本，这个目录可以认为是我们的全局命令所在的地方。</p><p>而当我们在<code>npm install -g</code>的时候，其实是将相关文件安装在<code>/usr/local/lib/node_modules</code>目录下，同时在全局命令<code>/usr/local/bin</code>目录下会有一个映射脚本，将其指向/usr/local/lib下的真实文件。这么做的好处是，可以在保证只有一份可执行文件的前提下，给命令取别名。</p><p>同样的，<code>npm link</code> 做的事情也是一样，唯一的区别是，它在 /usr/local/lib 下的 <code>node_modules</code> 里不是存的真实的文件，而是存了一个快捷方式，指向你当前执行 <code>npm link</code> 的目录。如果开发的的是node包，则执行的命令名和真实执行的文件入口，会根据项目的 <code>package.json</code> 里 <code>bin</code> 的配置来获取。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-project-dir</span><br><span class="line">npm link</span><br></pre></td></tr></table></figure><p>然后会看到输出类似如下的链接信息，说明成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/yourpakagename -&gt; /usr/local/lib/node_modules/yourpackagename/xxx</span><br><span class="line">/usr/local/lib/node_modules/yourpackagename/xxx -&gt; /Users/username/Documents/xxx(your real project path)</span><br></pre></td></tr></table></figure></p><h4 id="全局link"><a href="#全局link" class="headerlink" title="全局link"></a>全局link</h4><p>测试 node 环境下运行的包时，需要使用全局 link​。​并且做<code>npm link</code>之前，需要在 <code>package.json</code> 里配置 <code>bin</code> 字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># package.json</span><br><span class="line">&quot;bin&quot; : &#123;  </span><br><span class="line">&quot;your-command-name&quot;: &quot;./path-to/your-command-entry-file&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再在当前目录下进行link<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-command-module</span><br><span class="line">npm link</span><br></pre></td></tr></table></figure></p><p>成功后，就可以直接在终端执行全局命令 <code>your-command-name</code> 了。</p><h4 id="link到项目"><a href="#link到项目" class="headerlink" title="link到项目"></a>link到项目</h4><p>如果是测试前端包，跑在浏览器环境的，比如 UI 组件库，有两种情况：</p><ul><li><p>当项目和模块在同一个目录下，可以使用相对路径，只需要link一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link ../xx-module</span><br></pre></td></tr></table></figure></li><li><p>当项目和模块不在同一个目录下，那需要做两次 link。<br>先进入待测试组件库目录，将组件库 link 到全局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-ui-lib</span><br><span class="line">npm link</span><br></pre></td></tr></table></figure><p>之后，再进入要使用该组件库的工程，然后在工程中 link 这个组件库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-project</span><br><span class="line">npm link your-ui-lib</span><br></pre></td></tr></table></figure></li></ul><p>现在你就可以在你的工程中使用这个 ui 组件库，就好像这个 ui 库被 install 到工程中一样。</p><h4 id="解除link"><a href="#解除link" class="headerlink" title="解除link"></a>解除link</h4><ul><li><p>解除模块全局link<br>进入模块目录，然后执行unlink</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-command-module</span><br><span class="line">npm unlink your-command-module</span><br></pre></td></tr></table></figure></li><li><p>解除项目和模块link<br>进入项目目录，然后执行unlink</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-project</span><br><span class="line">npm unlink your-ui-lib</span><br></pre></td></tr></table></figure></li></ul><p>GoodLuck！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> NPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在mac中管理和随时切换node版本</title>
      <link href="/2019/08/26/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%AD%E7%AE%A1%E7%90%86%E5%92%8C%E9%9A%8F%E6%97%B6%E5%88%87%E6%8D%A2node%E7%89%88%E6%9C%AC/"/>
      <url>/2019/08/26/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%AD%E7%AE%A1%E7%90%86%E5%92%8C%E9%9A%8F%E6%97%B6%E5%88%87%E6%8D%A2node%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前用windows的电脑的时候，曾使用 <code>nvm-windows</code> 工具来管理开发环境中的node版本。快速在各个版本的node环境中切换的体验非常好。而在mac中，由于开发环境比较稳定，则没有使用这类工具来管理。近期由于项目的需要，有了在mac下频繁切换node版本的需求。才有了这篇文章。</p></blockquote><h2 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h2><p>我根据第一直觉，在npm上搜索 <code>nvm</code>，竟没有 <code>nvm</code> 的精确匹配，搜索结果第一位是一个叫 <code>n</code> 的包，点进去，也没个README说明（其实是当时我的网络不好README没有加载出来…）。(说实话，要不是发现它的作者是tj大神，我后来可能不会再次点开它，可能我就错过了一个非常好的工具。）</p><p>诧异过后，我转到github，搜索 <code>nvm</code>。 找是找到了，然而，它的安装方式，让我觉得不太友好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>为什么nvm没有pacakge版？不如看看那个”连README都没有”的 <code>n</code> 是否能用。我点开了 <code>n</code> 的github页面。详细的使用说明映入眼帘，粗略读了一遍，感觉有戏。仔细操作一遍，这感觉，怎么说呢，这是捡到宝了呀！</p><p><strong> 就它了！ n！ </strong></p><h2 id="如何使用-n-管理mac上的node版本"><a href="#如何使用-n-管理mac上的node版本" class="headerlink" title="如何使用 n 管理mac上的node版本"></a>如何使用 <code>n</code> 管理mac上的node版本</h2><a id="more"></a><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br></pre></td></tr></table></figure><h3 id="2-修改几个本地目录的拥有者"><a href="#2-修改几个本地目录的拥有者" class="headerlink" title="2. 修改几个本地目录的拥有者"></a>2. 修改几个本地目录的拥有者</h3><p>因为node环境是全局的，需要安装到系统目录下，涉及目录有 <code>/usr/local/bin</code>、<code>usr/local/lib</code>、<code>/usr/local/include</code>、<code>/usr/local/share</code>，这几个目录的拥者是root，其他用户没有权限操作他们。如下命令可以将他们的拥有者从root改为当前用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) /usr/local/bin /usr/local/lib /usr/local/include /usr/local/share</span><br></pre></td></tr></table></figure></p><p>另外，n 会在系统目录下创建一个目录，也需要修改下它的拥有者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) /usr/local/n</span><br></pre></td></tr></table></figure></p><p>关于 <code>chown</code> 命令，我的另一篇文章有详细说明：<strong> <a href="https://yc111.github.io/2019/08/26/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9mac%E4%B8%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%A5%E6%9C%89%E8%80%85/" target="_blank" rel="noopener">如何修改mac中文件夹和文件的拥有者</a> </strong></p><h3 id="3-安装指定版本的node"><a href="#3-安装指定版本的node" class="headerlink" title="3. 安装指定版本的node"></a>3. 安装指定版本的node</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n 10.16.3 //下载并安装node 10.16.3</span><br><span class="line">n latest //下载并安装node 最新版本</span><br><span class="line">n lts //下载并安装node 长期稳定维护版</span><br></pre></td></tr></table></figure><h3 id="4-切换node版本"><a href="#4-切换node版本" class="headerlink" title="4. 切换node版本"></a>4. 切换node版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n //列出所有缓存的node版本</span><br><span class="line">    node/4.4.4</span><br><span class="line">  ο node/8.11.1</span><br><span class="line">    node/10.16.3</span><br><span class="line">Use up/down arrow keys to select a version, return key to install, q to quit</span><br><span class="line">-&gt; 上下键选择当前需要的版本，回车</span><br><span class="line">-&gt; done</span><br></pre></td></tr></table></figure><p>用 <code>node -v</code> 查看版本是否生效。</p><h3 id="5-删除node版本"><a href="#5-删除node版本" class="headerlink" title="5. 删除node版本"></a>5. 删除node版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//删除指定版本</span><br><span class="line">n rm xxx</span><br><span class="line">//删除当前版本外的所有版本</span><br><span class="line">n prune</span><br><span class="line">//卸载当前已安装的node</span><br><span class="line">n uninstall</span><br></pre></td></tr></table></figure><h3 id="6-其他命令"><a href="#6-其他命令" class="headerlink" title="6. 其他命令"></a>6. 其他命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n ls //查看已下载的node版本列表</span><br></pre></td></tr></table></figure><p><strong> 补充 </strong><br><code>n</code> 的获取node的源路径为node官网<code>https://nodejs.org/dist/</code>，在国内访问，非常慢，经常由于太慢而发生超时错误导致下载失败。解决方案：修改node镜像源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export N_NODE_DOWNLOAD_MIRROR=https://npm.taobao.org/mirrors/node</span><br></pre></td></tr></table></figure></p><p>将node镜像指向淘宝镜像。再来操作 <code>n</code> 命令，是不是速度嗖嗖的了。</p><p>GOOD LUCK！</p><hr><p>参考：<br>n （npm）：<a href="https://www.npmjs.com/package/n" target="_blank" rel="noopener">https://www.npmjs.com/package/n</a><br>n （github）：<a href="https://github.com/tj/n" target="_blank" rel="noopener">https://github.com/tj/n</a><br>nvm ：<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a><br>nvm-window ：<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Intergration </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> node </tag>
            
            <tag> n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何修改mac中文件夹和文件的拥有者</title>
      <link href="/2019/08/26/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9mac%E4%B8%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%A5%E6%9C%89%E8%80%85/"/>
      <url>/2019/08/26/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9mac%E4%B8%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%A5%E6%9C%89%E8%80%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在mac上开发，涉及在系统目录（指操作系统自带的那些目录，比如<code>／</code>、 <code>／usr</code>、 <code>／usr／local／bin</code>  等）创建文件夹或者文件时，会出现由于权限不足导致创建失败的问题。这是由于，这些目录属于 <code>root</code> 用户， 而当前登录mac的一般都是非root用户，而非root用户没有权限修改root用户直接管辖的目录和文件。那么如何让用户拥有这些目录的修改权限呢？</p></blockquote><a id="more"></a><p>解决办法有两个：</p><ul><li>方法一：改成使用root登录，这样就具有对操作系统的最大权限，可以为所欲为。但是，不推荐这么做，因为太危险。</li><li>方法二：将你要操作的目录的权限从root手里夺过来，也即修改目录的拥有者。推荐。</li></ul><h2 id="如何修改目录的拥有者"><a href="#如何修改目录的拥有者" class="headerlink" title="如何修改目录的拥有者"></a>如何修改目录的拥有者</h2><p>使用linux命令 <code>chown</code> 。 </p><h3 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] 所有者[:组] 文件</span><br></pre></td></tr></table></figure><p><code>chown</code> 将指定文件的拥有者改为指定的用户或者用户组，用户可以是用户名或者用户ID，组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用 <code>chown</code> 命令，在将文件拷贝到另一个用户的目录下后，让用户拥有使用该文件的权限。</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p><strong> 把 <code>／usr/local/bin</code> 和 <code>／usr/local/lib</code> 这两个目录以及其子目录的拥有者从root改成当前用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) /usr/local/bin ／usr/local/lib</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li><code>chown</code> change owner 的缩写。</li><li><code>$(whoami)</code> who am i ，获取当前的用户。</li><li><code>-R</code> –recursive 的缩写，递归处理，将指定目录和所有子目录一并处理。</li></ul><p><strong> 执行完命令，可以用 <code>ls -l</code> 来查看一下是否修改成功。</strong></p><h3 id="常用选项列表："><a href="#常用选项列表：" class="headerlink" title="常用选项列表："></a>常用选项列表：</h3><p>必要参数</p><ul><li><code>-c</code> ：–changes 的缩写，当发生改变时输出调试信息，仅显示更改部分的信息</li><li><code>-f</code> ：不显示错误信息，忽略错误信息</li><li><code>-h</code> ：修复符号链接</li><li><code>-R</code> ：–recursive 的缩写, 递归处理，将指定目录以及其子目录下的所有文件一并处理</li><li><code>-v</code> ：–verbose 的缩写, 显示指令执行过程的详细的处理信息<br>选择参数</li><li><code>--help</code> ：显示帮助信息</li><li><code>--version</code> ：显示版本信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iphone AirDrop 无法发现mac的解决办法</title>
      <link href="/2019/08/13/iphone-AirDrop-%E6%97%A0%E6%B3%95%E5%8F%91%E7%8E%B0mac%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2019/08/13/iphone-AirDrop-%E6%97%A0%E6%B3%95%E5%8F%91%E7%8E%B0mac%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前几天想把手机上的照片传到mac上，发现在AirDrop里看不到我的mac了。以为是电脑太久没重启抽了，因为以前是可以找到的。于是重启了mac，结果没用。后来求助网络，才终于搞定。在此记下方法，以备以后遇到同样的问题又忘记怎么处理。</p></blockquote><a id="more"></a><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>先确保手机（iPhone）上的蓝牙打开，<code>AirDrop</code> 开启，并对所有人可见。</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>确保 <code>mac</code> 上 <code>AirDrop</code> 开启。具体操作：打开 <code>Finder</code> 中的 <code>AirDrop</code> ，并设置成 <code>所有人可见</code>。不过此时手机上的 <code>AirDrop</code> 仍然看不到 <code>mac</code>。</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>确保 <code>mac</code> 上蓝牙开启。具体操作：打开 <code>设置</code> -&gt; <code>蓝牙</code> -&gt; <code>打开蓝牙</code>。</p><h2 id="第四步-（关键）"><a href="#第四步-（关键）" class="headerlink" title="第四步 （关键）"></a>第四步 （关键）</h2><!-- more --><p><code>mac</code> 和 <code>iPhone</code> 蓝牙配对。具体操作：在 <code>mac</code> 的蓝牙设置界面，应该可以看到你的 <code>iPhone</code> 了。点击这个 <code>iPhone</code> 旁边的 <code>配对</code> 按钮。然后手机会收到一个配对请求，点接受。等待一会，就会配对成功。</p><p>PS：如果第四部看到手机已经是配对状态，则移除后重新配对。</p><p>这时，在mac和iPhone的AirDrop中就可以互相看见彼此了，然后就可以愉快地互传文件了。</p><p>Have a nice day!</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iphone </tag>
            
            <tag> mac </tag>
            
            <tag> airdrop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶(五)：给文章添加字数统计、阅读时长</title>
      <link href="/2019/02/25/%E8%BF%9B%E9%98%B6-%E4%BA%94-%EF%BC%9A%E7%BB%99%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1%E3%80%81%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/"/>
      <url>/2019/02/25/%E8%BF%9B%E9%98%B6-%E4%BA%94-%EF%BC%9A%E7%BB%99%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1%E3%80%81%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>继续倒腾个站。今天看到别人的花里胡哨的博客，手又痒了。之前我可是对自己的<strong>极简风</strong>“守身如玉”，不愿意在个站添加一点点多余的信息。今天居然有一点点动摇了，那就神不知鬼不觉地添加一点统计信息吧，这都是为了用户体验好（天音：想加东西就加，这么多借口干啥？）我：[抠鼻]</p></blockquote><a id="more"></a><p>只需三步：</p><h1 id="Step1-安装插件"><a href="#Step1-安装插件" class="headerlink" title="Step1: 安装插件"></a>Step1: 安装插件</h1><p>需要安装 <a href="https://www.npmjs.com/package/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a> 插件。它可以统计文章字数，估算阅读时长，以及统计整个网站的总字数。<br>在命令行进入blog根目录，然后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure></p><h1 id="Step2-修改主题配置"><a href="#Step2-修改主题配置" class="headerlink" title="Step2: 修改主题配置"></a>Step2: 修改主题配置</h1><p>进入 <code>themes/next/</code> 目录，打开 <code>_config.yml</code> ，找到 <code>post_wordcount</code> 字段，将<code>wordcont</code>、<code>min2read</code>、<code>totalcount</code> 三个属性都设为 <code>true</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalcount: true</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure></p><h1 id="Step3-重启hexo"><a href="#Step3-重启hexo" class="headerlink" title="Step3: 重启hexo"></a>Step3: 重启hexo</h1><p>给hexo项目安装新的插件，以及修改一些配置，需要重启hexo才能看到效果。我们重新 <code>hexo s</code> 启动一下hexo，再刷新本地预览界面，现在你可以看到：</p><ul><li>在每个标题下面增加了文章字数（<code>Words count in article</code>） 和 阅读时长（<code>Reading time</code>） 两组统计项；</li><li>在网站页脚增加了所有文章字数统计数据（<code>Site words total count</code>）。</li></ul><p>–<br>NICE～</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加chrome扩展程序技巧</title>
      <link href="/2019/01/29/%E6%B7%BB%E5%8A%A0chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/01/29/%E6%B7%BB%E5%8A%A0chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们给chrome 浏览器添加扩展程序，有时会遭到 chrome 的限制，比如只能通过 chrome 商城添加，而 chrome 商城需要墙外的环境，大多数时候不一定当前电脑可以翻墙。那么就需要一些技巧来添加这些扩展程序。</p></blockquote><a id="more"></a><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li><p>在扩展程序界面，打开开发者模式。</p></li><li><p>然后将下载好的 <code>.crx</code> 扩展程序文件拖拽到插件管理界面。</p></li></ul><blockquote><p>该方法通常是可行的，不过也有的时候赶上某些 chrome 版本，不允许拖拽安装。那么可以尝试第方法2：</p></blockquote><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ul><li><p>首先将下载好的 <code>.crx</code> 扩展程序文件修改后缀为 <code>.rar</code>，然后解压它，在解压的文件夹内，找到 <code>_metadata</code> 文件夹，将下划线去掉，改为 <code>metadata</code>。 </p></li><li><p>然后在 chrome 插件管理界面，打开开发者模式，点击 ‘加载已解压的扩展程序’，选择刚才解压并修改后的文件夹，确定，即可。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
            <tag> browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创建空白git分支</title>
      <link href="/2019/01/29/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%99%BDgit%E5%88%86%E6%94%AF/"/>
      <url>/2019/01/29/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%99%BDgit%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在管理前端代码工程时，有时需要创建一个干净的分支，比如用于放文档，或者全新的版本分支。但是普通的创建分支命令，会将历史日志带过去。那么对于有代码洁癖和强迫症的人（比如我）来说，是不能忍的。强大的git为我们这些人准备了创建空白git分支的方法。掌握后受用无穷。</p></blockquote><a id="more"></a><p>步骤：</p><h2 id="1-创建无父节点的分支"><a href="#1-创建无父节点的分支" class="headerlink" title="1. 创建无父节点的分支"></a>1. 创建无父节点的分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan orphanbranch</span><br></pre></td></tr></table></figure><p>参数 <code>orphan</code> 的作用有两个：</p><ul><li>1.拷贝当前所在分支的所有文件。</li><li>2.让这个新的分支没有父节点。这意味着这个分支不会有任何历史记录。</li></ul><p><img src="/images/git-checkout---orphan.jpg" alt="git-checkout---orphan.jpg"></p><h2 id="2-删除该分支下所有文件"><a href="#2-删除该分支下所有文件" class="headerlink" title="2. 删除该分支下所有文件"></a>2. 删除该分支下所有文件</h2><p><code>orphan</code> 会把之前分支中的文件都拷贝过来，这些文件我不想要，因为我要一个完全空白的干净分支。可以用<code>git rm</code>删除一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -rf .</span><br></pre></td></tr></table></figure></p><p><img src="/images/git-rm.jpg" alt="git-rm.jpg"></p><blockquote><p>不用担心在log里留下delete日志，因为严格来讲，我们的分支还没完全创建好（还差一步），此时的操作并不会影响历史记录。</p></blockquote><h2 id="3-创建一个初始文件，比如readme，并提交"><a href="#3-创建一个初始文件，比如readme，并提交" class="headerlink" title="3. 创建一个初始文件，比如readme，并提交"></a>3. 创建一个初始文件，比如readme，并提交</h2><p>现在试着查看下当前分支：<br><img src="/images/git-branch-a.jpg" alt="git-branch-a.jpg"></p><p>会发现，并没有看到我们创建的 <code>orphanbranch</code>。因为还差一步，我们必须对这个分支进行一次初始提交，才可以看到它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch README.md</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;add readme&quot;</span><br></pre></td></tr></table></figure></p><h2 id="4-一个干净的空白分支诞生"><a href="#4-一个干净的空白分支诞生" class="headerlink" title="4. 一个干净的空白分支诞生"></a>4. 一个干净的空白分支诞生</h2><p>现在<code>git branch -a</code>可以看到这个分支了。用<code>git log</code>查看一下这条分支的日志，可以看到，只有一条添加readme的记录。此时，一个空白分支就创建成功了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br><span class="line">git log --oneline</span><br></pre></td></tr></table></figure></p><p><img src="/images/git-branch-a-git-log.jpg" alt="git-branch-a-git-log.jpg"></p><p>Good luck！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> branch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶(四)：给博客添加站内搜索功能</title>
      <link href="/2019/01/26/%E8%BF%9B%E9%98%B6-%E5%9B%9B-%EF%BC%9A%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/01/26/%E8%BF%9B%E9%98%B6-%E5%9B%9B-%EF%BC%9A%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不知不觉坚持写博客已经快一年了，博客文章破50，虽然平均每个月4到5篇不算什么，但是对于平时一心扑到工作简直没有时间生活的我来说，已经很不容易了。虽然文章可能没有高大上的标题，也没有涉及太多前沿的技术，但是起码我记录下了我的一些小经验，累积了自己的一个小知识库。其实我还有很多内容没来及的记录，希望以后能通过博客沉淀更多的知识，同时帮助到更多的人。</p><p>言归正传，文章一多，有时自己想翻查一个内容，要找好久，要是有站内查找功能就好了。于是仔细查阅了工程yml配置，果然发现在theme下的<code>_config.yml</code>有个<code>local_search</code>配置项，满心欢心把它设为<code>true</code>。结果搜索图标是出来了，但是点击后除了在页面加了一个全局loading就什么都没有了。看来还需要额外的操作。百度了一番，原来hexo提供了的search插件，需要手动安装才可以使用站内搜索。</p></blockquote><a id="more"></a><p>3步搞定：</p><h2 id="1-安装两个插件"><a href="#1-安装两个插件" class="headerlink" title="1.安装两个插件"></a>1.安装两个插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-generator-search hexo-generator-searchdb</span><br></pre></td></tr></table></figure><h2 id="2-配置hexo主配置文件（位于工程根目录下）-config-yml"><a href="#2-配置hexo主配置文件（位于工程根目录下）-config-yml" class="headerlink" title="2.配置hexo主配置文件（位于工程根目录下）_config.yml"></a>2.配置hexo主配置文件（位于工程根目录下）<code>_config.yml</code></h2><p>在最后面追加这段，注意2个空格的缩进，这个是yml缩进语法，不能随意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># local_search</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p><h2 id="3-配置hexo主题下的配置文件（位于theme-gt-next下）-config-yml"><a href="#3-配置hexo主题下的配置文件（位于theme-gt-next下）-config-yml" class="headerlink" title="3.配置hexo主题下的配置文件（位于theme-&gt;next下）_config.yml"></a>3.配置hexo主题下的配置文件（位于theme-&gt;next下）<code>_config.yml</code></h2><blockquote><p>将<code>enable</code>设为<code>true</code>。这一步我在一开始就已经做过了～</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure><p>重新<code>hexo g</code>, <code>hexo s</code>，刷新页面，点击搜索图标，就可以看到搜索弹出框了，输入关键字，可以看到匹配到文章。<br><img src="/images/hexo-local-search.jpg" alt=""></p><p>GOOD LUCK!</p><hr><p>参考资料：<br><a href="https://www.jianshu.com/p/519b45730824" target="_blank" rel="noopener">https://www.jianshu.com/p/519b45730824</a><br><a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">https://github.com/wzpan/hexo-generator-search</a><br><a href="https://www.npmjs.com/package/hexo-generator-searchdb" target="_blank" rel="noopener">https://www.npmjs.com/package/hexo-generator-searchdb</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm install 高级</title>
      <link href="/2019/01/09/npm-install-%E9%AB%98%E7%BA%A7/"/>
      <url>/2019/01/09/npm-install-%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>npm install</p><p>npm install –production</p><p>npm install –only=prod</p><p>npm install –only=dev</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> NPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git clone 高级</title>
      <link href="/2019/01/09/git-clone-%E9%AB%98%E7%BA%A7/"/>
      <url>/2019/01/09/git-clone-%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义克隆下来的目录名"><a href="#自定义克隆下来的目录名" class="headerlink" title="自定义克隆下来的目录名"></a>自定义克隆下来的目录名</h2><p>克隆仓库的命令格式是 <code>git clone [url]</code><br>这个命令会将远程仓库的名字作为你的本地仓库（即项目根目录）的名字。<br>如果你想自己命名本地仓库的名字可以使用这个命令：<code>git clone [url] yourprojectname</code></p><h2 id="克隆指定分支"><a href="#克隆指定分支" class="headerlink" title="克隆指定分支"></a>克隆指定分支</h2><p>如果远程仓库不做设置，默认 <code>git clone</code> 克隆下来的是项目的 <code>master</code> 分支。<br>如果想要获取非 <code>master</code> 分支，可以使用命令指定分支： <code>git clone -b branchname [url]</code><br>比如我要克隆 <code>zrender</code> 项目的 <code>dev</code> 分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b dev https://github.com/ecomfe/zrender</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github和gitlab上的md文档支持相对路径的链接了</title>
      <link href="/2019/01/09/github%E5%92%8Cgitlab%E4%B8%8A%E7%9A%84md%E6%96%87%E6%A1%A3%E6%94%AF%E6%8C%81%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E9%93%BE%E6%8E%A5%E4%BA%86/"/>
      <url>/2019/01/09/github%E5%92%8Cgitlab%E4%B8%8A%E7%9A%84md%E6%96%87%E6%A1%A3%E6%94%AF%E6%8C%81%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E9%93%BE%E6%8E%A5%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>markdown 格式语法中，链接的格式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[链接文字](链接地址)</span><br></pre></td></tr></table></figure></p><p>之前写链接，用 http 协议 url 居多，最近遇到在项目的 README 中要添加另一个文档的链接，由于当前在 dev 分支，如果写分支的仓库 url 路径，那到时候 dev 分支合并到其他分支后，dev 分支被删除后，这个地址岂不是有问题了。如果能用相对路径就好了。</p><p>查了下，居然在 gitlab 上是支持的，在 github 上最近也支持了，真是喜讯。说到喜讯，昨天 github 官网宣布开放免费的 private repository ，也是2019喜讯一桩。</p><h3 id="相对路径使用举例"><a href="#相对路径使用举例" class="headerlink" title="相对路径使用举例"></a>相对路径使用举例</h3><p>如果你的项目结构如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">    text.md</span><br><span class="line">    subpro/</span><br><span class="line">        subtext.md</span><br><span class="line">        subsubpro/</span><br><span class="line">            subsubtext.md</span><br><span class="line">        subsubpro2/</span><br><span class="line">            subsubtext2.md</span><br></pre></td></tr></table></figure><p>那么在 text.md 中链接到 subtext.md 的相对链接这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[this subtext](subpro/subtext.md)</span><br></pre></td></tr></table></figure></p><p>在 text.md 中链接到 subsubtext.me 的相对链接这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[this subsubtext](subpro/subsubpro/subsubprotext.md)</span><br></pre></td></tr></table></figure></p><p>在 subsubtext.md 中链接到 text.md 的相对链接这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[this text](../../text.md)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Intergration </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows批处理常用命令</title>
      <link href="/2018/12/20/windows%E6%89%B9%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/12/20/windows%E6%89%B9%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前阵子在倒腾服务器的时候，需要些一些 windows 批处理来执行任务。就稍微研究了一下。</p></blockquote><h3 id="一、-基本信息"><a href="#一、-基本信息" class="headerlink" title="一、 基本信息"></a>一、 基本信息</h3><ol><li>批处理文件扩展名为 <code>.bat</code> 或者 <code>.cmd</code>。区别：cmd 文件只能在 windows2000 以上的系统才能运行，bat 文件则没有这个限制。</li><li>这个文件的每一行都是一条 DOS 命令。</li><li>可以使用任何文本编辑器创建和修改。</li><li>批处理是一种简单的程序，可以用 <code>if</code> 和 <code>go</code> 来控制流程，也可以使用 <code>for</code> 循环。</li><li>批处理的编程能力远不如 C语言等编程语言，也十分不规范。</li><li>每个编写好的批处理文件都相当于一个 DOS 的外部命令，把它锁在的目录放到 DOS 搜索路径（path）中，即可在任意位置运行。</li><li><code>C:\AUTOEXEC.BAT</code>  是每次系统启动时都会自动运行的，可以将每次启动时都要运行的命令放入该文件中。</li><li>大小写不敏感</li><li>在命令提示下键入批处理文件的名称，或者双击该批处理文件，系统会调用cmd.exe来运行该文件。</li></ol><h3 id="二、-参数"><a href="#二、-参数" class="headerlink" title="二、 参数"></a>二、 参数</h3><a id="more"></a><ol><li><p>系统参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%SystemRoot% === C:\WINDOWS (%windir% 同样)</span><br><span class="line">%ProgramFiles% === C:\Program Files</span><br><span class="line">%USERPROFILE% === C:\Documents and Settings\Administrator (子目录有“桌面”,“开始菜单”,“收藏夹”等)</span><br><span class="line">%APPDATA% === C:\Documents and Settings\Administrator\Application Data</span><br><span class="line">%TEMP% === C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp (%TEM% 同样)</span><br><span class="line">%APPDATA% === C:\Documents and Settings\Administrator\Application Data</span><br><span class="line">%OS% === Windows_NT (系统)</span><br><span class="line">%Path% === %SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem (原本的设置)</span><br><span class="line">%HOMEDRIVE% === C: (系统盘)</span><br><span class="line">%HOMEPATH% === \Documents and Settings\Administrator</span><br><span class="line"></span><br><span class="line">:: 枚举当前的环境变量</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">FOR /F &quot;usebackq delims==&quot; %%i IN (`set`) DO @echo %%i !%%i!</span><br></pre></td></tr></table></figure></li><li><p>给批处理文件传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%[1-9]表示参数，参数是指在运行批处理文件时在文件名后加的以空格(或者Tab)分隔的字符串。</span><br><span class="line">变量可以从%0到%9，%0表示批处理命令本身，其它参数字符串用 %1 到 %9 顺序表示。</span><br><span class="line"></span><br><span class="line">Sample：</span><br><span class="line">call test2.bat &quot;hello&quot; &quot;haha&quot; (执行同目录下的“test2.bat”文件，并输入两个参数)</span><br><span class="line">在“test2.bat”文件里写:</span><br><span class="line">echo %1 (打印: &quot;hello&quot;)</span><br><span class="line">echo %2 (打印: &quot;haha&quot;)</span><br><span class="line">echo %0 (打印: test2.bat)</span><br><span class="line">echo %19 (打印: &quot;hello&quot;9)</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、-基本命令"><a href="#三、-基本命令" class="headerlink" title="三、 基本命令"></a>三、 基本命令</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><h4 id="md"><a href="#md" class="headerlink" title="md"></a>md</h4><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><h4 id="shutdowm"><a href="#shutdowm" class="headerlink" title="shutdowm"></a>shutdowm</h4><h4 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h4><h4 id="符号："><a href="#符号：" class="headerlink" title="符号："></a>符号：</h4><p><code>&gt;</code>        传递并覆盖<br><code>&gt;&gt;</code>       传递并追加<br><code>::</code>       注释</p><p>找到一个比较清晰比较全的一个文档，在<a href="https://segmentfault.com/a/1190000009873409" target="_blank" rel="noopener">这里</a></p><h3 id="四、-例子"><a href="#四、-例子" class="headerlink" title="四、 例子"></a>四、 例子</h3><p>重启的批处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r -f -t 0</span><br></pre></td></tr></table></figure></p><blockquote><p>r: 关闭并重启计算机。<br>f: 强制关闭正在运行的应用程序，不在前台警告用户。<br>t xxx: 设置关闭的超时事件为 xxx 秒。有效范围时0-315360000（10年），默认值为30.</p></blockquote><p>在重启前，将重启时间写入日志(以下已在英文版windows操作系统上检测过)<br>restart.bat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set nowdate=%date:~4, 10%</span><br><span class="line">set nowtime=%time:~0,8%</span><br><span class="line">set content=%nowdate:/=-% %nowtime%</span><br><span class="line">set distpath=&quot;c:\restartlog&quot;</span><br><span class="line">::write log</span><br><span class="line">echo restart time: %content% &gt;&gt; %distpath%\log.txt</span><br><span class="line">shutdown -r -f -t 0</span><br></pre></td></tr></table></figure></p><p>再在windows的计划任务中，将这个脚本配置进去。则当脚本执行，将会在系统的c盘下新建一个目录restartlog，然后在这个目录中创建一个文件log.txt，并在文件中追加写入： “restart time： 当时的时间”，最后重启系统。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> windows </tag>
            
            <tag> bat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git如何撤销commit并保留修改</title>
      <link href="/2018/11/27/git%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80commit%E5%B9%B6%E4%BF%9D%E7%95%99%E4%BF%AE%E6%94%B9/"/>
      <url>/2018/11/27/git%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80commit%E5%B9%B6%E4%BF%9D%E7%95%99%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有时 commit 代码的时候，手误或者眼花误将不应该这次提交的文件 commit 了，此时还没有 push 到远程仓库，这个时候可以通过 git 命令，撤销该次 commit，并且本地修改还在，即回到 commit 之前的状态，可以重新选择文件进行提交。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft [commit_id]</span><br></pre></td></tr></table></figure><p>这个 commit_id 可以是历史记录中任一一个，这个命令会让你的代码回到该条 commit 之后的状态，所有的修改都会在，log 中的该条之后的 commit 记录就都删除了。所以也要谨慎使用，一般用于撤销上一次的 commit。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何更改git clone默认检出的分支</title>
      <link href="/2018/11/26/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9git-clone%E9%BB%98%E8%AE%A4%E6%A3%80%E5%87%BA%E7%9A%84%E5%88%86%E6%94%AF/"/>
      <url>/2018/11/26/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9git-clone%E9%BB%98%E8%AE%A4%E6%A3%80%E5%87%BA%E7%9A%84%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<p>一般我们 clone 一个项目都是检出默认的 master 分支。这个其实是可以修改的。</p><p>修改办法：<br>在 git 服务器上，进入该项目的 .git （仓库）文件夹，编辑 HEAD 文件。</p><p>例如想默认为 dev 分支：<br>将 refs/heads/master 改成 refs／heads/dev</p><blockquote><p>该操作需要 git 管理员来完成，修改本地仓库没有用。</p></blockquote><p>在 gitlab 或者 github 的仓库配置中，可以找到，有个默认分支下拉选项，就是做这个设置的。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js如何识别图片加载失败</title>
      <link href="/2018/11/26/js%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/"/>
      <url>/2018/11/26/js%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在做项目过程中遇到图片请求失败的时候，图片区域会出现一个原生的碎片图标，非常影响用户体验。这时需要用一个 broken 的图片去代替它，来提升户体验。要做到这一点，首先要在代码中识别图片加载失败这个事情。那么怎么判断一个图片加载失败了呢？</p></blockquote><a id="more"></a><h1 id="在-js-中使用-onerror-事件"><a href="#在-js-中使用-onerror-事件" class="headerlink" title="在 js 中使用 onerror 事件"></a>在 js 中使用 onerror 事件</h1><p>javascript 给我们提供了一个 <code>onerror</code> 事件，img 标签支持该事件，当装载文档或者图像的过程中发生了错误，就会触发 onerror 事件。<br>我们可以在这个事件中，定义要替换加载不出来的原图的 broken 图片。</p><p>核心代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;img src=&quot;img.png&quot; onerror=&quot;myfunction()&quot;&gt;</span><br><span class="line"></span><br><span class="line">// javascript</span><br><span class="line">myfunction() &#123;</span><br><span class="line">this.src=&quot;default.png&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>如果 onerror 指定的图片也不存在的话，会出现无限死循环 404. 解决办法是在 js 中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// javascript</span><br><span class="line">myfunction() &#123;</span><br><span class="line">this.src=&quot;./default.png&quot;;</span><br><span class="line">this.onerror = null; // 添加这个防止默认图片也不存在而陷入死循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="在-Vue-中怎么使用-onerror"><a href="#在-Vue-中怎么使用-onerror" class="headerlink" title="在 Vue 中怎么使用 onerror"></a>在 Vue 中怎么使用 onerror</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;img :src=&quot;item.imgUrl&quot; :onerror=&quot;defaultImg&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line"> data () &#123;</span><br><span class="line"> return &#123;</span><br><span class="line"> defaultImg: &apos;this.src=&quot;./static/images/default.png&quot;&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>有时因为网络比较卡的原因需要多加载几次再判定为是否加载失败。<br>但是有时是因为网络连接断开而加载失败，需要在网络恢复连接时自动加载图片。<br>这是就需要知道，js中怎么识别网络断开和连接的，有两个事件：<code>online</code> 和 <code>offline</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">var isOnLine = true;</span><br><span class="line">var eventList = &#123;&#125;;</span><br><span class="line">window.addEventListener(&apos;offline&apos;, function() &#123;</span><br><span class="line">isOnLine = false;</span><br><span class="line">&#125;)</span><br><span class="line">window.addEventListener(&apos;online&apos;, function() &#123;</span><br><span class="line">if(!isOnline) &#123;</span><br><span class="line">isOnLine = true;</span><br><span class="line">reLine(); // 执行重连后要做的事情 </span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">function reLine() &#123;</span><br><span class="line">for(var key in eventList) &#123;</span><br><span class="line">if(!eventList[key]) continue;</span><br><span class="line">var arg = eventList[key].arg;</span><br><span class="line">var thisOnFn = eventList[key].that;</span><br><span class="line">eventList[key].fun.apply(thisOnFn, arg);</span><br><span class="line">eventList[key] = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">function offLined(fun, arg, that) &#123;</span><br><span class="line">if(!isOnLine) &#123;</span><br><span class="line">var name = fun.name || &apos;__new&apos;;</span><br><span class="line">eventList[name] = &#123;&#125;;</span><br><span class="line">eventList[name].fun = fun;</span><br><span class="line">eventList[name].arg = [].slice.call(arg);</span><br><span class="line">eventList[name].that = that;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// 重新定义myfunction</span><br><span class="line">myfunction(imgObj, imgSrc, maxErrorNum) &#123;</span><br><span class="line">if(offLined(restImgUrl, arguments, this)) return;</span><br><span class="line">if(maxErrorNum &gt; 0) &#123;</span><br><span class="line">imgObj.onerror = function () &#123;</span><br><span class="line">myFunction(imgObj, imgSrc, maxErrorNum - 1)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">imgObj.src = imgSrc;</span><br><span class="line">&#125;, 500)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">imgObj.src = &apos;./default.png&apos;;</span><br><span class="line">this.onerror = null;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">&lt;img src=&quot;img.png&quot; onerror=&quot;myfunction(this, this.src, 3)&quot;&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js如何获取网页元素的绝对位置</title>
      <link href="/2018/11/25/js%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE/"/>
      <url>/2018/11/25/js%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是网页元素的绝对位置和相对位置"><a href="#什么是网页元素的绝对位置和相对位置" class="headerlink" title="什么是网页元素的绝对位置和相对位置"></a>什么是网页元素的绝对位置和相对位置</h1><p>网页元素的绝对位置，是指该元素的左上角相对于整张网页的左上角的坐标。<br>网页元素的相对位置，是指该元素的左上角相对于视口的左上角的坐标。</p><h1 id="如何获取绝对位置"><a href="#如何获取绝对位置" class="headerlink" title="如何获取绝对位置"></a>如何获取绝对位置</h1><a id="more"></a><p>由于每个元素都有 offsetTop 和 offsetLeft 属性， 表示该元素左上角与父容器（offsetParent对象）左上角的距离。<br>所以可以遍历一下元素的祖先容器，把所有的 offsetTop 加起来得到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&apos;article_container&apos;)</span><br><span class="line">var actualTop = element.offsetTop; // 绝对位置</span><br><span class="line">var current = element.offsetParent;</span><br><span class="line">while (current !== null)&#123;</span><br><span class="line">　　actualTop += current.offsetTop;</span><br><span class="line">　　current = current.offsetParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="如何获取相对位置"><a href="#如何获取相对位置" class="headerlink" title="如何获取相对位置"></a>如何获取相对位置</h1><p>有了绝对位置，获得相对位置就容易了，可以通过绝对坐标减去页面滚动条滚动的距离来得到。<br>滚动条滚动的垂直距离，是 document 对象的 scrollTop 属性，滚动的水平距离，是 document 对象的 scrollLeft 属性。scrollTop 和 scrollLeft 是可以赋值的，并且会立即自动滚动网页到相应位置。可以利用它们改变元素的相对位置。另外，elment.scrollIntoView() 方法也有类似作用，可以使网页元素出现在浏览器窗口的左上角（不过需要在支持 html5 的浏览器才能生效）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var elementScrollTop = document.documentElement.scrollTop; </span><br><span class="line">var relativeTop = actualTop-elementScrollTop; // 相对位置</span><br></pre></td></tr></table></figure></p><h1 id="快速获取元素的绝对位置和相对位置"><a href="#快速获取元素的绝对位置和相对位置" class="headerlink" title="快速获取元素的绝对位置和相对位置"></a>快速获取元素的绝对位置和相对位置</h1><p>使用 js 的 getBoundingClientRect() 方法。她会返回一个对象，包含 left， right， top， bottom 四个属性，分别对应该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var dom = document.getElementById(&apos;article_container&apos;);</span><br><span class="line">// 相对位置</span><br><span class="line">var rLeft = dom.getBoundingClientRect().left;</span><br><span class="line">var rTop = dom.getBoundingClientRect().top;</span><br><span class="line"></span><br><span class="line">// 绝对位置（相对位置+滚动距离）</span><br><span class="line">var aLeft = rLeft + document.documentElement.scrollLeft;</span><br><span class="line">var aTop = rTop + document.documentElement.scrollTop;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacBook 常用快捷键</title>
      <link href="/2018/11/25/MacBook-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/11/25/MacBook-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="1-新建一个-Tab-样式的终端窗口"><a href="#1-新建一个-Tab-样式的终端窗口" class="headerlink" title="1. 新建一个 Tab 样式的终端窗口"></a>1. 新建一个 Tab 样式的终端窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + T</span><br></pre></td></tr></table></figure><h3 id="2-自带的截图快捷键"><a href="#2-自带的截图快捷键" class="headerlink" title="2. 自带的截图快捷键"></a>2. 自带的截图快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command + Shift + 3 截取整个屏幕，保存图片在桌面</span><br><span class="line">Command + Shift + 4 选取部分屏幕区域，保存图片在桌面</span><br><span class="line">先Command + Shift + 4 再空格， 可以对指定的窗口或者菜单截屏</span><br><span class="line">以上快捷键，加上 Control， 可以把截图保存在剪切板</span><br></pre></td></tr></table></figure><h3 id="3-锁屏"><a href="#3-锁屏" class="headerlink" title="3. 锁屏"></a>3. 锁屏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + Control + q</span><br></pre></td></tr></table></figure><h3 id="4-呼出-Emoji-键盘"><a href="#4-呼出-Emoji-键盘" class="headerlink" title="4. 呼出 Emoji 键盘"></a>4. 呼出 Emoji 键盘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + Control + 空格</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">option + command + f 进入全屏模式</span><br><span class="line">command + delete 删除至行首</span><br><span class="line">option + delete 删除一个单词</span><br><span class="line">command + o 打开文件 command + ↑ 上级目录</span><br><span class="line">command + 空格: 打开Spotlight（本地搜索引擎）</span><br><span class="line">option + command + esc 打开强制关闭控制面板（很有用）</span><br><span class="line">fn + F11 显示桌面</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> MacBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git log高级使用</title>
      <link href="/2018/11/24/git-log%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/11/24/git-log%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git log 是我们经常使用的git命令之一，它可以展示分支上的历史提交信息。但是除了 git log 这一个命令，其实它还为我们提供了很多辅助的参数来从不同维度展示我们需要的日志信息，包括展示格式、只看某个分支的日志，只看某个用户提交的日志，只看某个文件上的提交等等，有的时候，这些方法可以帮助我们快速地定位问题。</p></blockquote><a id="more"></a><h2 id="git-log-选项"><a href="#git-log-选项" class="headerlink" title="git log 选项"></a>git log 选项</h2><table><thead><tr><th>选项</th><th>说明</th><th>举例 </th></tr></thead><tbody><tr><td>-n</td><td>查看最近n次的提交信息</td><td>git log -2 #查看最近2次提交记录</td></tr><tr><td>-p</td><td>查看具体的修改diff</td><td>git log -p src/index.js #显示某个文件每次提交的diff；git log -p commit-id #显示某次提交的diff</td></tr><tr><td>–stat</td><td>查看提交的修改文件列表</td><td>git log -2 –stat #查看最近两次提交的修改文件列表表</td></tr><tr><td>–shortstat</td><td>只显示 –stat 中最后的行数和修改添加移除的统计</td><td></td></tr><tr><td>–filename</td><td>查看指定文件的提交信息，文件名要放到参数的最后位置，通常在前面加上 <code>--</code> 并用空格隔开表示是文件。</td><td>git log – file1 file2</td></tr><tr><td>branchname</td><td>查看某个分支上的提交记录</td><td>git log dev</td></tr><tr><td>tagName</td><td>查询指定标签的提交记录</td><td>git log v1.0.. #查询从v1.0以后的提交历史记录(不包含v1.0)</td></tr><tr><td>–grep</td><td>仅显示含指定关键字的提交</td><td></td></tr><tr><td>–S</td><td>仅展示添加或者移除了某个关键字的提交</td><td></td></tr><tr><td>–author</td><td>查询指定作者的提交记录</td><td>git log –author=sam</td></tr><tr><td>–commiter</td><td>查询指定提交者的提交记录</td><td>git log –commiter=sam</td></tr><tr><td>–grep</td><td>通过关键字过滤提交日志</td><td>git log –grep=mod  #列出所有包含 mod 字样提交信息的记录</td></tr><tr><td>–graph</td><td>显示ASCLL码图形表示的分支河滨管理师</td><td>git log –graph</td></tr></tbody></table><h3 id="git-log-过滤分支"><a href="#git-log-过滤分支" class="headerlink" title="git log 过滤分支"></a>git log 过滤分支</h3><p>git log test..master 查询master分支中的提交记录但不包含test分支记录<br>git log master..test 查询test分支中的提交记录但不办含master分支记录<br>git log master…test 查询master或test分支中的提交记录。<br>git log test –not master 屏蔽master分支</p><h3 id="根据-commit-id-或者-HEAD-查询日志"><a href="#根据-commit-id-或者-HEAD-查询日志" class="headerlink" title="根据 commit id 或者 HEAD 查询日志"></a>根据 commit id 或者 HEAD 查询日志</h3><p>commit id 可以是提交哈希的简写模式，也可以使用HEAD替代。HEAD指向当前分支，HEAD^为最后一个提交，等同于HEAD~1,HEAD~2代表倒数第二次提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log f52c471</span><br><span class="line">git show f52c471 filename #只看某个条中某个文件的变化</span><br><span class="line">git show -s --pretty=raw f52c471 #查看某个提交</span><br></pre></td></tr></table></figure></p><h3 id="git-其他查看某个文件修改历史的命令"><a href="#git-其他查看某个文件修改历史的命令" class="headerlink" title="git 其他查看某个文件修改历史的命令"></a>git 其他查看某个文件修改历史的命令</h3><table><thead><tr><th>选项</th><th>说明</th><th>举例 </th></tr></thead><tbody><tr><td>show</td><td>查看某次提交的修改(查看diff)</td><td>git show <commit id=""> –stat #–stat 可以不加</commit></td></tr><tr><td>blame</td><td>显示文件的每一行是在哪个版本最后修改的</td><td>git blame filename</td></tr><tr><td>whatchanged</td><td>显示某个文件的每个版本提交信息：提交日期、提交人员、版本号、提交备注</td><td>git whatchanged filename</td></tr></tbody></table><h3 id="–pretty-按指定格式显示日志信息"><a href="#–pretty-按指定格式显示日志信息" class="headerlink" title="–pretty 按指定格式显示日志信息"></a>–pretty 按指定格式显示日志信息</h3><p>可选项有：</p><p><code>oneline</code>, <code>short</code>, <code>medium</code>, <code>full</code>, <code>fuller</code>, <code>email</code>, <code>raw</code>, <code>format</code><br>默认为medium，可以通过修改配置文件来指定默认的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log (--pretty=)oneline</span><br></pre></td></tr></table></figure></p><p>常见的 format 选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">选项  说明</span><br><span class="line">%H  提交对象（commit）的完整哈希字串 </span><br><span class="line">%h  提交对象的简短哈希字串 </span><br><span class="line">%T  树对象（tree）的完整哈希字串 </span><br><span class="line">%t  树对象的简短哈希字串 </span><br><span class="line">%P  父对象（parent）的完整哈希字串 </span><br><span class="line">%p  父对象的简短哈希字串 </span><br><span class="line">%an 作者（author）的名字 </span><br><span class="line">%ae 作者的电子邮件地址 </span><br><span class="line">%ad 作者修订日期（可以用 -date= 选项定制格式） </span><br><span class="line">%ar 作者修订日期，按多久以前的方式显示 </span><br><span class="line">%cn 提交者(committer)的名字 </span><br><span class="line">%ce 提交者的电子邮件地址 </span><br><span class="line">%cd 提交日期 </span><br><span class="line">%cr 提交日期，按多久以前的方式显示 例如：1 day ago</span><br><span class="line">%ci 提交日期，按ISO 8601 格式显示 例如：2021-02-04 23:00:45 +0800</span><br><span class="line">%s  subject 提交说明</span><br><span class="line">%d  body</span><br></pre></td></tr></table></figure></p><p>事例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format:&quot;$h %cn %cr %s&quot;</span><br><span class="line">// 或者</span><br><span class="line">git log --format=&quot;$h %cn %cr %s&quot;</span><br></pre></td></tr></table></figure></p><h3 id="自定义-git-log-–format-后输出内容的颜色"><a href="#自定义-git-log-–format-后输出内容的颜色" class="headerlink" title="自定义 git log –format 后输出内容的颜色"></a>自定义 git log –format 后输出内容的颜色</h3><p><code>git log --format</code> 后，输出的内容是没有颜色区分的，我们其实是可以给输出的内容自定义颜色，便于让内容更有辨识度。<br>方法为在 format 的内容选项前，加上 %C() 选项。其中:</p><ol><li>括号内放代表颜色的字符串，颜色字符串支持24位的RGB值（要带#号）</li><li>也可以是以下的颜色名称：<ul><li>normal</li><li>black</li><li>red</li><li>green</li><li>yellow</li><li>blue</li><li>magenta</li><li>cyan</li><li>white</li></ul></li><li>这些颜色名称还可以跟这些修饰属性绑定使用，可叠加多个使用。注意，这些修饰只能修饰前景色：<ul><li>bold    // 加粗</li><li>dim     // 颜色减淡</li><li>ul      // 下划线</li><li>blink   // 闪烁效果</li><li>reverse // 前景色背景色交换</li></ul></li><li>也可以放两个颜色字符串，第一个将被识别为前景色，第二个将被识别为背景色</li><li>在 git v1.7 版本后，对于 red、green、blue 三个颜色来说，括号是可选的。（但是这样就只能使用一个颜色，即前景色）</li><li>颜色和颜色修饰，是会传播到之后的输出内容样式，除非在内容前或者该内容后，重置颜色和修饰：%Creset。或则剔除修饰：noxxx（xxx 代表修饰名，例如nodim）。<strong>所以每设置完一个内容的颜色，最好是在该内容后紧跟一个%Creset，以防影响后面内容的样式。</strong></li><li>重置颜色和剔除修饰也是会传播的。</li></ol><h3 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h3><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --format=&quot;%C(magenta)%h %C(red)%d %C(yellow)(%cr) %C(green)%s&quot;</span><br></pre></td></tr></table></figure></p><p>效果：<br><img src="/images/git-log--format-with-color1.jpg" alt="git-log--format-with-color1"><br>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --format=&quot;%C(white ul bold magenta)%h%Creset %C(yellow)(%cr)%Creset %C(green)%s%Creset %C(dim)%cd&quot;</span><br></pre></td></tr></table></figure></p><p>效果：<br><img src="/images/git-log--format-with-color2.jpg" alt="git-log--format-with-color2"><br>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --format=&quot;%C(reverse ul black)%h%Creset %C(yellow)(%cr)%Creset %C(green)%s%Creset %C(dim)%cd&quot;</span><br></pre></td></tr></table></figure></p><p>效果：<br><img src="/images/git-log--format-with-color3.jpg" alt="git-log--format-with-color3"></p><h3 id="自定义规则快捷键——别名"><a href="#自定义规则快捷键——别名" class="headerlink" title="自定义规则快捷键——别名"></a>自定义规则快捷键——别名</h3><p>每次都要输入这一长串的命令非常繁琐且容易出错，我们可以将调整好的这一串命令保存在git配置文件里，并给它起一个别名，下次只需要输入这个别名，就可以看到符合自己习惯的日志格式和样式了。</p><ol><li>进入～／.gitconfig</li><li><p>添加：（注意，format后的值必须要用单引号，双引号会报错。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">   logs = log --format=&apos;%C(reverse ul red)%h%Creset %cn  %C(yellow)(%cr)%Creset %C(green)%s%Creset&apos;</span><br></pre></td></tr></table></figure></li><li><p>然后在命令行只需要输入 <code>git logs</code> 就可以得到你要的效果了。</p></li></ol><blockquote><p>更多详细可查看 <a href="https://git-scm.com/docs/pretty-formats" target="_blank" rel="noopener">git documentation Pretty Formats</a></p></blockquote><h3 id="–name-only-列出修改过-新增、修改、删除-的文件清单"><a href="#–name-only-列出修改过-新增、修改、删除-的文件清单" class="headerlink" title="–name-only 列出修改过(新增、修改、删除)的文件清单"></a>–name-only 列出修改过(新增、修改、删除)的文件清单</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --name-only --oneline</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">44032af (HEAD -&gt; master, origin/master) add timeout error handler</span><br><span class="line">src/utils/http.js</span><br><span class="line">92e2cf5 update readme</span><br><span class="line">README.md</span><br><span class="line">64ed4bd make http request with wrapped api function</span><br><span class="line">src/views/Home.vue</span><br><span class="line">0f0aad3 wrap apis</span><br><span class="line">src/api/home.js</span><br><span class="line">src/api/index.js</span><br><span class="line">4a14830 wrap axios</span><br><span class="line">package-lock.json</span><br><span class="line">package.json</span><br><span class="line">src/utils/http.js</span><br><span class="line">0de3bde get prepared</span><br><span class="line">.browserslistrc</span><br><span class="line">.editorconfig</span><br><span class="line">.eslintrc.js</span><br><span class="line">.gitignore</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure></p><h3 id="–name-status-列出修改过的文件和修改状态"><a href="#–name-status-列出修改过的文件和修改状态" class="headerlink" title="–name-status 列出修改过的文件和修改状态"></a>–name-status 列出修改过的文件和修改状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --name-status</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">44032af (HEAD -&gt; master, origin/master) add timeout error handler</span><br><span class="line">M       src/utils/http.js</span><br><span class="line">92e2cf5 update readme</span><br><span class="line">M       README.md</span><br><span class="line">64ed4bd make http request with wrapped api function</span><br><span class="line">M       src/views/Home.vue</span><br><span class="line">0f0aad3 wrap apis</span><br><span class="line">A       src/api/home.js</span><br><span class="line">A       src/api/index.js</span><br><span class="line">4a14830 wrap axios</span><br><span class="line">M       package-lock.json</span><br><span class="line">M       package.json</span><br><span class="line">A       src/utils/http.js</span><br><span class="line">0de3bde get prepared</span><br><span class="line">A       .browserslistrc</span><br><span class="line">A       .editorconfig</span><br><span class="line">A       .eslintrc.js</span><br><span class="line">A       .gitignore</span><br><span class="line">A       README.md</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用nvm+nrm+cmder打造灵活的前端开发环境</title>
      <link href="/2018/11/24/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8nvm-nrm-cmder%E6%89%93%E9%80%A0%E7%81%B5%E6%B4%BB%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/11/24/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8nvm-nrm-cmder%E6%89%93%E9%80%A0%E7%81%B5%E6%B4%BB%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在前端工程开发过程中，不同项目可能会使用不同的 node 环境和 npm 环境，在不同项目中切换时，要不停的卸载安装前端开发环境，非常麻烦。于是有了 nvm 和 nrm，可以通过切换的方式快速设置开发环境版本，再也不要繁琐地卸载安装了，有效的解放了劳动力。</p></blockquote><a id="more"></a><h3 id="1-nvm"><a href="#1-nvm" class="headerlink" title="1. nvm"></a>1. nvm</h3><p>nvm: node version manager<br>node 版本管理器</p><h3 id="2-nrm"><a href="#2-nrm" class="headerlink" title="2. nrm"></a>2. nrm</h3><p>nrm: npm registry manager<br>npm 版本管理器</p><p>安装 nrm：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nrm -g</span><br></pre></td></tr></table></figure></p><p>添加 registry：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm add npm http://registry.npmjs.org</span><br><span class="line">nrm add taobao https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>查看已添加的 registry：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure></p><p>切换 registry：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm use taobao</span><br><span class="line">nrm use npm</span><br></pre></td></tr></table></figure></p><h3 id="3-cmder"><a href="#3-cmder" class="headerlink" title="3. cmder"></a>3. cmder</h3><p>一款酷炫的命令行终端软件</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Intergration </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> nvm </tag>
            
            <tag> nrm </tag>
            
            <tag> cmder </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何查看和设置npm镜像地址</title>
      <link href="/2018/11/24/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%AE%BE%E7%BD%AEnpm%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80/"/>
      <url>/2018/11/24/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%AE%BE%E7%BD%AEnpm%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure><p>在输出信息中可以看到我的 npm 镜像如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">metrics-registry = &quot;https://registry.npmjs.org/&quot;</span><br><span class="line">scope = &quot;&quot;</span><br><span class="line">user-agent = &quot;npm/5.5.1 node/v8.9.3 darwin x64&quot;</span><br></pre></td></tr></table></figure></p><h3 id="设置镜像"><a href="#设置镜像" class="headerlink" title="设置镜像"></a>设置镜像</h3><p>常用的 npm 镜像地址有：<br>npm —- <a href="http://registry.npmjs.org" target="_blank" rel="noopener">http://registry.npmjs.org</a> (默认)<br>cnpm — <a href="http://r.cnpmjs.org" target="_blank" rel="noopener">http://r.cnpmjs.org</a><br>taobao - <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>nj —– <a href="https://registry.nodejitsu.com" target="_blank" rel="noopener">https://registry.nodejitsu.com</a><br>rednpm - <a href="http://registry.mirror.cqupt.edu.cn" target="_blank" rel="noopener">http://registry.mirror.cqupt.edu.cn</a><br>npmMirror <a href="https://skimdb.npmjs.com/registry" target="_blank" rel="noopener">https://skimdb.npmjs.com/registry</a><br>edunpm - <a href="http://registry.enpmjs.org" target="_blank" rel="noopener">http://registry.enpmjs.org</a></p><h4 id="1-临时使用"><a href="#1-临时使用" class="headerlink" title="1. 临时使用"></a>1. 临时使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org install xxx</span><br></pre></td></tr></table></figure><h4 id="2-持久使用"><a href="#2-持久使用" class="headerlink" title="2. 持久使用"></a>2. 持久使用</h4><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure><p>或者直接编辑 <code>~/.npmrc</code> 文件，加入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><h4 id="3-随时切换"><a href="#3-随时切换" class="headerlink" title="3. 随时切换"></a>3. 随时切换</h4><p>使用 <code>nrm</code> 管理 npm 镜像地址</p><h3 id="检测镜像是否配置成功"><a href="#检测镜像是否配置成功" class="headerlink" title="检测镜像是否配置成功"></a>检测镜像是否配置成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">npm config get disturl</span><br></pre></td></tr></table></figure><blockquote><p><code>npm info underscore</code> 或者 <code>npm info express</code> 也可以用来查看配置是否成功</p></blockquote><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config delete registry</span><br><span class="line">npm config delete disturl</span><br></pre></td></tr></table></figure><p>其他</p><h3 id="查看-npm-安装目录"><a href="#查看-npm-安装目录" class="headerlink" title="查看 npm 安装目录"></a>查看 npm 安装目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm root -g</span><br></pre></td></tr></table></figure><h3 id="查看-npm-的-prefix-和-cache-路径配置信息"><a href="#查看-npm-的-prefix-和-cache-路径配置信息" class="headerlink" title="查看 npm 的 prefix 和 cache 路径配置信息"></a>查看 npm 的 prefix 和 cache 路径配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get prefix</span><br><span class="line">npm config get cache</span><br></pre></td></tr></table></figure><p>安装 node.js 时会自动安装 npm， 默认的缓存路径是 %appdata%\Roaming\npm-cache</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> NPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git如何去掉对文件的追踪</title>
      <link href="/2018/11/24/git%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%BD%E8%B8%AA/"/>
      <url>/2018/11/24/git%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<p>去掉对某些文件的 track：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;file path&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让commit信息带图标</title>
      <link href="/2018/11/24/%E5%A6%82%E4%BD%95%E8%AE%A9commit%E4%BF%A1%E6%81%AF%E5%B8%A6%E5%9B%BE%E6%A0%87/"/>
      <url>/2018/11/24/%E5%A6%82%E4%BD%95%E8%AE%A9commit%E4%BF%A1%E6%81%AF%E5%B8%A6%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git commit 的提交日志上，除了文字，还可以有图标。叫做 git commit emoji。</p></blockquote><a id="more"></a> <p>提交事例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;:tada: Made some changes&quot;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="/images/git-commit-emoji.jpg" alt="git-commit-emoji"></p><h3 id="commit-格式规范："><a href="#commit-格式规范：" class="headerlink" title="commit 格式规范："></a>commit 格式规范：</h3><ol><li>message 摘要不超过50个字，首字母大写，使用祈使语气，句末不要加句号</li><li>引用相关 <code>issue</code> 或 <code>PR</code> 编号 <code>&lt;#110&gt;</code></li></ol><h3 id="emoji-代码列表"><a href="#emoji-代码列表" class="headerlink" title="emoji 代码列表"></a>emoji 代码列表</h3><table><thead><tr><th>emoji</th><th>emoji代码</th><th>语义</th></tr></thead><tbody><tr><td>:tada:(庆祝)</td><td><code>:tada:</code></td><td>初次提交</td></tr><tr><td>:sparkles: (火花)</td><td><code>:sparkles:</code></td><td>引入新功能</td></tr><tr><td>:bookmark: (书签)</td><td><code>:bookmark:</code></td><td>发行/版本标签</td></tr><tr><td>:bug: (bug)</td><td><code>:bug:</code></td><td>修复 bug</td></tr><tr><td>:ambulance: (急救车)</td><td><code>:ambulance:</code></td><td>重要补丁</td></tr><tr><td>:globe_with_meridians: (地球)</td><td><code>:globe_with_meridians:</code></td><td>国际化与本地化</td></tr><tr><td>:lipstick: (口红)</td><td><code>:lipstick:</code></td><td>更新 UI 和样式文件</td></tr><tr><td>:rotating_light: (警车灯)</td><td><code>:rotating_light:</code></td><td>移除 linter 警告</td></tr><tr><td>:wrench: (扳手)</td><td><code>:wrench:</code></td><td>修改配置文件</td></tr><tr><td>:heavy_plus_sign: (加号)</td><td><code>:heavy_plus_sign:</code></td><td>增加一个依赖</td></tr><tr><td>:heavy_minus_sign: (减号)</td><td><code>:heavy_minus_sign:</code></td><td>减少一个依赖</td></tr><tr><td>:arrow_up: (上升箭头)</td><td><code>:arrow_up:</code></td><td>升级依赖</td></tr><tr><td>:arrow_down: (下降箭头)</td><td><code>:arrow_down:</code></td><td>降级依赖</td></tr><tr><td>:zap: (闪电)<br>:racehorse: (赛马)</td><td><code>:zap:</code><br><code>:racehorse:</code></td><td>提升性能</td></tr><tr><td>:chart_with_upwards_trend: (上升趋势图)</td><td><code>:chart_with_upwards_trend:</code></td><td>添加分析或跟踪代码</td></tr><tr><td>:rocket: (火箭)</td><td><code>:rocket:</code></td><td>部署功能</td></tr><tr><td>:white_check_mark: (白色复选框)</td><td><code>:white_check_mark:</code></td><td>增加测试</td></tr><tr><td>:memo: (备忘录)</td><td><code>:memo:</code></td><td>撰写文档</td></tr><tr><td>:hammer: (锤子)</td><td><code>:hammer:</code></td><td>重大重构</td></tr><tr><td>:art: (调色板)</td><td><code>:art:</code></td><td>改进代码结构/代码格式</td></tr><tr><td>:fire: (火焰)</td><td><code>:fire:</code></td><td>移除代码或文件</td></tr><tr><td>:pencil2: (铅笔)</td><td><code>:pencil2:</code></td><td>修复 typo</td></tr><tr><td>:construction: (施工)</td><td><code>:construction:</code></td><td>工作进行中</td></tr><tr><td>:construction_worker: (工人)</td><td><code>:construction_worker:</code></td><td>添加 CI 构建系统</td></tr><tr><td>:green_heart: (绿心)</td><td><code>:green_heart:</code></td><td>修复 CI 构建问题</td></tr><tr><td>:lock: (锁)</td><td><code>:lock:</code></td><td>修复安全问题</td></tr><tr><td>:whale: (鲸鱼)</td><td><code>:whale:</code></td><td>Docker 相关工作</td></tr><tr><td>:apple: (苹果)</td><td><code>:apple:</code></td><td>修复 macOS 下的问题</td></tr><tr><td>:penguin: (企鹅)</td><td><code>:penguin:</code></td><td>修复 Linux 下的问题</td></tr><tr><td>:checkered_flag: (旗帜)</td><td><code>:checked_flag:</code></td><td>修复 Windows 下的问题</td></tr></tbody></table><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>emoji 表情在提交代码的时候不能乱用，否则容易造成误解。为此，开源项目 <a href="https://gitmoji.carloscuesta.me" target="_blank" rel="noopener"><code>gitmoji</code></a> 专门规定了在 github 提交代码时应当遵循的 emoji 规范。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><ol><li>默认情况下在命令行中不会显示出 emoji， 仅显示 emoji 代码。不过可以使用 <a href="https://github.com/mrowa44/emojify" target="_blank" rel="noopener"><code>emojify</code></a> 使得在命令行也可以像显示 emoji，emojify 是一个 shell 脚本。(不过这个脚本已经很老了，最近更新在3年前，而且mac提示已经不支持该命令，后空再找解决方案)</li><li>另外，markdown 也有一系列支持的 emoji，<a href="https://gist.github.com/rxaviers/7360908#file-gistfile1-md" target="_blank" rel="noopener"><code>传送门</code></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js如何获取浏览器窗口大小和网页内容尺寸</title>
      <link href="/2018/11/05/js%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%E5%B0%BA%E5%AF%B8/"/>
      <url>/2018/11/05/js%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%E5%B0%BA%E5%AF%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是网页的大小和浏览器窗口"><a href="#什么是网页的大小和浏览器窗口" class="headerlink" title="什么是网页的大小和浏览器窗口"></a>什么是网页的大小和浏览器窗口</h1><ul><li>网页大小就是一张网页的全部面积，通常情况，网页大小由内容和CSS样式表决定。</li><li>浏览器窗口大小，是指浏览器窗口中看到的那部分网页面积，又叫视口（viewport）。</li></ul><h1 id="获取浏览器窗口大小"><a href="#获取浏览器窗口大小" class="headerlink" title="获取浏览器窗口大小"></a>获取浏览器窗口大小</h1><p>可以通过windows对象的 innerHeight 属性获取。<br>也可以通过元素的 clientHeight 属性获取。网页上每个元素都有 clientHeight 和 clientWidth 属性。这两个属性指元素的内容部分加上 padding 的大小，不包括 border 和滚动条的大小。<br>大部分情况下 document.documentElement 的大小可以代表浏览器窗口的大小，但是在 IE6 的 quirks 模式中，document.body 才返回正确的值。</p><p>如何获取浏览器窗口高度</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器内部界面的高度，即内容显示区域的高度，F12调试工具的占位会实时改变该值</span><br><span class="line">window.innerHeight</span><br><span class="line"></span><br><span class="line">// 浏览器外部界面即窗体的高度，调试工具的占位不会影响该值</span><br><span class="line">window.outerHeight</span><br><span class="line"></span><br><span class="line">// 表示 HTML 文档所在窗口的可视区域高度，效果同 window.innerHeight</span><br><span class="line">document.documentElement.clientHeight</span><br><span class="line"></span><br><span class="line">// ie6 quirks 模式下表示 body 的可视区域高度，注意：body与浏览器之间有个默认的 margin</span><br><span class="line">document.body.clientHeight</span><br></pre></td></tr></table></figure><p>与高度对应的，还有宽度：<code>window.innerWidth</code> 、<code>window.outerWidth</code>、<code>window.outerWidth</code>、<code>document.documentElement.clientWidth</code>、 <code>document.body.clientWidth</code></p><blockquote><p>说明：window.innerHeight ／ innderWidth 在ie8 及以下不支持，需要通过<br>document.documentElement.clientHeight ／ clientWidth 来替代。所以兼容的写法为：<br><code>window.innerHeight || document.documentElement.clientHeight</code><br><code>window.innderWidth || document.documentElement.clientWidth</code></p></blockquote><h1 id="获取网页内容大小"><a href="#获取网页内容大小" class="headerlink" title="获取网页内容大小"></a>获取网页内容大小</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement.scrollWidth || document.body.scrollWidth</span><br><span class="line">document.documentElement.scrollHeight || document.body.scrollHeight</span><br><span class="line"></span><br><span class="line">document.documentElement.offsetWidth || document.body.offSetWidth</span><br><span class="line">document.documentElement.offsetHeight || document.body.offSetHeight</span><br></pre></td></tr></table></figure><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>通常获取浏览器界面的宽高，是有自适应布局的需要，常常需要跟如下方法配合使用：</p><h3 id="1-window-的尺寸变化事件"><a href="#1-window-的尺寸变化事件" class="headerlink" title="1. window 的尺寸变化事件"></a>1. window 的尺寸变化事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// js</span><br><span class="line">window.onresize()</span><br><span class="line"></span><br><span class="line">// jquery</span><br><span class="line">$(window).resize()</span><br></pre></td></tr></table></figure><h3 id="2-window-的滚动事件"><a href="#2-window-的滚动事件" class="headerlink" title="2. window 的滚动事件"></a>2. window 的滚动事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// js</span><br><span class="line">window.onscroll()</span><br><span class="line"></span><br><span class="line">// jquery</span><br><span class="line">$(window).scroll()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows下模拟域名</title>
      <link href="/2018/10/05/windows%E4%B8%8B%E6%A8%A1%E6%8B%9F%E5%9F%9F%E5%90%8D/"/>
      <url>/2018/10/05/windows%E4%B8%8B%E6%A8%A1%E6%8B%9F%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>在 c盘下 <code>windows／system32/drivers/etc/host</code> 文件内，可以添加设置域名，将本地起的服务模拟成域名形式，便于相关前端测试，比如测试跨域。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> windows </tag>
            
            <tag> domain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速使用express搭建服务</title>
      <link href="/2018/10/05/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8express%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/10/05/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8express%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用 express 搭建最简单的服务。需要有 node 环境。</p></blockquote><h4 id="1-安装-express"><a href="#1-安装-express" class="headerlink" title="1. 安装 express"></a>1. 安装 express</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure><h4 id="2-编写最简单的服务"><a href="#2-编写最简单的服务" class="headerlink" title="2. 编写最简单的服务"></a>2. 编写最简单的服务</h4><ul><li>新建 server.js 文件</li><li>打开 server.js 文件，写入：</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;); //引入 express</span><br><span class="line">const app = express(); //执行一下 express</span><br><span class="line">app.use(express.static(__dirname)); //指定静态文件路径</span><br><span class="line">app.listen(3000); //指定监听端口</span><br></pre></td></tr></table></figure><h4 id="3-起服务"><a href="#3-起服务" class="headerlink" title="3. 起服务"></a>3. 起服务</h4><p>命令行进入 server.js 所在目录，然后执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure></p><h4 id="4-done！"><a href="#4-done！" class="headerlink" title="4. done！"></a>4. done！</h4><p>服务已经启动，在浏览器输入 <code>http://localhost:3000</code> 就可以访问页面了。</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="1-添加接口路由"><a href="#1-添加接口路由" class="headerlink" title="1. 添加接口路由"></a>1. 添加接口路由</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//get 请求，访问地址为 `http://localhost:3000/users`</span><br><span class="line">app.get(&apos;/users&apos;, function(req, res) &#123;</span><br><span class="line">res.end(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//put 请求，访问地址为 `http://localhost:3000/users`</span><br><span class="line">app.put(&apos;/users&apos;, function(req, res) &#123;</span><br><span class="line">res.end(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-设置响应头"><a href="#2-设置响应头" class="headerlink" title="2. 设置响应头"></a>2. 设置响应头</h4><p>根据需要，有时得设置响应头，以达到某种目的，比如跨域。<br>在 server.js 文件的定义变量之后，添加一个 app.use：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">//允许哪个源可以访问我</span><br><span class="line">res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://localhost:4000&apos;);</span><br><span class="line"></span><br><span class="line">//允许携带哪个头访问我，多个头，用英文逗号隔开</span><br><span class="line">res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;name&apos;);</span><br><span class="line"></span><br><span class="line">//允许哪个方法访问我</span><br><span class="line">res.setHeader(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT&apos;);</span><br><span class="line"></span><br><span class="line">//允许携带 cookie 访问我</span><br><span class="line">res.setHeader(&apos;Access-Control-Allow-Credentials&apos;, true);</span><br><span class="line"></span><br><span class="line">//允许前端访问哪个头，多个头，用英文逗号隔开</span><br><span class="line">res.setHeader(&apos;Access-Control-Expose-Headers&apos;, &apos;name&apos;);</span><br><span class="line">next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2018/10/05/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2018/10/05/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>浏览器同源策略：<br>请求的地址与平台的协议、域名、端口号，都一致，称为 <code>同域</code>。<br>只要有一个不一样，就称为 <code>跨域</code>。</p><p>cookie、 Localstorage 不能跨域；<br>DOM元素也有同源策略（iframe）；<br>ajax 也不支持跨域。</p><p>可以跨域的 html 标签：<br><code>link</code>、 <code>img</code>、 <code>script</code></p><p>如何实现跨域：</p><ol><li>jsonp</li><li>cors</li><li>postMessage</li><li>document.domain</li><li>window.name</li><li>location.hash</li><li>http-proxy</li><li>ngix</li><li>WebSocket</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用gitbook发布自己的书籍</title>
      <link href="/2018/10/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gitbook%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
      <url>/2018/10/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gitbook%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B9%A6%E7%B1%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>利用开源项目 gitbook，自己写本书吧～</p><p>前言：gitbook 平台在今年的4月9日发布了新的版本v2。新的版本官网已经变成 <a href="www.gitbook.com"><code>www.gitbook.com</code></a> （旧的地址为 <a href="legacy.gitbook.com"><code>legacy.gitbook.com</code></a> ）。新旧版本有很多的不一样，网上很多资料都是针对旧版。 比如新版不再支持把每本书作为一个 <code>Git Repository</code> 来进行版本管理。（以前是可以针对每本书从本地 <code>git push</code> 到 gitbook 的），这点也是坑了我很久（坑一个强迫症重度患者的结果就是，不扒出被坑的根本原因誓不罢休）。更多 v2 的重大改变可以看 <a href="https://docs.gitbook.com/v2-changes/important-differences" target="_blank" rel="noopener">这里</a>。</p></blockquote><p>以下的所有操作都是针对新版的 gitbook。</p><a id="more"></a><p>使用 gitbook 编写一本书的步骤如下：</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="1-全局安装-gitbook-cli"><a href="#1-全局安装-gitbook-cli" class="headerlink" title="1. 全局安装 gitbook-cli"></a>1. 全局安装 gitbook-cli</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-cli -g</span><br></pre></td></tr></table></figure><h3 id="2-查看-gitbook-版本"><a href="#2-查看-gitbook-版本" class="headerlink" title="2. 查看 gitbook 版本"></a>2. 查看 gitbook 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook --version</span><br></pre></td></tr></table></figure><p>  我在查看 gitbook 版本的时候，他会自动安装一些插件，等了一会安装完才出的版本信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLI version: 2.3.2</span><br><span class="line">GitBook version: 3.2.3</span><br></pre></td></tr></table></figure></p><h3 id="3-初始化-gitbook"><a href="#3-初始化-gitbook" class="headerlink" title="3. 初始化 gitbook"></a>3. 初始化 gitbook</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></figure><h3 id="4-编辑书籍"><a href="#4-编辑书籍" class="headerlink" title="4. 编辑书籍"></a>4. 编辑书籍</h3><ul><li><p>一个 gitbook 项目至少要包含 README.md 和 SUMMARY.md，书本的第一页内容是从文件 README.md 文件中提取的。如果这个文件名没有出现在 SUMMARY.md 文件中，则它会被添加为章节的第一个条目。而由于一些托管在 github 上的书更喜欢将 README.md 作为项目的介绍而不是书的介绍，从 gitbook v2 起，可以在 book.json 中指定某个文件作为 README。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;structure&quot;: &#123;</span><br><span class="line">&quot;readme&quot;: &quot;myIntro.md&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>gitbook 使用文件 SUMMARY.md 来定义书本的章节和子章节的结构。它用来生成书本内容的预览表。它的格式是一个简单的链接列表。另外可以在里面添加一些 markdown 格式的标题和分割线。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 概要</span><br><span class="line">* [章节 1](chapter1.md)</span><br><span class="line">* [章节 2](chapter2.md)</span><br><span class="line">* [章节 3](chapter3.md)</span><br><span class="line"></span><br><span class="line"># 基础</span><br><span class="line">* [章节 1](chapter1/README.md)</span><br><span class="line">  * [1.1 a](chapter1/a.md)</span><br><span class="line">  * [1.2 b](chapter1/b.md)</span><br><span class="line">---</span><br><span class="line">* [章节 2](chapter2/README.md)</span><br><span class="line">  * [2.1 c](chapter2/c.md)</span><br><span class="line">  * [2.2 d](chapter2/d.md)</span><br><span class="line"></span><br><span class="line"># 进阶</span><br><span class="line">* [章节 3](chapter3/README.md)</span><br></pre></td></tr></table></figure></li><li><p>编写文章内容<br>接下来就可以在相应的 md 文件里书写内容了。</p></li></ul><h3 id="5-启动-gitbook-本地服务"><a href="#5-启动-gitbook-本地服务" class="headerlink" title="5. 启动 gitbook 本地服务"></a>5. 启动 gitbook 本地服务</h3><p>写完内容，可以通过以下方式来预览书本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></figure></p><p>  <code>gitbook serve</code> 命令实际上是先调用 <code>gitbook build</code> 编译书籍，然后启动一个 web 服务器，监听在本地的4000端口。</p><h2 id="gitbook-进阶"><a href="#gitbook-进阶" class="headerlink" title="gitbook 进阶"></a>gitbook 进阶</h2><p>以上所说的都是在本地的操作，如何让别人也可以访问自己的书籍，除了自己买域名，还可以利用现有的互联网平台：gitbook.com、 github.com、 gitlab.com（gitlab也是听说可以有 gitlab pages，没有实际操作过，先略过）</p><h3 id="1-在-gitbook-com-上发布和管理书籍"><a href="#1-在-gitbook-com-上发布和管理书籍" class="headerlink" title="1. 在 gitbook.com 上发布和管理书籍"></a>1. 在 gitbook.com 上发布和管理书籍</h3><ul><li>需要先注册 gitbook 账号。可以单独注册，也可以使用 github 账号关联登录。</li><li>然后先创建一个 Orgnization 。</li><li>再在这个 Orgnization 里面创建一个 Space（旧版叫 Book）。这个就是你的书籍项目了。</li><li>然后就可以在线写书了～书籍的在线浏览地址为：<code>https://yourorgnizationname.gitbook.io/yourspacename</code></li></ul><h3 id="2-在-github-com-上发布和管理书籍"><a href="#2-在-github-com-上发布和管理书籍" class="headerlink" title="2. 在 github.com 上发布和管理书籍"></a>2. 在 github.com 上发布和管理书籍</h3><p>在前面说的本地操作，编辑和预览书籍后，可以把 build 之后的结果，上传到 github 上面，然后利用 github pages 来发布书籍。</p><ul><li>首先在 github 上新建一个跟你的书籍同名的 repository。</li><li>然后将远程仓库地址添加到本地，然后将编译后的 <code>_book</code> 目录 push 到远程。</li><li>然后在 github 上设置一下 github pages，具体方法和步骤我在另一个文章中详细介绍过：<a href="https://yc111.github.io/2018/10/05/如何给github项目建立自己的主页/" target="_blank" rel="noopener">如何给github项目建立自己的主页</a>。</li><li>在设置完后，就可以通过 <code>https://githubusername.github.io/projectname</code> 来浏览你的书了。</li></ul><h3 id="3-gitbook-与-github-关联同步"><a href="#3-gitbook-与-github-关联同步" class="headerlink" title="3. gitbook 与 github 关联同步"></a>3. gitbook 与 github 关联同步</h3><p>新版 gitbook.com 不支持本地版本管理了，但是对 github 的集成支持的不错。可以通过配置，实现在 github 项目里面提交内容，gitbook 平台会自动同步过去。</p><ul><li>在 gitbook 平台里，进入要设置的 space，也就是你的书。</li><li>点左下角的配置按钮，进入配置，点击 Intergrations ，找到 github。</li><li>点击 link you github repository 按钮，根据向导，登录 github ，选择 reposirory，选择分支，完成绑定和同步。(你还可以选择是 gitbook 同步 github ，还是 github 同步 gitbook)<blockquote><p>需要注意的是：绑定的 github 仓库分支里面要是 gitbook 的源码，也就是那些 md 文件。而不是 build 之后生成的 html 文件。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> GitBook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何给github项目建立自己的主页</title>
      <link href="/2018/10/05/%E5%A6%82%E4%BD%95%E7%BB%99github%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/"/>
      <url>/2018/10/05/%E5%A6%82%E4%BD%95%E7%BB%99github%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>想给 github 项目发布一个可访问的地址，网上的资料虽然多，但是乱。总的来讲，分为两种方法：一种是通过 github 的 <a href="https://htmlpreview.github.io/" target="_blank" rel="noopener"><code>htmlpreview</code></a> 插件来展示。另一种就是通过 github pages 来展示。关于 github pages 网上很多人对它有误解，认为一定要先创建 <code>username.github.io</code> 这个 repository 才可以，其实并不需要；还有人认为一定要把要展示的静态资源放在项目的 gh-pages 分支上才可以，其实也不用。</p></blockquote><p>总结一下我利用 github pages 给自己的项目创建主页的方法。</p><p>步骤如下：</p><a id="more"></a><h4 id="1-在-github-上建立项目-repository。"><a href="#1-在-github-上建立项目-repository。" class="headerlink" title="1. 在 github 上建立项目 repository。"></a>1. 在 github 上建立项目 repository。</h4><h4 id="2-进入该-repository-的-Settings。"><a href="#2-进入该-repository-的-Settings。" class="headerlink" title="2. 进入该 repository 的 Settings。"></a>2. 进入该 repository 的 Settings。</h4><h4 id="3-在-Options-里面，-找到-GitHub-Pages。"><a href="#3-在-Options-里面，-找到-GitHub-Pages。" class="headerlink" title="3. 在 Options 里面， 找到 GitHub Pages。"></a>3. 在 Options 里面， 找到 GitHub Pages。</h4><h4 id="4-为项目选择用于主页的分支，-然后保存。"><a href="#4-为项目选择用于主页的分支，-然后保存。" class="headerlink" title="4. 为项目选择用于主页的分支， 然后保存。"></a>4. 为项目选择用于主页的分支， 然后保存。</h4><h4 id="5-然后就可以在浏览器输入-https-username-github-io-projectname-来访问项目主页了。"><a href="#5-然后就可以在浏览器输入-https-username-github-io-projectname-来访问项目主页了。" class="headerlink" title="5. 然后就可以在浏览器输入 https://username.github.io/projectname 来访问项目主页了。"></a>5. 然后就可以在浏览器输入 <a href="https://username.github.io/projectname" target="_blank" rel="noopener">https://username.github.io/projectname</a> 来访问项目主页了。</h4><blockquote><p>当然前提是在该分支下有用于展示的 html 文件，比如 index.html</p></blockquote><hr><p>另附上 github 的 <code>htmlpreview</code> 地址：<br><a href="https://htmlpreview.github.io/" target="_blank" rel="noopener">https://htmlpreview.github.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> github pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在mac上查看隐藏文件</title>
      <link href="/2018/10/05/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"/>
      <url>/2018/10/05/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在 Finder 里，按 <code>Cmd + Shift + .</code> 即可切换隐藏文件的显隐。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶(三)：博客域名升级</title>
      <link href="/2018/09/29/%E8%BF%9B%E9%98%B6-%E4%B8%89-%EF%BC%9A%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E5%8D%87%E7%BA%A7/"/>
      <url>/2018/09/29/%E8%BF%9B%E9%98%B6-%E4%B8%89-%EF%BC%9A%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<ol><li>购买域名，我是在阿里云上购买的，.com域名。<ul><li>先查询你想的域名是否已经被注册，如果有那就要另想一个了。</li><li>选择购买时长，一次买长一点的好像比一年一年买要划得来，而且也不容易被别人抢注。</li><li>然后购买，购买前要实名认证。</li></ul></li><li>配置DNS，添加记录，将github page域名添加进去。</li><li>github上配置custom domain，设置为新购买的域名。</li><li>hexo source里添加CNAME文件，内容为新购买的域名。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> domain </tag>
            
            <tag> hexo </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用json-server+faker模拟API服务和数据</title>
      <link href="/2018/09/26/%E5%88%A9%E7%94%A8json-server-faker%E6%A8%A1%E6%8B%9FAPI%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/09/26/%E5%88%A9%E7%94%A8json-server-faker%E6%A8%A1%E6%8B%9FAPI%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> json-sever </tag>
            
            <tag> faker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中的Date</title>
      <link href="/2018/09/26/javascript%E4%B8%AD%E7%9A%84Date/"/>
      <url>/2018/09/26/javascript%E4%B8%AD%E7%9A%84Date/</url>
      
        <content type="html"><![CDATA[<h2 id="chrome下"><a href="#chrome下" class="headerlink" title="chrome下"></a>chrome下</h2><p>结论：</p><h4 id="1-日期有前置0，则会解析为-UTC-时间，没有前置0，则会解析为本地时间。"><a href="#1-日期有前置0，则会解析为-UTC-时间，没有前置0，则会解析为本地时间。" class="headerlink" title="1. 日期有前置0，则会解析为 UTC 时间，没有前置0，则会解析为本地时间。"></a>1. 日期有前置0，则会解析为 UTC 时间，没有前置0，则会解析为本地时间。</h4><p>例如<br><code>new Date(&#39;2018-09-26&#39;).getTime()</code> 获取的是距离1970年1月1日0点UTC时间。<br><code>new Date(&#39;2018-9-26&#39;).getTime()</code> 获取的是距离1970年1月1日0点本地时间。</p><h4 id="2-Date-now-、-new-Date-、-new-Date-getTime-获取的都是距离1970年1月1日0点本地时间。"><a href="#2-Date-now-、-new-Date-、-new-Date-getTime-获取的都是距离1970年1月1日0点本地时间。" class="headerlink" title="2. Date.now()、 +new Date()、 new Date().getTime(), 获取的都是距离1970年1月1日0点本地时间。"></a>2. <code>Date.now()</code>、 <code>+new Date()</code>、 <code>new Date().getTime()</code>, 获取的都是距离1970年1月1日0点本地时间。</h4><blockquote><p>检验依据：<code>Date.UTC()</code> 该方法使用的是UTC时间。而 <code>Date.UTC(2018, 8, 26)</code> 跟 <code>Date.now()</code>、 <code>+new Date()</code>、 <code>new Date().getTime()</code> 获得的值相差8个小时。</p></blockquote><h2 id="ie下"><a href="#ie下" class="headerlink" title="ie下"></a>ie下</h2><a id="more"></a><p>结论：</p><h4 id="1-不支持非UTC格式的-new-Date"><a href="#1-不支持非UTC格式的-new-Date" class="headerlink" title="1. 不支持非UTC格式的 new Date()."></a>1. 不支持非UTC格式的 <code>new Date()</code>.</h4><h4 id="2-并且-Date-now-、-new-Date-、-new-Date-getTime-获取的都是距离1970年1月1日0点的UTC时间。"><a href="#2-并且-Date-now-、-new-Date-、-new-Date-getTime-获取的都是距离1970年1月1日0点的UTC时间。" class="headerlink" title="2. 并且 Date.now()、 +new Date()、 new Date().getTime() 获取的都是距离1970年1月1日0点的UTC时间。"></a>2. 并且 <code>Date.now()</code>、 <code>+new Date()</code>、 <code>new Date().getTime()</code> 获取的都是距离1970年1月1日0点的UTC时间。</h4><blockquote><p>检验依据：而 <code>Date.UTC(2018, 8, 26)</code> 跟 <code>Date.now()</code>、 <code>+new Date()</code>、 <code>new Date().getTime()</code> 获得的值在同一个时区。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10下中文输入法简繁切换快捷键</title>
      <link href="/2018/09/26/win10%E4%B8%8B%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%AE%80%E7%B9%81%E5%88%87%E6%8D%A2%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/09/26/win10%E4%B8%8B%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%AE%80%E7%B9%81%E5%88%87%E6%8D%A2%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>在中文输入法下，按 ctr+shift+f 。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git reflog</title>
      <link href="/2018/09/25/git-reflog/"/>
      <url>/2018/09/25/git-reflog/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们对 git log 应该很熟悉了，它是我们常用的用来查看提交记录的命令，而对另一个查看日志的命令 git reflog，可能就不那么熟悉了。我最近因为排查一个线上bug，定位到一段代码被注释掉了，从 log 日志上看，是在一次 merge 的过程中发生的，但因为 rebase 和 amend 等命令的存在，光看 log 有的时候是不可靠的，为了进一步确认该操作是如何发生的，我用到了 git reflog。顺便把 reflog 的用法整理了一份。</p></blockquote><h2 id="git-log-VS-git-reflog"><a href="#git-log-VS-git-reflog" class="headerlink" title="git log VS git reflog"></a>git log VS git reflog</h2><blockquote><p>git log shows the current HEAD and its ancestry. That is, it prints the commit HEAD points to, then its parent, its parent, and so on. It traverses back through the repo’s ancestry, by recursively looking up each commit’s parent.</p><p>(In practice, some commits have more than one parent. To see a more representative log, use a command like git log –oneline –graph –decorate.)</p><p>git reflog doesn’t traverse HEAD’s ancestry at all. The reflog is an ordered list of the commits that HEAD has pointed to: it’s undo history for your repo. The reflog isn’t part of the repo itself (it’s stored separately to the commits themselves) and isn’t included in pushes, fetches or clones; it’s purely local.</p><p>Aside: understanding the reflog means you can’t really lose data from your repo once it’s been committed. If you accidentally reset to an older commit, or rebase wrongly, or any other operation that visually “removes” commits, you can use the reflog to see where you were before and git reset –hard back to that ref to restore your previous state. Remember, refs imply not just the commit but the entire history behind it.</p></blockquote><p>git log 是显示当前的HEAD和他的祖先的，递归是沿着当前指针的父亲，父亲的父亲……这样的原则。</p><p>git reflog 根本不遍历HEAD的祖先，他是HEAD所指向的一个顺序的提交列表。reflog并不是repo的一部分，它单独存储，而且不包含在pushes、fetches、或者clones里，它纯属是本地的。</p><p>reflog查看的是所有的 HEAD 改变的记录，约等于记录用户操作行为。reflog 可以很好地帮助你恢复你误操作的数据，例如你错误地 reset 了一个旧的提交，或者 rebase 等等，这个时候想要查看在错误操作之前的信息，log就做不到了，而reflog可以。然后使用 git reset –hard 去恢复之前的状态。</p><p><a href="http://git-scm.com/docs/git-log" target="_blank" rel="noopener">git log</a> shows the commit log accessible from the refs (heads, tags, remotes)<br><a href="http://git-scm.com/docs/git-reflog" target="_blank" rel="noopener">git reflog</a> is a record of all commits that are or were referenced in your repo at any time.<br>That is why git reflog (a local recording which is pruned after 90 days by default) is used when you do a “destructive” operation (like deleting a branch), in order to get back the SHA1 that was referenced by that branch.<br>See <a href="http://git-scm.com/docs/git-config" target="_blank" rel="noopener">git config</a></p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/17857723/whats-the-difference-between-git-reflog-and-log" target="_blank" rel="noopener">https://stackoverflow.com/questions/17857723/whats-the-difference-between-git-reflog-and-log</a></p></blockquote><h2 id="git-reflog-命令"><a href="#git-reflog-命令" class="headerlink" title="git reflog 命令"></a>git reflog 命令</h2><h3 id="git-的版本表示法"><a href="#git-的版本表示法" class="headerlink" title="git 的版本表示法"></a>git 的版本表示法</h3><blockquote><p>HEAD@{2} means “where HEAD used to be two moves ago”, master@{one.week.ago}means “where master used to point to one week ago in this local repository”</p></blockquote><p>HEAD@{2}表示HEAD指针在两次移动之前的情况；而 master@{one.week.ago}表示master在本地仓库一周之前的情况。</p><h3 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog &lt;subcommand&gt; &lt;options&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reflog [show] [<span class="built_in">log</span>-options] [&lt;ref&gt;]</span><br><span class="line">git reflog expire [--expire=&lt;time&gt;] [--expire-unreachable=&lt;time&gt;] [--rewrite] [--updateref] [--stale-fix] [--dry-run | -n] [--verbose] [--all | &lt;refs&gt;…​]</span><br><span class="line">git reflog delete [--rewrite] [--updateref] [--dry-run | -n] [--verbose] ref@&#123;specifier&#125;…​</span><br><span class="line">git reflog exists &lt;ref&gt;</span><br></pre></td></tr></table></figure><p>“expire”子命令会删除掉更老的reflog条目。</p><p>“delete”子命令从reflog中删除一个条目。</p><p>“exists”子命令检查一个ref是否有一个reflog。</p><h3 id="reflog-高级"><a href="#reflog-高级" class="headerlink" title="reflog 高级"></a>reflog 高级</h3><p>reflog 跟 log 一样也可以自定义输出格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">%H: commit hash</span><br><span class="line">%h: 缩短的commit hash</span><br><span class="line">%T: tree hash</span><br><span class="line">%t: 缩短的 tree hash</span><br><span class="line">%P: parent hashes</span><br><span class="line">%p: 缩短的 parent hashes</span><br><span class="line">%an: 作者名字</span><br><span class="line">%aN: mailmap的作者名字 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))</span><br><span class="line">%ae: 作者邮箱</span><br><span class="line">%aE: 作者邮箱 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))</span><br><span class="line">%ad: 日期 (--date= 制定的格式)</span><br><span class="line">%aD: 日期, RFC2822格式</span><br><span class="line">%ar: 日期, 相对格式(1 day ago)</span><br><span class="line">%at: 日期, UNIX timestamp</span><br><span class="line">%ai: 日期, ISO 8601 格式</span><br><span class="line">%cn: 提交者名字</span><br><span class="line">%cN: 提交者名字 (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))</span><br><span class="line">%ce: 提交者 email</span><br><span class="line">%cE: 提交者 email (.mailmap对应，详情参照git-shortlog(1)或者git-blame(1))</span><br><span class="line">%cd: 提交日期 (--date= 制定的格式)</span><br><span class="line">%cD: 提交日期, RFC2822格式</span><br><span class="line">%cr: 提交日期, 相对格式(1 day ago)</span><br><span class="line">%ct: 提交日期, UNIX timestamp</span><br><span class="line">%ci: 提交日期, ISO 8601 格式</span><br><span class="line">%d: ref名称</span><br><span class="line">%e: encoding</span><br><span class="line">%s: commit信息标题</span><br><span class="line">%f: sanitized subject line, suitable for a filename</span><br><span class="line">%b: commit信息内容</span><br><span class="line">%N: commit notes</span><br><span class="line">%gD: reflog selector, e.g., refs/stash@&#123;1&#125;</span><br><span class="line">%gd: shortened reflog selector, e.g., stash@&#123;1&#125;</span><br><span class="line">%gs: reflog subject</span><br><span class="line">%Cred: 切换到红色</span><br><span class="line">%Cgreen: 切换到绿色</span><br><span class="line">%Cblue: 切换到蓝色</span><br><span class="line">%Creset: 重设颜色</span><br><span class="line">%C(...): 制定颜色, as described in color.branch.* config option</span><br><span class="line">%m: left, right or boundary mark</span><br><span class="line">%n: 换行</span><br><span class="line">%%: a raw %</span><br><span class="line">%x00: print a byte from a hex code</span><br><span class="line">%w([[,[,]]]): switch line wrapping, like the -w option of git-shortlog(1)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> reflog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让本地分支与远程分支建立映射关系</title>
      <link href="/2018/09/25/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E4%B8%8E%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2018/09/25/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E4%B8%8E%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git 建分支很 cheap，本地和远程都常常各自拥有大量分支，有时本地分支需要跟某个新的远程分支建立追踪映射，以便于在 pull、 push 等操作时，简化命令，也在一定程度上防止误传到其他分支。今天建立了新的远程分支，本地不想弄一个新的跟它对应，想用当前分支换个关联，用到了该技能。</p></blockquote><a id="more"></a><h3 id="核心命令"><a href="#核心命令" class="headerlink" title="核心命令"></a>核心命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=[remote-name/remote-branch-name]</span><br></pre></td></tr></table></figure><h3 id="详解"><a href="#详解" class="headerlink" title="详解:"></a>详解:</h3><p>完成同样效果的命令还有：</p><h4 id="git-1-8-以上"><a href="#git-1-8-以上" class="headerlink" title="git 1.8 以上"></a>git 1.8 以上</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -u [remote-name/remote-branch-name]</span><br><span class="line"># or 如果要关联的本地分支不是当前分支</span><br><span class="line">git branch -u [remote-name/remote-branch-name] [local-branch-name]</span><br></pre></td></tr></table></figure><p>如果比较喜欢比较长的命令写法(我比较喜欢，是不是很变态，哈哈)，可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=[remote-name/remote-branch-name]</span><br><span class="line"># or 如果要关联的本地分支不是当前分支</span><br><span class="line">git branch --set-upstream-to=[remote-name/remote-branch-name] [local-branch-name]</span><br></pre></td></tr></table></figure></p><p>例如，我有个本地分支 dev，想跟远程 origin 的 v1.1 关联：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#如果当前就在 dev 分支上：</span><br><span class="line">git branch -u origin/v1.1</span><br><span class="line">#or</span><br><span class="line">git branch --set-upstream-to=origin/v1.1</span><br><span class="line"></span><br><span class="line">#如果当前不在 dev 分支上：</span><br><span class="line">git branch -u origin/v1.1 dev</span><br><span class="line">#or</span><br><span class="line">git branch --set-upstream-to=origin/v1.1 dev</span><br></pre></td></tr></table></figure></p><h4 id="git-1-7-以上（已经在2-几版本停用）"><a href="#git-1-7-以上（已经在2-几版本停用）" class="headerlink" title="git 1.7 以上（已经在2.几版本停用）"></a>git 1.7 以上（已经在2.几版本停用）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream dev origin/v1.1</span><br></pre></td></tr></table></figure><h3 id="如果要在-check-分支的时候进行映射"><a href="#如果要在-check-分支的时候进行映射" class="headerlink" title="如果要在 check 分支的时候进行映射"></a>如果要在 check 分支的时候进行映射</h3><p>check 到与远程分支同名的本地分支 v1.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track origin/v1.1   #git 1.6.2 以上</span><br></pre></td></tr></table></figure></p><p>check 到与远程分支不同名的分支 dev2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev2 origin/v1.1</span><br></pre></td></tr></table></figure></p><h3 id="查看本地分支与远程分支的映射情况"><a href="#查看本地分支与远程分支的映射情况" class="headerlink" title="查看本地分支与远程分支的映射情况"></a>查看本地分支与远程分支的映射情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> branch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让远程仓库回退到某个之前的版本</title>
      <link href="/2018/09/23/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9B%9E%E9%80%80%E5%88%B0%E6%9F%90%E4%B8%AA%E4%B9%8B%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC/"/>
      <url>/2018/09/23/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9B%9E%E9%80%80%E5%88%B0%E6%9F%90%E4%B8%AA%E4%B9%8B%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pull 代码再次遇到冲突，这次突发奇想，想试试用 git stash 来处理，结果 push 完，队友反映她 pull 后好多代码被重置，并且遇到严重冲突，受牵连70几个文件。我查看了下 commit 记录，惊讶地发现，我处理完冲突传上去的代码确实都变成了我本地的老代码，pull 下来的修改都被我重置了。都是乱用 git stash 的错。。还好发现的及时，我立即决定撤回远程仓库中我的那次 push，让代码回滚到我 push 前的状态。那么如何让远程仓库回退到某个之前的版本？步骤如下。</p></blockquote><a id="more"></a><p>只需五步，方法如下：</p><h3 id="1-查看-commit-日志，确定要回滚到的-commit-id（前7位即可）"><a href="#1-查看-commit-日志，确定要回滚到的-commit-id（前7位即可）" class="headerlink" title="1. 查看 commit 日志，确定要回滚到的 commit id（前7位即可）"></a>1. 查看 commit 日志，确定要回滚到的 commit id（前7位即可）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>找到要回到的那次 commit ，复制 commit id，比如我这里是 b8b2df7</p><h3 id="2-先备份下当前版本"><a href="#2-先备份下当前版本" class="headerlink" title="2. 先备份下当前版本"></a>2. 先备份下当前版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b old_dev</span><br><span class="line">git push origin old_dev:old_dev</span><br></pre></td></tr></table></figure><h3 id="3-本地回滚到指定代码版本"><a href="#3-本地回滚到指定代码版本" class="headerlink" title="3. 本地回滚到指定代码版本"></a>3. 本地回滚到指定代码版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard b8b2df7</span><br></pre></td></tr></table></figure><h3 id="4-删除远程对应的分支"><a href="#4-删除远程对应的分支" class="headerlink" title="4. 删除远程对应的分支"></a>4. 删除远程对应的分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin :dev</span><br><span class="line">//or</span><br><span class="line">git push origin --delete dev</span><br></pre></td></tr></table></figure><h3 id="5-重新创建远程分支"><a href="#5-重新创建远程分支" class="headerlink" title="5. 重新创建远程分支"></a>5. 重新创建远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev:dev</span><br></pre></td></tr></table></figure><h3 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h3><blockquote><p>或者，不使用删除分支再建分支的方法，这个要两部，有些麻烦，可以使用强制推送，只需一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev:dev -f  #因为reset后本地仓库落后于远程仓库，因此要强制提交</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> reset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何撤销 git add 和 git commit</title>
      <link href="/2018/09/19/%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80-git-add-%E5%92%8C-git-commit/"/>
      <url>/2018/09/19/%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80-git-add-%E5%92%8C-git-commit/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于心急，提交代码的时候，commit 后，发现多提交了一个文件，然后第一想法是使用 <code>rebase</code> 来修改提交，然后我把那个多提交的文件，恢复成修改前的样子，然后打算在 <code>git add .</code> 之后进行 rebase ，结果查看状态发现，它把我之前在编辑器里面忽略的一个文件也给加进来了…所以这个时候，我既多 commit 了， 又多 add 了…蜜汁尴尬…</p></blockquote><a id="more"></a><p>经过查找资料，问题解决，又 get 到 git 的新技能。</p><h3 id="1-git-add-多了"><a href="#1-git-add-多了" class="headerlink" title="1. git add 多了"></a>1. git add 多了</h3><ul><li><code>git status</code> 查看下 add 的文件</li><li><code>git reset HEAD</code> 如果后面什么都不跟，就是把上一次的 git add 全部撤销。<br>or</li><li><code>git reset HEAD xxx/xxx/xxx.js</code> ，则撤销某个文件的add。这对add了一批文件后，又删除了其中的某个文件，想取消对这个文件的add的情况非常适用。</li></ul><h3 id="2-git-add-多了之后，又-commit-了"><a href="#2-git-add-多了之后，又-commit-了" class="headerlink" title="2. git add 多了之后，又 commit 了"></a>2. git add 多了之后，又 commit 了</h3><ul><li>先使用 <code>git log --oneline</code> 查看节点，找到这次 commit 的上一次 commit 记录。</li><li>然后 <code>git reset commit_id</code> 。退回到某一个提交的节点，代码还是现在的样子，只是那个节点之后的commit日志没有了，git add 的暂存区也清掉了，那次节点之后的所有改动都放在了当前工作区。即需要重新 git add 到暂存区，再commit。<blockquote><p><code>git reset</code> 有三个参数可选：<code>--hard</code> <code>--soft</code> <code>--mixed</code>，不跟参数就是默认的<code>--mixed</code>。</p></blockquote></li></ul><h3 id="3-使用-git-revert-还原已经提交的修改（这个没有验证过）"><a href="#3-使用-git-revert-还原已经提交的修改（这个没有验证过）" class="headerlink" title="3. 使用 git revert 还原已经提交的修改（这个没有验证过）"></a>3. 使用 git revert 还原已经提交的修改（这个没有验证过）</h3><p>使用 git revert 后，此次操作之前和之后的 commit 和 history 都会保留，并且把这次撤销作为一次最新的提交。</p><ul><li><code>git revert HEAD</code> 撤销前一次 commit</li><li><code>git revert HEAD^</code> 撤销前一次 commit</li><li><code>git revert commit_id</code> 撤销指定的版本，撤销也会作为一次提交进行保存。<br>git revert 是提交一个新的版本，将需要 revert 的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> reset </tag>
            
            <tag> revert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶(二)：hexo博客配置</title>
      <link href="/2018/09/19/%E8%BF%9B%E9%98%B6-%E4%BA%8C-%EF%BC%9Ahexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/19/%E8%BF%9B%E9%98%B6-%E4%BA%8C-%EF%BC%9Ahexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="进阶-二-：hexo博客配置"><a href="#进阶-二-：hexo博客配置" class="headerlink" title="进阶(二)：hexo博客配置"></a>进阶(二)：hexo博客配置</h2><blockquote><p>进阶配置内容：</p><ol><li>添加评论系统</li><li>添加 tags 页面</li><li>添加 categories 页面</li><li>添加 about 页面</li><li>配置404页</li><li>设置 ‘阅读全文’</li><li>配置博客文档模版</li></ol></blockquote><a id="more"></a><h3 id="1-添加评论系统"><a href="#1-添加评论系统" class="headerlink" title="1. 添加评论系统"></a>1. 添加评论系统</h3><p>hexo官方提供了很多评论系统的配置，我选择的是’来必力’。<br>我先注册了<a href="https://livere.com" target="_blank" rel="noopener">来必力</a>，<br>然后创建了一个 liverre city，获取到代码中的 <code>data-uid</code> ，<br>然后编辑 <code>hexo</code> 主题配置文件 <code>_config.yml</code> , 编辑 <code>livere_uid</code> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liverre_uid: #我在来必力获取的uid</span><br></pre></td></tr></table></figure></p><h3 id="2-添加-tags-页面"><a href="#2-添加-tags-页面" class="headerlink" title="2. 添加 tags 页面"></a>2. 添加 tags 页面</h3><ol><li><p>在终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li><li><p>在生成的 tags 目录下，编辑 index.md ，设置 <code>type</code> 属性为 <code>tags</code>，并屏蔽该页的评论功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-09-19 22:51:31</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>在 <code>_config.yml</code> 文件中，编辑 menu 字段，放开 tags：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  #about: /about/ || user</span><br></pre></td></tr></table></figure><blockquote><p><code>||</code> 左侧是页面路径，<code>||</code> 右侧是图标在 <code>FontAwesome</code> 字体中的名称。</p></blockquote></li></ol><h3 id="3-添加-categories-页面"><a href="#3-添加-categories-页面" class="headerlink" title="3. 添加 categories 页面"></a>3. 添加 categories 页面</h3><ol><li><p>在终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li><li><p>在生成的 categories 目录下，编辑 index.md ，设置 <code>type</code> 属性为 <code>categories</code> ，并屏蔽该页的评论功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-09-19 22:51:31</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>在 <code>_config.yml</code> 文件中，编辑 menu 字段，放开 categoris 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  #about: /about/ || user</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-添加-about-页面"><a href="#4-添加-about-页面" class="headerlink" title="4. 添加 about 页面"></a>4. 添加 about 页面</h3><ol><li><p>在终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure></li><li><p>在生成的 about 目录下，编辑 index.md ，屏蔽该页的评论功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-09-19 22:51:31</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>在 <code>_config.yml</code> 文件中，编辑 menu 字段，放开 about 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  about: /about/ || user</span><br></pre></td></tr></table></figure></li></ol><blockquote><h4 id="about页面的设置Tip"><a href="#about页面的设置Tip" class="headerlink" title="about页面的设置Tip"></a>about页面的设置Tip</h4><p>注意：about页面还有一些地方要处理，因为 <code>Next主题中</code> 默认会把页面跟文章一样处理，当你在yml中设置了显示文章目录时，自定义页面也会统一被添加toc目录（这是我不想要的）。于是我DIY了一下：</p><ul><li><p>在 about页 的 index.md 文件头部加上自定义属性 <code>toc: false</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: 2018-09-19 21:35:29</span><br><span class="line">toc: false</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>然后找到 <code>themes/next/layout/_macro</code> 目录下的 <code>sidebar.swig</code> 模版文件，将 toc 渲染条件由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set display_toc = is_post and theme.toc.enable or is_page and theme.toc.enable %&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set display_toc = is_post and theme.toc.enable or page.toc !== false %&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启 hexo 服务，刷新 about 页，即可看到不再显示右侧的toc目录了。</p></li></ul></blockquote><h3 id="5-配置404页"><a href="#5-配置404页" class="headerlink" title="5. 配置404页"></a>5. 配置404页</h3><p>给自己的站点设置404页面，可以让网站体验更加友好。<br>hexo中配置404页的步骤很简单，在<code>/source</code>目录下，或者<code>themes/next/source</code> 目录下创建 <code>404.html</code> 文件即可。404页面的内容可以发挥自己的创意个性来设计，也可以利用404为社会公益做一些贡献。我放的是腾讯公益，帮助找回走失儿童，页面代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">         &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">         &lt;title&gt;404&lt;/title&gt;                                                                                                                                        </span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">         &lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; homePageName=&quot;返回首页&quot; homePageUrl=&quot;https://www.champyin.com&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="6-设置-‘阅读全文’"><a href="#6-设置-‘阅读全文’" class="headerlink" title="6. 设置 ‘阅读全文’"></a>6. 设置 ‘阅读全文’</h3><p>效果：在首页提供文章的部分内容，并提供一个链接跳转到全文页面。<br>在 NextT 中提供了三种方式，我比较喜欢它推荐的那种，也是 Hexo 提供的方式：<br>在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断。</p><h3 id="7-配置博客文档模版"><a href="#7-配置博客文档模版" class="headerlink" title="7. 配置博客文档模版"></a>7. 配置博客文档模版</h3><p>hexo 中，运行 <code>hexo new &quot;xxx&quot;</code> 是调用了 <code>scaffolds</code> 目录下的 <code>post.md</code> 文件作为模版来创建的。<br>所以修改这个模版，就可以达到每次创建文档可以使用自己习惯的模版了。<br>默认模版是没有 categories 的，我需要这个字段，所以在模版中加上了这个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: </span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何修改git中已经提交的内容</title>
      <link href="/2018/09/11/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9git%E4%B8%AD%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E7%9A%84%E5%86%85%E5%AE%B9/"/>
      <url>/2018/09/11/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9git%E4%B8%AD%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E7%9A%84%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在git上提交代码的时候，不小心在 commit message 中打了几个错别字，merge、push 完了才发现。。 由于我的完美主义加强迫症比较严重，那几个错别字越看越不顺眼，寻思着把它们给改过来。一番资料搜寻和操作，成功搞定！</p></blockquote><a id="more"></a><h2 id="如何修改某次提交的-commit-message"><a href="#如何修改某次提交的-commit-message" class="headerlink" title="如何修改某次提交的 commit message"></a>如何修改某次提交的 commit message</h2><p>需要注意的是：没有办法修改整个项目的第一条日志。第2次以后的信息都可以通过此方法修改。</p><h3 id="step-1-查看提交的-commit-id-SHA值"><a href="#step-1-查看提交的-commit-id-SHA值" class="headerlink" title="step 1. 查看提交的 commit id (SHA值)"></a>step 1. 查看提交的 commit id (SHA值)</h3><p>如果 push 过，可以在git托管平台（比如 github、gitlab)上的 commits 里面看到（那串40位的编码就是了），只需要其前7位。<br>或者直接通过 <code>git log</code> 命令查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure></p><p>在展示的结果上每条 log 记录的前面的字段就是我们需要的 SHA 值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">b8b2df7 (HEAD -&gt; master, origin/master) 中文</span><br><span class="line">dd09519 di sici tijiao</span><br><span class="line">f1d9380 english only modify again..</span><br><span class="line">ea8a3b5 nonono correct message</span><br><span class="line">66a4488 need to be changed message</span><br></pre></td></tr></table></figure></p><p>比如我要修改的那条 commit 的 SHA 为：dd09519<br>那我需要的是这一条之前的一条 commit 的 SHA ：f1d9380</p><h3 id="step-2-通过-git-rebase-命令回到要修改提交的上一次提交的基础上"><a href="#step-2-通过-git-rebase-命令回到要修改提交的上一次提交的基础上" class="headerlink" title="step 2. 通过 git rebase 命令回到要修改提交的上一次提交的基础上"></a>step 2. 通过 <code>git rebase</code> 命令回到要修改提交的上一次提交的基础上</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i f1d9380</span><br></pre></td></tr></table></figure><p>等待一会，然后会打开 vim 编辑器，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pick dd09519 di sici tijiao</span><br><span class="line">pick b8b2df7 中文</span><br><span class="line"></span><br><span class="line"># Rebase f1d9380..f52c471 onto f1d9380 (2 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span><br><span class="line"># d, drop &lt;commit&gt; = remove commit</span><br><span class="line"># l, label &lt;label&gt; = label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; = reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&apos;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line">#       However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure></p><p>在编辑器中找到你要修改的那个提交信息，用 <code>i</code> 命令进入编辑，<br>将那一行开头的 <code>pick</code> 改为 <code>edit</code>: <code>pick dd09519 di sici tijiao</code> -&gt; <code>edit dd09519 di sici tijiao</code><br>然后 <code>esc</code> -&gt; <code>:</code> -&gt; <code>wq</code>, 保存退出。</p><p>然后界面显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i f1d9380</span><br><span class="line">Stopped at dd09519...  di sici tijiao</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --continue</span><br></pre></td></tr></table></figure></p><h3 id="step-3-修改-commit-message："><a href="#step-3-修改-commit-message：" class="headerlink" title="step 3. 修改 commit message："></a>step 3. 修改 commit message：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>再次进入 vim 编辑器，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">di sici tijiao</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Sep 11 18:49:29 2018 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto f1d9380</span><br><span class="line"># Last command done (1 command done):</span><br><span class="line">#    edit 4df3762 中文信息 sici tijiao</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick f52c471 中文</span><br><span class="line"># You are currently editing a commit while rebasing branch &apos;master&apos; on &apos;f1d9380&apos;.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       modified:   README.md</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p><p>可以看到第一行就是要修改的 commit message。<br>同样的通过 vim 命令 进入编辑模式，修改提交信息: <code>di sici tijiao</code> -&gt; <code>中文信息 sici tijiao</code><br>然后<code>:wq</code> 保存退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br><span class="line">[detached HEAD 4df3762] 中文信息 sici tijiao</span><br><span class="line"> Date: Tue Sep 11 18:49:29 2018 +0800</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure></p><h3 id="step-4-完成-rebase："><a href="#step-4-完成-rebase：" class="headerlink" title="step 4. 完成 rebase："></a>step 4. 完成 rebase：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>等待一会，然后出现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --continue</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure></p><p>表明操作成功。</p><h3 id="step-5-将修改后的变动-push-到远程"><a href="#step-5-将修改后的变动-push-到远程" class="headerlink" title="step 5. 将修改后的变动 push 到远程"></a>step 5. 将修改后的变动 push 到远程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master -f</span><br></pre></td></tr></table></figure><p>注意一定要使用 <code>-f</code> 参数，表示强制推送。<br>因为我们没有产生新的 commit（用 <code>git status</code> 可以看出），直接 push 不会发送任何东西。</p><h3 id="step-6-现在我们去远程仓库刷新下-commit-记录，可以看到-commit-信息就已经修改了。"><a href="#step-6-现在我们去远程仓库刷新下-commit-记录，可以看到-commit-信息就已经修改了。" class="headerlink" title="step 6. 现在我们去远程仓库刷新下 commit 记录，可以看到 commit 信息就已经修改了。"></a>step 6. 现在我们去远程仓库刷新下 commit 记录，可以看到 commit 信息就已经修改了。</h3><h3 id="最后，我们再来看下我们的日志信息"><a href="#最后，我们再来看下我们的日志信息" class="headerlink" title="最后，我们再来看下我们的日志信息"></a>最后，我们再来看下我们的日志信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>细心点就会发现，从我们修改的那条 commit 起，之后的所有的 commit 的 commit id 都发生了变化！我修改的那条，由 <code>dd09519</code> 变成了 <code>4df3762</code>; 而它之后的那条记录也由 <code>b8b2df7</code> 变成了 <code>f52c471</code> 虽然我没由修改这条 commit 信息。<br><figure class="highlight plain"><figcaption><span>git log --oneline</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f52c471 (HEAD -&gt; master, origin/master) 中文</span><br><span class="line">4df3762 中文信息 sici tijiao</span><br><span class="line">f1d9380 english only modify again..</span><br><span class="line">ea8a3b5 nonono correct message</span><br><span class="line">66a4488 need to be changed message</span><br></pre></td></tr></table></figure></p><h2 id="BTW-还要说一个要注意的"><a href="#BTW-还要说一个要注意的" class="headerlink" title="BTW 还要说一个要注意的"></a>BTW 还要说一个要注意的</h2><p> 就是如果 commit 信息要输入中文，记得用 git bash。因为我是在 IDE（webstorm）上进行的 commit，用的中文（要不怎么有错别字呢），那在修改 commit 信息的时候，我仍想用中文，我用 cmd、powerShell、Cmder，都试了，没法在 vim 里面敲中文，直接乱码，查资料改配置（quotepath = false、[gui] encoding = utf8）等等都没用，最后怀着绝望的心情，试了下 git bash， 居然中文支持的非常好！真是。。</p><blockquote><h2 id="另外，在查资料的过程中，还顺便-get-到几个-git-的高级技能。总结如下："><a href="#另外，在查资料的过程中，还顺便-get-到几个-git-的高级技能。总结如下：" class="headerlink" title="另外，在查资料的过程中，还顺便 get 到几个 git 的高级技能。总结如下："></a>另外，在查资料的过程中，还顺便 get 到几个 git 的高级技能。总结如下：</h2><h3 id="1-修改最近一次的提交"><a href="#1-修改最近一次的提交" class="headerlink" title="1. 修改最近一次的提交"></a>1. 修改最近一次的提交</h3><h4 id="方法一：commit-–amend"><a href="#方法一：commit-–amend" class="headerlink" title="方法一：commit –amend"></a>方法一：commit –amend</h4><p>这种方法不仅可以修改 commit message，也可以修改提交内容。这种方式在还没有推送到远端的情况下，可以保持原有的 Change-Id（commit id）。若已经推送到远端，Change-Id 则会修改掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改需要修改的项目代码(如果只需要修改 commit message 就不用做)</span><br><span class="line">git add . #如果只需要修改 commit message 就不用做</span><br><span class="line">git commit --amend</span><br><span class="line"># 在出现的 vim 编辑器中修改 commit message，保存退出。</span><br><span class="line">git push &lt;remote&gt; &lt;branch&gt; -f #若还没有推送到远端，就不用做</span><br></pre></td></tr></table></figure></p><h4 id="方法二：reset"><a href="#方法二：reset" class="headerlink" title="方法二：reset"></a>方法二：reset</h4><p>这种方法也可以修改提交内容和 commit message。这种方式在还没有推送到远端的情况下，也可以保持原有的 Change-Id（commit id）。若已经推送到远端，Change-Id 则会修改掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^</span><br><span class="line"># 修改需要修改的项目代码(如果只需要修改 commit message 就不用做)</span><br><span class="line">git add . # 如果只需要修改 commit message 就不用做</span><br><span class="line">git commit -m “new commit message”</span><br><span class="line">git push &lt;remote&gt; &lt;branch&gt; -f # 若还没有推送到远端，就不用做</span><br></pre></td></tr></table></figure></p><h3 id="2-提交到了错误的分支上的处理"><a href="#2-提交到了错误的分支上的处理" class="headerlink" title="2. 提交到了错误的分支上的处理"></a>2. 提交到了错误的分支上的处理</h3><h4 id="方法一：reset-stash"><a href="#方法一：reset-stash" class="headerlink" title="方法一：reset + stash"></a>方法一：reset + stash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 取消最新的提交， 然后保留现场原状</span><br><span class="line">git reset HEAD~ --soft</span><br><span class="line">git stash</span><br><span class="line"># 切换到正确的分支</span><br><span class="line">git checkout name-of-correct-branch</span><br><span class="line">git stash pop</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;new commit message&quot;</span><br><span class="line"># 现在你已经提交到正确的分支上了</span><br></pre></td></tr></table></figure><h4 id="方法二：cherry-pick-摘樱桃"><a href="#方法二：cherry-pick-摘樱桃" class="headerlink" title="方法二：cherry-pick 摘樱桃"></a>方法二：cherry-pick 摘樱桃</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout name-of-correct-branch</span><br><span class="line"># 把主分支上的最新提交摘过来～</span><br><span class="line">git cherry-pick master</span><br><span class="line"># 再删掉主分支上的最新提交</span><br><span class="line">git checkout master</span><br><span class="line">git reset HEAD~ --hard</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> rebase </tag>
            
            <tag> amend </tag>
            
            <tag> cherry-pick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用express/koa快速起一个node服务</title>
      <link href="/2018/09/11/%E4%BD%BF%E7%94%A8express-koa%E5%BF%AB%E9%80%9F%E8%B5%B7%E4%B8%80%E4%B8%AAnode%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/09/11/%E4%BD%BF%E7%94%A8express-koa%E5%BF%AB%E9%80%9F%E8%B5%B7%E4%B8%80%E4%B8%AAnode%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><p>express 导出的是一个函数。</p><h4 id="1-最简单的服务"><a href="#1-最简单的服务" class="headerlink" title="1. 最简单的服务"></a>1. 最简单的服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// www.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">res.end(&apos;server by express&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure><h4 id="2-使用-express-generator"><a href="#2-使用-express-generator" class="headerlink" title="2. 使用 express-generator"></a>2. 使用 express-generator</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i express</span><br><span class="line">npx express-generator //需要nodejs8.2及以上</span><br><span class="line">//nodejs8.2以下：</span><br><span class="line">//npm i -g express-generator</span><br><span class="line">//express --view=ejs myproject</span><br></pre></td></tr></table></figure><p>会在当前目录下生成一个项目，7个文件夹，9个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|--app.js</span><br><span class="line">|--bin/</span><br><span class="line">|    |-- www.js</span><br><span class="line">|--package.json</span><br><span class="line">|--public/</span><br><span class="line">|    |-- images/</span><br><span class="line">|    |-- javascript/</span><br><span class="line">|    |-- stylesheets/</span><br><span class="line">|            |--  style.css</span><br><span class="line">|--routes/</span><br><span class="line">|    |-- index.js</span><br><span class="line">|    |-- users.js</span><br><span class="line">|--views/</span><br><span class="line">     |-- error.jade</span><br><span class="line">     |-- index.jade</span><br><span class="line">     |-- layout.jade</span><br></pre></td></tr></table></figure></p><p>然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line">DEBUGE=projectname:* npm start</span><br><span class="line">//在windows下这样：</span><br><span class="line">//set DEBUG=projectname:* npm start</span><br></pre></td></tr></table></figure></p><h3 id="koa"><a href="#koa" class="headerlink" title="koa"></a>koa</h3><p>koa导出的是一个对象。</p><h4 id="最简单的服务"><a href="#最简单的服务" class="headerlink" title="最简单的服务"></a>最简单的服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i koa</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// www.js</span><br><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">cnost app = new Koa();</span><br><span class="line"></span><br><span class="line">app.use((ctx) =&gt; &#123;</span><br><span class="line">ctx.body = &apos;server by koa&apos;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git错误：HTTP Basic: Access denied</title>
      <link href="/2018/09/10/git%E9%94%99%E8%AF%AF%EF%BC%9AHTTP-Basic-Access-denied/"/>
      <url>/2018/09/10/git%E9%94%99%E8%AF%AF%EF%BC%9AHTTP-Basic-Access-denied/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上周五修改了gitlab的用户密码，今天发现操作git远程仓库都报错拒绝，错误信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remote: HTTP Basic: Access denied</span><br><span class="line">fatal: Athentication failed for &apos;https://************&apos;</span><br></pre></td></tr></table></figure></p></blockquote><p>直觉告诉我，是改密码引起。网上查了资料，确实 git 会把第一次输入过的用户名密码存储起来，再次使用 git 命令的时候，会使用存储的用户名密码，然而当 git 的密码修改后，原来存储的密码肯定匹配不了，于是直接报没有权限终止操作。网上类似的帖子很多，但是不是都有效，在多次尝试后，终于解决，解决办法如下：</p><p>首先我因为有两台电脑，一台 win7，一台 win10，不同操作系统解决方式还不一样，也是坑了我很多时间。。。</p><h2 id="win-10-下的解决办法"><a href="#win-10-下的解决办法" class="headerlink" title="win 10 下的解决办法"></a>win 10 下的解决办法</h2><a id="more"></a><p>解决办法很简单，一句命令搞定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system -unset credentia.helper</span><br></pre></td></tr></table></figure></p><p>不过要注意的是在 win10 中，这个命令需要在管理员权限下运行，否则报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: could not lock config file C:/Program Files/Git/migw64/etc/gitconfig: Permission denied</span><br></pre></td></tr></table></figure></p><p>在 linux 下使用 <code>sudo</code> 可以切换到管理员权限，但是在 win10 上，只能先找到 cmd 的快捷方式，然后右键，以管理员身份运行。比如，在左下角windows符号上右键 -&gt; <code>Windows PowerShell(管理员)</code>。</p><p>运行后，命令的前面的路径会显示为：<code>PS C:\Windows\system32&gt;</code></p><h2 id="win-7-下的解决办法"><a href="#win-7-下的解决办法" class="headerlink" title="win 7 下的解决办法"></a>win 7 下的解决办法</h2><p>使用刚才在 win 10 上的解决办法，在 win 7 上尝试无效。。。<br>win 7 下采用的办法是直接修改凭据：</p><ol><li>进入 <code>控制面版 -&gt; 所有用户 -&gt; 凭据管理</code></li><li>在 <code>Windows 凭据</code> 下，找到 gitlab 对应的凭据</li><li>点 <code>编辑</code>，修改密码，保存。</li><li>done。</li></ol><p>然后执行下刚才的 <code>git pull</code> 命令，妥妥滴拉下来。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> access denied </tag>
            
            <tag> authentication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码片段</title>
      <link href="/2018/09/06/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
      <url>/2018/09/06/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="1-文字截断"><a href="#1-文字截断" class="headerlink" title="1. 文字截断"></a>1. 文字截断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.ellipsis &#123;</span><br><span class="line">overflow: hidden;</span><br><span class="line">white-space: nowrap;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-清除浮动"><a href="#2-清除浮动" class="headerlink" title="2. 清除浮动"></a>2. 清除浮动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123;</span><br><span class="line">zoom: 1;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">clear:both;</span><br><span class="line">content: &quot;&quot;;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-javascript-生成-img-标签的3种方式"><a href="#3-javascript-生成-img-标签的3种方式" class="headerlink" title="3. javascript 生成 img 标签的3种方式"></a>3. javascript 生成 <code>img</code> 标签的3种方式</h3><p>方式1: 使用 createElement 方法</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img = document.createElement(&apos;img&apos;);</span><br><span class="line">img.src = &apos;https://www.baidu.com/img/bd_logo1.png&apos;</span><br><span class="line">document.body.appendChild(img);</span><br></pre></td></tr></table></figure><p>方式2: 使用 innerHTML 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var imgHtml = &apos;&lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; &gt;&apos;;</span><br><span class="line">document.body.innerHTML = imgHtml;</span><br></pre></td></tr></table></figure></p><p>方式3: 使用 new image() 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img = new image();</span><br><span class="line">img.src = &apos;https://www.baidu.com/img/bd_logo1.png&apos;;</span><br><span class="line">document.body.appendChild(img);</span><br></pre></td></tr></table></figure></p><h3 id="4-js-添加、删除-class"><a href="#4-js-添加、删除-class" class="headerlink" title="4. js 添加、删除 class"></a>4. js 添加、删除 class</h3><p>方法1: 比较传统的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var classVal = docment.getElementById(&apos;id&apos;).getAttribute(&apos;class&apos;);</span><br><span class="line">// 删除某个class</span><br><span class="line">var classVal = classVal.replace(&apos;someclassname&apos;, &apos;&apos;);</span><br><span class="line">document.getElementById.setAttribute(&apos;class&apos;, classVal);</span><br><span class="line"></span><br><span class="line">// 添加class</span><br><span class="line">var classVal = classVal.concat(&apos;newclassname&apos;);</span><br><span class="line">document.getElementById.setAttribute(&apos;class&apos;, classVal);</span><br><span class="line"></span><br><span class="line">// 替换class</span><br><span class="line">var classVal = classVal.replace(&apos;someclassname&apos;, &apos;newclassname&apos;);</span><br><span class="line">document.getElementById.setAttribute(&apos;class&apos;, classVal);</span><br></pre></td></tr></table></figure></p><p>方法2: HTML5中添加了classList<br>classList 属性返回元素的雷鸣，作为DOMTokenList对象。<br>classList 属性是只读的，但是可以使用 add() 和 remove() 方法修改它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 增加</span><br><span class="line">document.getElementById(&apos;id&apos;).classList.add(&apos;class1&apos;, &apos;class2&apos;, &apos;class3&apos;);</span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">document.getElemtnById(&apos;id&apos;).classList.remove(&apos;class1&apos;);</span><br></pre></td></tr></table></figure></p><p>方法3: 正则匹配<br>…</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> front-end </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web端页面如何在移动端也获得较好体验</title>
      <link href="/2018/09/05/web%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B9%9F%E8%8E%B7%E5%BE%97%E8%BE%83%E5%A5%BD%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/09/05/web%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B9%9F%E8%8E%B7%E5%BE%97%E8%BE%83%E5%A5%BD%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>在网页的 <code>head</code> 标签里，加上对 <code>viewport</code> 的设置，就可以让页面在移动设备上可以以比较好的缩放和比例来呈现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; &gt;</span><br></pre></td></tr></table></figure></p><p>还可以加入更多设置，如缩放之类：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes&quot; &gt;</span><br></pre></td></tr></table></figure><p>参数解释：<br>width：可以控制 viewport 的大小，可以指定一个数值，或者一个特殊的值，比如 <code>device-width</code> 设备的宽度。<br>initial-scale：初始缩放比例，也即当前页面第一次load的时候缩放比例<br>minimum-scale：允许用户缩放到的最小比例。<br>maximum-scale：允许用户缩放到的最大比例。<br>user-scalable：用户是否可以手动缩放。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> viewport </tag>
            
            <tag> mobiles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设置IDE编辑器以配合自动实时编译</title>
      <link href="/2018/09/02/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEIDE%E7%BC%96%E8%BE%91%E5%99%A8%E4%BB%A5%E9%85%8D%E5%90%88%E8%87%AA%E5%8A%A8%E5%AE%9E%E6%97%B6%E7%BC%96%E8%AF%91/"/>
      <url>/2018/09/02/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEIDE%E7%BC%96%E8%BE%91%E5%99%A8%E4%BB%A5%E9%85%8D%E5%90%88%E8%87%AA%E5%8A%A8%E5%AE%9E%E6%97%B6%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在前端开发过程中，通过webpack配置了即时监听并自动编译，实现保存文件触发编译。但是有的编辑器有 “安全写入” 的机制（就是在编辑器保存文件后不直接写入硬盘，而是先保存在编辑器内部的缓存里面，到一定时间后再写入硬盘），这会造成触发编译不那么实时，很影响开发效率。</p></blockquote><a id="more"></a><p>以下是针对几款常见编辑器，如何禁用安全写入的设置办法：</p><h3 id="JetBrains-IDEs（e-g-WebStorm"><a href="#JetBrains-IDEs（e-g-WebStorm" class="headerlink" title="JetBrains IDEs（e.g. WebStorm):"></a>JetBrains IDEs（e.g. WebStorm):</h3><p>在 <code>Preferences &gt; Appearance &amp; Behavior &gt; System Settings</code> 里面，去掉对 “Use safe write” 选项的勾选。即可。</p><h3 id="Sublime-Text3"><a href="#Sublime-Text3" class="headerlink" title="Sublime Text3:"></a>Sublime Text3:</h3><p>在 preferences-user 文件里，添加 <code>atomic_save: false</code>。即可。</p><h3 id="Vim："><a href="#Vim：" class="headerlink" title="Vim："></a>Vim：</h3><p>在 setting 文件里，添加 <code>:set backupcopy=yes</code> 。即可。</p>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webstorm </tag>
            
            <tag> sublime </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git冲突处理</title>
      <link href="/2018/08/30/git%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/"/>
      <url>/2018/08/30/git%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="git冲突处理"><a href="#git冲突处理" class="headerlink" title="git冲突处理"></a>git冲突处理</h1><blockquote><p>今天在merge分支的时候，由于记忆错位，merge了format分支到master，造成了很严重的冲突（我原本是要把format分支合并到dev分支，结果合并到了master）。<br>看到几百个文件的modify想死的心都有，差点想重新clone重新来过。。。<br>好在理智战胜冲动，决定正面处理冲突，而不是消极回避。<br>而在处理完冲突之后，发现异常的简单，庆幸没有冲动乱来。</p></blockquote><a id="more"></a><p>言归正传。</p><p>我在merge的时候git的提示是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err： Your local changes to the following files would be overwritteen by merge:</span><br><span class="line">      bla bla bla</span><br><span class="line">Please commit your changes or stash them before you merge.</span><br><span class="line">Abording</span><br><span class="line">Updating xxxxxxx(some hashcode)</span><br></pre></td></tr></table></figure></p><h3 id="解决方案有三种："><a href="#解决方案有三种：" class="headerlink" title="解决方案有三种："></a>解决方案有三种：</h3><h4 id="第一种：-提交修改"><a href="#第一种：-提交修改" class="headerlink" title="第一种： 提交修改"></a>第一种： 提交修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;my message&quot;</span><br></pre></td></tr></table></figure><h4 id="第二种：-stash"><a href="#第二种：-stash" class="headerlink" title="第二种： stash"></a>第二种： stash</h4><p>备份当前工作区的内容，从最近的一次提交种读取相关内容，当工作去保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。然后执行merge，然后再从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git statsh</span><br></pre></td></tr></table></figure></p><p>然后执行之前未执行完的merge操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge xxx</span><br></pre></td></tr></table></figure></p><p>然后拉取stash：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></p><p>由于可能存在多个stash的内容，所有用栈来管理，pop会从最近的一个stash中读取内容并恢复。<br>可以用 <code>git stash list</code> 来查看Git栈内的所有备份，可以利用这个列表来决定从哪个地方恢复。<br><code>git stash clear</code> 可以清空Git栈。</p><h4 id="第三种：-忽略本地修改"><a href="#第三种：-忽略本地修改" class="headerlink" title="第三种： 忽略本地修改"></a>第三种： 忽略本地修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">// or</span><br><span class="line">git checkout -t -f remote/branch</span><br></pre></td></tr></table></figure><h3 id="Or-忽略只忽略特定的文件"><a href="#Or-忽略只忽略特定的文件" class="headerlink" title="Or 忽略只忽略特定的文件"></a>Or 忽略只忽略特定的文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout filename</span><br></pre></td></tr></table></figure><h2 id="我当然使用的是stash的方式。"><a href="#我当然使用的是stash的方式。" class="headerlink" title="我当然使用的是stash的方式。"></a>我当然使用的是stash的方式。</h2><ul><li>在 <code>master</code> 分支上使用 <code>git stash</code>,</li><li>然后 <code>git merge dev</code>, 成功merge！</li><li>然后恢复工作区 <code>git stash pop</code>, 然后多出了很多modify的文件，还有一个标红的文件（冲突），不过它已经帮你解决好，只需要在文件中选择你要保留哪一段代码就好。</li><li>修改完冲突文件后， <code>git add .</code>, <code>git commit -m &quot;conflict fixed&quot;</code>.</li><li>最后，赶紧把这个解决完冲突后的代码传上远程仓库, WOO，松了一口气。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> conflict </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>virtualbox如何挂载宿主机的文件夹</title>
      <link href="/2018/07/17/virtualbox%E5%A6%82%E4%BD%95%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
      <url>/2018/07/17/virtualbox%E5%A6%82%E4%BD%95%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我的宿主机是一台windows操作系统的服务器。</p><p>虚拟机用的是virtualbox。</p><p>以前在 vmware 上面与宿主机的共享只需要在 wmware 上配置下共享文件夹就可以生效。但是在 virtualbox 上，除了配置共享文件夹，还要使用 <code>mount</code> 命令进行挂载才能与宿主机共享一个文件夹。</p></blockquote><a id="more"></a><h2 id="1-在宿主机建立一个用于与virtualbox共享的文件夹，例如-myshared。并在里面新建一个空的文本-a-txt，用于检测最后挂载是否成功。"><a href="#1-在宿主机建立一个用于与virtualbox共享的文件夹，例如-myshared。并在里面新建一个空的文本-a-txt，用于检测最后挂载是否成功。" class="headerlink" title="1. 在宿主机建立一个用于与virtualbox共享的文件夹，例如 myshared。并在里面新建一个空的文本 a.txt，用于检测最后挂载是否成功。"></a>1. 在宿主机建立一个用于与virtualbox共享的文件夹，例如 <code>myshared</code>。并在里面新建一个空的文本 <code>a.txt</code>，用于检测最后挂载是否成功。</h2><h2 id="2-在virtualbox中选择-设备-gt-共享文件夹-gt-打开设置界面。"><a href="#2-在virtualbox中选择-设备-gt-共享文件夹-gt-打开设置界面。" class="headerlink" title="2. 在virtualbox中选择 设备 -&gt; 共享文件夹 -&gt; 打开设置界面。"></a>2. 在virtualbox中选择 设备 -&gt; 共享文件夹 -&gt; 打开设置界面。</h2><h2 id="3-点击右侧-号，添加共享文件夹，选择宿主机上之前建好的-myshared-文件夹，并勾选-固定分配-。"><a href="#3-点击右侧-号，添加共享文件夹，选择宿主机上之前建好的-myshared-文件夹，并勾选-固定分配-。" class="headerlink" title="3. 点击右侧 + 号，添加共享文件夹，选择宿主机上之前建好的 myshared 文件夹，并勾选 固定分配 。"></a>3. 点击右侧 <code>+</code> 号，添加共享文件夹，选择宿主机上之前建好的 <code>myshared</code> 文件夹，并勾选 <code>固定分配</code> 。</h2><h2 id="4-在linux虚拟机中，打开终端，在mnt目录下新建一个目录-shared："><a href="#4-在linux虚拟机中，打开终端，在mnt目录下新建一个目录-shared：" class="headerlink" title="4. 在linux虚拟机中，打开终端，在mnt目录下新建一个目录 shared："></a>4. 在linux虚拟机中，打开终端，在mnt目录下新建一个目录 <code>shared</code>：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/shared</span><br></pre></td></tr></table></figure><h2 id="5-执行挂载："><a href="#5-执行挂载：" class="headerlink" title="5. 执行挂载："></a>5. 执行挂载：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t vboxsf myshared /mnt/shared</span><br></pre></td></tr></table></figure><h2 id="6-挂载成功，进入shared目录，就可以看到a-txt文件了。"><a href="#6-挂载成功，进入shared目录，就可以看到a-txt文件了。" class="headerlink" title="6. 挂载成功，进入shared目录，就可以看到a.txt文件了。"></a>6. 挂载成功，进入shared目录，就可以看到a.txt文件了。</h2>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> virtualbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下如何切换到root用户</title>
      <link href="/2018/07/16/linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%88%B0root%E7%94%A8%E6%88%B7/"/>
      <url>/2018/07/16/linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%88%B0root%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果只是想要临时使用一下root权限，只需要在命令前面加上 <code>sudo</code> 就可以了。</p><p>如果想要一直使用root权限，需要通过su切换到root用户：</p></blockquote><a id="more"></a><h2 id="首先要重设root用户的密码"><a href="#首先要重设root用户的密码" class="headerlink" title="首先要重设root用户的密码"></a>首先要重设root用户的密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>然后根据提示，输入新的root密码（可以是原来的root旧密码）</p><h2 id="然后就可以随时切换到root用户了"><a href="#然后就可以随时切换到root用户了" class="headerlink" title="然后就可以随时切换到root用户了"></a>然后就可以随时切换到root用户了</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure><p>输入root用户密码即可。</p><h2 id="回到用户权限"><a href="#回到用户权限" class="headerlink" title="回到用户权限"></a>回到用户权限</h2><p>使用 <code>su &quot;yc&quot;</code> 或者 <code>exit</code> 命令，即可回到用户权限。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2018/07/16/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/07/16/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录常用的liux命令，不定期更新。</p></blockquote><a id="more"></a><h1 id="一、-rm"><a href="#一、-rm" class="headerlink" title="一、 rm"></a>一、 rm</h1><p>删除文件或文件夹</p><h4 id="删除文件夹，无论文件夹是否为空"><a href="#删除文件夹，无论文件夹是否为空" class="headerlink" title="删除文件夹，无论文件夹是否为空"></a>删除文件夹，无论文件夹是否为空</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf 目录路径</span><br></pre></td></tr></table></figure><blockquote><p>说明：<br>-r 就是向下递归的意思；<br>-f 就是强制删除，不做任何提示的意思。</p></blockquote><p></p><p style="color:red">注意：使用 rm -rf 命令一定要格外小心。linux没有回收站，删除之后再找回就难了。</p><p></p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f 文件路径</span><br></pre></td></tr></table></figure><h1 id="二、ls"><a href="#二、ls" class="headerlink" title="二、ls"></a>二、ls</h1><p>ls是 list segment 的缩写，用于列出文件。</p><h4 id="列出当前目录下每个文件的大小以及当前目录文件下所有文件大小总和。"><a href="#列出当前目录下每个文件的大小以及当前目录文件下所有文件大小总和。" class="headerlink" title="列出当前目录下每个文件的大小以及当前目录文件下所有文件大小总和。"></a>列出当前目录下每个文件的大小以及当前目录文件下所有文件大小总和。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lht</span><br></pre></td></tr></table></figure><p>与以下命令是同一个效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l -h -t</span><br></pre></td></tr></table></figure></p><h4 id="ls的常用参数"><a href="#ls的常用参数" class="headerlink" title="ls的常用参数"></a>ls的常用参数</h4><p>常用参数：</p><p>-a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件</p><p>-A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。</p><p>-c  配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序</p><p>-C 每栏由上至下列出项目</p><p>–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</p><p>-d, –directory 将目录象文件一样显示，而不是显示其下的文件。</p><p>-D, –dired 产生适合 Emacs 的 dired 模式使用的结果</p><p>-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</p><p>-g 类似 -l,但不列出所有者</p><p>-G, –no-group 不列出任何有关组的信息</p><p>-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)</p><p>–si 类似 -h,但文件大小取 1000 的次方而不是 1024</p><p>-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地</p><p>–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</p><p>-i, –inode 印出每个文件的 inode 号</p><p>-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目</p><p>-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。</p><p>-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</p><p>-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息</p><p>-m 所有项目以逗号分隔，并填满整行行宽</p><p>-o 类似 -l,显示文件的除组信息外的详细信息。   </p><p>-r, –reverse 依相反次序排列</p><p>-R, –recursive 同时列出所有子目录层</p><p>-s, –size 以块大小为单位列出所有文件的大小</p><p>-S 根据文件大小排序</p><p>–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：</p><ul><li>extension -X status -c</li><li>none -U time -t</li><li>size -S atime -u</li><li>time -t access -u</li><li>version -v use -u</li></ul><p>-t 以文件修改时间排序</p><p>-u ：</p><ul><li>配合 -lt:显示访问时间而且依访问时间排序</li><li>配合 -l:显示访问时间但根据名称排序</li><li>否则：根据访问时间排序</li></ul><p>-U 不进行排序;依文件系统原有的次序列出项目</p><p>-v 根据版本进行排序</p><p>-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值</p><p>-x 逐行列出项目而不是逐栏列出</p><p>-X 根据扩展名排序</p><p>-1 每行只列出一个文件</p><p>–help 显示此帮助信息并离开</p><p>–version 显示版本信息并离开</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何重置gitlab用户密码</title>
      <link href="/2018/07/15/%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEgitlab%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
      <url>/2018/07/15/%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEgitlab%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>之前有提到，我为我们部门搭建了一个gitlab，前几天有用户跟我反映，他忘记密码了，使用gitlab自带的找回密码功能无果，收不到邮件，估计跟公司内网有一些关系，也可能是我没有配置好邮件联动。anyway，现在去配置邮箱感觉花的时间有些来不及。想着作为管理员，应该有权限和办法去重置用户的密码的，于是查询了资料，果然不出所料。方法如下，只需4步：</p><a id="more"></a><h2 id="1-首先进入Ruby-on-Rails-console："><a href="#1-首先进入Ruby-on-Rails-console：" class="headerlink" title="1. 首先进入Ruby on Rails console："></a>1. 首先进入Ruby on Rails console：</h2><p>使用root权限进入gitlab所在的linux服务器，打开一个终端，输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gitlab-rails console production</span><br></pre></td></tr></table></figure></p><p>然后等待ruby的console界面加载出来。</p><h3 id="2-然后你有好几种方法去查找用户。"><a href="#2-然后你有好几种方法去查找用户。" class="headerlink" title="2. 然后你有好几种方法去查找用户。"></a>2. 然后你有好几种方法去查找用户。</h3><p>方法一，使用id：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; user = User.where(id:[user&apos;s register index]).first</span><br></pre></td></tr></table></figure></p><p>方法二，使用邮箱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; user = User.where(email:[user&apos;s register email]).first</span><br></pre></td></tr></table></figure></p><p>方法三，使用用户名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; user = User.where(name:[user&apos;s register name]).first</span><br></pre></td></tr></table></figure></p><p>我这次使用的是邮箱<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; user=User.where(email:xxx@163.com).first</span><br></pre></td></tr></table></figure></p><h3 id="3-修改密码"><a href="#3-修改密码" class="headerlink" title="3. 修改密码"></a>3. 修改密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; user.password = &apos;newpassword&apos;</span><br><span class="line">&gt; user.password_confirmation = &apos;newpassword&apos;</span><br></pre></td></tr></table></figure><blockquote><p>注意最好是将 <code>password</code> 和 <code>password_confirmation</code> 都重置，以确保完全修改生效。</p></blockquote><h3 id="4-保存修改"><a href="#4-保存修改" class="headerlink" title="4. 保存修改"></a>4. 保存修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; user.save!</span><br></pre></td></tr></table></figure><blockquote><p>注意 <code>!</code> 号也很重要，不加的话，你的修改不会推送到数据库。</p></blockquote><h2 id="现在退出-console-使用新的密码登录试试，可以登录啦。"><a href="#现在退出-console-使用新的密码登录试试，可以登录啦。" class="headerlink" title="现在退出 console 使用新的密码登录试试，可以登录啦。"></a>现在退出 console 使用新的密码登录试试，可以登录啦。</h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> GitLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> gitlab </tag>
            
            <tag> ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何迁移git仓库</title>
      <link href="/2018/06/20/%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BBgit%E4%BB%93%E5%BA%93/"/>
      <url>/2018/06/20/%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BBgit%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>如果你想从别的git托管服务哪里复制一份源代码到新的Git托管服务器上，可以使用<br><code>git clone --mirror</code> / <code>git clone --bare</code> 和 <code>git push --mirror</code>命令。</p><p>普通 <code>git clone</code> 不能下载所有分支，想要简单的克隆所有分支，可以用镜像方法。</p><h1 id="做一个镜像仓库"><a href="#做一个镜像仓库" class="headerlink" title="做一个镜像仓库"></a>做一个镜像仓库</h1><p>只需3步：</p><a id="more"></a><ol><li><p>从原地址克隆一份裸版本库（假设在github）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare git://github.com/username/project.git</span><br><span class="line">or</span><br><span class="line">git clone --mirror git://github.com/username/project.git</span><br></pre></td></tr></table></figure><blockquote><p>这两种方式都只是将裸仓库克隆下来，不会在本地生成目录结构。</p></blockquote></li><li><p>在新的服务器上创建一个新项目。例如new-peoject。</p></li><li><p>以镜像推送的方式上传到新的git服务器上（假设在gitlab）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd prioject.git</span><br><span class="line">git push --mirror  git@gitlab.com/username/new-priject.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="done"><a href="#done" class="headerlink" title="done!"></a>done!</h2><blockquote><p>这种方式可以保留原版本远程仓库中的所有内容。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 删除已发布的包或者包的某个版本</title>
      <link href="/2018/06/08/npm-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%8F%91%E5%B8%83%E7%9A%84%E5%8C%85%E6%88%96%E8%80%85%E5%8C%85%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%88%E6%9C%AC/"/>
      <url>/2018/06/08/npm-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%8F%91%E5%B8%83%E7%9A%84%E5%8C%85%E6%88%96%E8%80%85%E5%8C%85%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="删除已发布的包的某个版本："><a href="#删除已发布的包的某个版本：" class="headerlink" title="删除已发布的包的某个版本："></a>删除已发布的包的某个版本：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unpublish xxx@x.x.x</span><br></pre></td></tr></table></figure><blockquote><p>删除这个版本后，<strong>不能再发布同版本的包</strong>，必须要大于这个版本号的包才行。</p></blockquote><h2 id="删除已发布的包："><a href="#删除已发布的包：" class="headerlink" title="删除已发布的包："></a>删除已发布的包：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unpublish xxx</span><br></pre></td></tr></table></figure><blockquote><p>删除这个包之后，<strong>不能再发布同名的包</strong>。</p></blockquote><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p><code>npm unpublish</code> <strong>仅在包发布后的24小时内有效</strong>。如果超过了24小时，则要联系npm官方去取消发布了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> NPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> unpublish </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过NPM安装私有模块</title>
      <link href="/2018/06/07/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87NPM%E5%AE%89%E8%A3%85%E7%A7%81%E6%9C%89%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/06/07/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87NPM%E5%AE%89%E8%A3%85%E7%A7%81%E6%9C%89%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有3种方案安装NPM私有模块：</p></blockquote><a id="more"></a><h2 id="方案一：购买npm付费账号"><a href="#方案一：购买npm付费账号" class="headerlink" title="方案一：购买npm付费账号"></a>方案一：购买npm付费账号</h2><p>根据npm的价格方案，只要是付费用户，不论是哪一种，都可以下载和发布不限量的私有模块。所有的私有模块都是scoped package。scope是npm的新特性。如果一个模块的名字以 <code>@</code> 开头，那它就是一个scoped package:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@scope/project-name</span><br></pre></td></tr></table></figure></p><blockquote><p>每一个npm用户都有拥有一个自己的scope：当前用户名username。</p></blockquote><h2 id="方案二：自建npm私服"><a href="#方案二：自建npm私服" class="headerlink" title="方案二：自建npm私服"></a>方案二：自建npm私服</h2><p>如果连仓库都是私有的，模块自然是私有的。这个方案好处就是可以建在自己公司内部，访问速度自然是杠杠的，而且想怎么定制就怎么定制。不过构建成本也是有的，而且需要服务器。一般稍微大规模的团队和公司会采取这种办法。</p><h2 id="方案三：利用npm安装机制和git仓库"><a href="#方案三：利用npm安装机制和git仓库" class="headerlink" title="方案三：利用npm安装机制和git仓库"></a>方案三：利用npm安装机制和git仓库</h2><p>这个方案最经济实惠。<br>首先，<code>npm install</code> 支持 <code>npm install &lt;git remote url&gt;</code> ，其中 <code>git remote url</code> 的格式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;protocol&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:/]&lt;path&gt;[#&lt;commit-ish&gt;]</span><br></pre></td></tr></table></figure></p><p>即，如果你的代码托管在bitbucket中，可以通过如下命令安装模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install git+ssh://git@bitbucket.org/用户名／项目名.git#版本号</span><br></pre></td></tr></table></figure></p><p>这种方式唯一的不足的地方就是，你必须要确保安装这个私有模块的机器由访问这个私有模块git仓库的权限。也就是说这台机器的公钥必须添加到git仓库中。<br>如果你嫌添加公钥麻烦，也可以通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install git+https:username:password@bitbucket.org/用户名／项目名.git#版本号</span><br></pre></td></tr></table></figure></p><p>不过密码就暴露出来了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> NPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何发布一个npm模块</title>
      <link href="/2018/06/07/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/06/07/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>目录<br>一、发布普通 npm 模块<br>二、发布 scoped package </p></blockquote><a id="more"></a><h1 id="一、发布普通-npm-模块"><a href="#一、发布普通-npm-模块" class="headerlink" title="一、发布普通 npm 模块"></a>一、发布普通 npm 模块</h1><h2 id="1-注册一个-npm-账号"><a href="#1-注册一个-npm-账号" class="headerlink" title="1.注册一个 npm 账号"></a>1.注册一个 npm 账号</h2><p>进入<a href="https://www.npmjs.cn/signup" target="_blank" rel="noopener">官网</a>注册 npm 账号。</p><h2 id="2-初始化包描述文档"><a href="#2-初始化包描述文档" class="headerlink" title="2.初始化包描述文档"></a>2.初始化包描述文档</h2><p>在你要发布的模块工程根目录下，初始化 package.json (如果没有的话)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></p><p>package.json 中 npm 所需的主要几个关键字段：</p><ul><li>name: 包名，必须唯一，不能跟npm上的包重名。可以在 npm 官网搜索名字，如果存在则需要换个名字。</li><li>version: 版本号，每次发布至 npm 都需要修改版本号，不能比上一次发布的版本号低。</li><li>description: 描述。</li><li>main: 入口文件，需指向我们编译后的包文件。</li><li>keyword: 关键字，以空格分离，希望用户搜索的词。</li><li>author: 作者。</li><li>private: 是否私有，需要修改为 false 才能发布到 npm。</li><li>license: 开源协议。</li></ul><h2 id="3-添加账号授权"><a href="#3-添加账号授权" class="headerlink" title="3.添加账号授权"></a>3.添加账号授权</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm adduser</span><br></pre></td></tr></table></figure><p>然后根据提示一步一步输入你的 npm 账号、密码和邮箱。<br>然后你可以通过如下命令来验证登录是否正确。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm whoami</span><br></pre></td></tr></table></figure></p><h2 id="4-发布"><a href="#4-发布" class="headerlink" title="4.发布"></a>4.发布</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><h1 id="二、发布-scoped-package"><a href="#二、发布-scoped-package" class="headerlink" title="二、发布 scoped package"></a>二、发布 scoped package</h1><p>scope是npm的新特性。如果一个模块的名字以 <code>@</code> 开头，那它就是一个 scoped package:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@scope/project-name</span><br></pre></td></tr></table></figure></p><blockquote><p>每一个npm用户都有拥有一个自己的 scope：当前用户名 username。</p></blockquote><h2 id="初始化一个-scoped-package"><a href="#初始化一个-scoped-package" class="headerlink" title="初始化一个 scoped-package"></a>初始化一个 scoped-package</h2><p>通过在包名字前添加 scope：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;@usernane/project-name&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以使用 <code>npm init</code> 命令自定义 <code>--scope</code> 选项来设置scope：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init --scope=username</span><br></pre></td></tr></table></figure></p><p>如果你在大多数时候使用的 scope 都是相同的，可以设置一个默认的 scope，这样每次初始化的时候会自动使用该 scope：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> scope &lt;your_scope&gt;</span><br></pre></td></tr></table></figure></p><h2 id="发布-scoped-package"><a href="#发布-scoped-package" class="headerlink" title="发布 scoped-package"></a>发布 scoped-package</h2><p>发布 scoped 模块跟发布普通模块一样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></p><p>默认状态下scoped package包是私有的。然而，你可以把 scoped package 免费滴发布为公共包。只需要在发布时配置 <code>--access</code> 选项即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --access=public</span><br></pre></td></tr></table></figure></p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="1-确认镜像源"><a href="#1-确认镜像源" class="headerlink" title="1. 确认镜像源"></a>1. 确认镜像源</h2><p>发布npm包之前，首先一定要确保使用的是npm官方镜像源。如果你使用了<code>nrm</code>来管理镜像，可以通过<code>nrm ls</code>来查看下当前使用的是什么源，如果不是 npmjs 官方镜像，比如 taobao，那么使用<code>nrm use npm</code>切换过来。</p><h2 id="2-预检查包内容"><a href="#2-预检查包内容" class="headerlink" title="2. 预检查包内容"></a>2. 预检查包内容</h2><p>发包之前可以通过 <code>npm pack</code> 命令在本地产生一个tgz压缩包，里面的文件就是你将要传到 npm 的内容。如果有遗漏或者多了不需要发布的文件，则可以通过调整 <code>.npmignore</code> 文件的配置来调整。</p><h2 id="3-检查包名是否重名"><a href="#3-检查包名是否重名" class="headerlink" title="3. 检查包名是否重名"></a>3. 检查包名是否重名</h2><p>包名字不能与 npm 中已有的包同名，如果已存在同名包，否则会提交失败。通过在 npm 官网搜索包名，如已存在，则需要换一个。</p><h2 id="4-检查版本号"><a href="#4-检查版本号" class="headerlink" title="4. 检查版本号"></a>4. 检查版本号</h2><p>每次提交版本号都要比上次的高，否则也会提交失败。从 npm 上查看自己上次发布的版本号，如果相同说明忘记更新版本号，根据需要通过 <code>npm version</code> 命令修改版本。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> NPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件版本命名规范</title>
      <link href="/2018/06/04/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/2018/06/04/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="软件版本阶段"><a href="#软件版本阶段" class="headerlink" title="软件版本阶段"></a>软件版本阶段</h3><h4 id="开发期"><a href="#开发期" class="headerlink" title="开发期"></a>开发期</h4><ul><li><p>Base版<br>此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是页面中的功能都没有做完成的实现，只是作为整体网站的一个基础架构。</p></li><li><p>Alpha版<br>软件的初级版本，此版本表示软件处于以实现软件功能为主的阶段，通常只在软件开发者内部交流，一般而言，该版本软件的bug较多，需要继续修改。测试人员条bug经开发人员修改确认后，发布到测试网址让测试人员测试，此时可将软件版本标注为alpha版。</p></li><li><p>Beta版<br>此版本相对于alpha版已有了很大的改进，消除了严重的错误，但还存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对象是软件的UI。</p></li></ul><a id="more"></a><ul><li>RC（Release Candidate）版<br>最终测试版，此版本已经相当成熟了，基本上不存在导致错误的bug，与即将发行的正式版相差无几。可能成为最终产品的候选版本，如果未出现问题，则可发布称为正式版本，多数开源软件会推出两个RC版本，卒后的RC2则称为正式版本。</li></ul><ul><li>Release版<br>此版本意味着“最终版本”，是最终交付用户使用的一个版本。该版本又是也称为标准版本。一般情况下Release不会以单词形式出现在软件封面上，取而代之的是符号（R）。</li></ul><h4 id="完成期"><a href="#完成期" class="headerlink" title="完成期"></a>完成期</h4><ul><li><p>stable<br>稳定版，来自于蓝版本修改修正完成。</p></li><li><p>GA（General Availability）<br>正式发布的版本，在国外都是用GA来说明release版本的。</p></li><li><p>RTM（Release to Manufacturing）<br>给生产商的release版本，RTM版本并不一定意味着创作者解决软件的所有问题，仍有可能在向公众发布前更新版本。<br>另外一种RTM的称呼是RTM（Release To Web），表示正式版本的软件发布到Web网站上供客户免费下载。</p></li><li><p>RTL（Retail）<br>零售版，是真正的正式版，正式降价零售版。</p></li></ul><h3 id="软件版本命名规范"><a href="#软件版本命名规范" class="headerlink" title="软件版本命名规范"></a>软件版本命名规范</h3><p>软件版本号由4部分组成：<br>主版本号.子版本号.阶段版本号.日期版本号加希腊字母版本号（希腊字母版本号共有5种：base、alpha、beta、RC、release）。<br>例如：1.1.1.180604_beta</p><h4 id="版本号修改规则"><a href="#版本号修改规则" class="headerlink" title="版本号修改规则"></a>版本号修改规则</h4><ul><li><p>主版本号：当功能模块有较大的变动，比如增加多个模块活着整体架构发生变化，此版本号有项目决定是否修改。</p></li><li><p>子版本号：当功能有一定的增加或变化。此版本由项目决定是否修改。</p></li><li><p>修订版本号：一般是bug修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的bug即可发布一个修订版。此版本由项目经理决定是否修改。</p></li><li><p>日期版本号：用于记录修改项目的当前日志，每天对项目的修改都需要更改日期版本号。此版本号由开发人员决定是否修改。</p></li><li><p>希腊字母版本号：此版本号用语标注当前版本的软件处于哪个开发阶段，当软件进入到另一个阶段时，需要修改此版本号。此版本号由项目决定是否修改。</p></li></ul><blockquote><p><code>注：上一级有变动时，下级要归零。</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> version </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设置linux虚拟机网络</title>
      <link href="/2018/05/28/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AElinux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2018/05/28/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AElinux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建自己的gitlab服务</title>
      <link href="/2018/05/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84gitlab%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/05/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84gitlab%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>gitlab 是一个基于 web 的 git 仓库管理工具。gitlab 拥有 github 拥有的一切，并且拥有更多，更重要的是，它是开源的！我们可以直接 gitlab 在线服务，也可以通过购买他们的付费服务，或者使用开源服务搭建自己的私服，来托管团队项目代码。自己搭建一个 gitlab 私服也不难，只需4步。</p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>GitHub、GitLab 以及 Bitbucket ，相信大家都已经耳熟能详，它们是目前最流行的三大代码托管平台 。我们使用 git 管理的项目，要想实现远程协作，就得依赖这类托管平台。</p><p>我们可以直接使用这三家提供的在线服务，也可以通过购买他们的付费服务，或者使用开源服务搭建自己的私服，来托管团队项目代码。</p><h1 id="搭建Gitlab"><a href="#搭建Gitlab" class="headerlink" title="搭建Gitlab"></a>搭建Gitlab</h1><p>gitlab 是一个基于 web 的 git 仓库管理工具。gitlab 拥有 github 拥有的一切，并且拥有更多，更重要的是，它是开源的！</p><p>搭建一个 gitlab 私服只需如下4步：</p><ol><li>准备linux环境</li><li>安装gitlab</li><li>配置gitlab</li><li>启动gitlab</li></ol><h2 id="准备linux环境"><a href="#准备linux环境" class="headerlink" title="准备linux环境"></a>准备linux环境</h2><p>gitlab必须安装在linux操作系统上，因此必须要有一个linux操作系统环境。gitlab目前支持的linux操作系统有：</p><ul><li>Ubuntu</li><li>Debian</li><li>CentOs</li><li>openSUSE<br>等。</li></ul><p>如果你的服务器是 linux 系统，则可以跳过这一步。如果你的服务器是 windows 系统，也没有关系，可以使用虚拟机。</p><ol><li>安装虚拟机。oracle 公司的 virtual box 或者 vmware 都是很好的选择。</li><li>下载 linux 操作系统镜像。desktop 或者 server 版都行。</li><li>安装、配置镜像。因为要作为长期使用的代码托管服务，各项参数尽量配高一些。</li></ol><p>我的虚拟机（virtual box ）配置：</p><ul><li>linux版本：ubuntu 16.04 LTS</li><li>CPU：8核</li><li>内存：16G</li><li>硬盘：100G</li></ul><h2 id="安装gitlab"><a href="#安装gitlab" class="headerlink" title="安装gitlab"></a>安装gitlab</h2><p>gitlab 是开源的，可以去 gitlab 官网 <code>https://about.gitlab.com/</code> 获取相应 linux 版本支持的镜像安装地址。比如我需要的是 ubuntu 版本的 gitlab。</p><h3 id="在线自动安装"><a href="#在线自动安装" class="headerlink" title="在线自动安装"></a>在线自动安装</h3><p>如果你的服务器可以联外网，可以以下步骤进行在线自动安装：</p><ol><li><p>在 linux 服务器打开一个终端，安装配置依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y curl openssh-server ca-certificates</span><br></pre></td></tr></table></figure></li><li><p>添加gitlab包，并自动安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure></li></ol><h3 id="离线解决方案"><a href="#离线解决方案" class="headerlink" title="离线解决方案"></a>离线解决方案</h3><p>因为我当时所在的网络不能访问该镜像地址，所以官网的方式行不通。不过幸好 gitlab 提供了手动安装的离线包，最终通过离线包安装的方式安装成功。</p><ol><li>先将离线包<a href="https://packages.gitlab.com/gitlab/gitlab-ce" target="_blank" rel="noopener">下载</a>下来，放到 virtual box 与宿主机的共享目录（需要设置一下虚拟机），比如 <code>mnt/share</code>。你也可以通过远程工具（比如 filezilla）把镜像直接传到 ​linux 服务器上。​</li></ol><ol><li><p>然后在 linux 服务器打开一个终端，通过如下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i /mnt/share/gitlab-ce_10.1.4-ce.0_amd64.deb</span><br></pre></td></tr></table></figure></li><li><p>安装成功后的终端信息显示如下：<br><img src="/images/gitlab-install-success.png" alt="gitlab 安装成功"></p></li></ol><h2 id="配置gitlab"><a href="#配置gitlab" class="headerlink" title="配置gitlab"></a>配置gitlab</h2><p>要修改的配置都在 /ect/gitlab/gitlab.rb 这个文件里面。<br>我这里主要是修改 URL 为我自己服务器的域名以及端口（我为我的 linux 虚拟机申请了域名，具体操作见 <a href="https://yc111.github.io/2018/05/28/如何设置linux虚拟机网络/" target="_blank" rel="noopener">如何设置linux网络</a>）：找到 gitlab.rb 文件中的 <code>EXTERNAL_URL</code> 字段，将其修改为我的域名，端口设为80。</p><p>这样你的项目 clone 的地址URL就会变成你设置的域名而不是IP地址了。</p><p>然后运行如下命令让修改生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></p><h2 id="启动gitlab"><a href="#启动gitlab" class="headerlink" title="启动gitlab"></a>启动gitlab</h2><p>最后通过如下命令启动 gitlab<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure></p><p>查看一下 gitlab 各服务器状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl status</span><br></pre></td></tr></table></figure></p><p>如果你的服务器内置了浏览器，现在就可以在浏览器中输入 localhost 预览 gitlab。</p><p>首次访问gitlab界面，会要求你设置root账号的密码：<br><img src="/images/gitlab-first-access.png" alt="首次访问gitlab界面"></p><p>使用刚才重置后的 root 账号登录 gitlab<br><img src="/images/gitlab-root-login.png" alt="使用刚才重置后的root账号登录进入gitlab的界面"></p><p>退出 root 账号后， 进入 gitlab 注册登录页：<br><img src="/images/gitlab-logout.png" alt="退出root账号的gitlab界面"></p><h2 id="至此，就完成了gitlab的整个搭建过程"><a href="#至此，就完成了gitlab的整个搭建过程" class="headerlink" title="至此，就完成了gitlab的整个搭建过程"></a>至此，就完成了gitlab的整个搭建过程</h2><p>现在，在任何一台可联网的电脑上，输入你的 linux 服务器域名（或者 IP 地址），就可以访问你刚刚搭建好的 gitlab 私服了。接下来请愉快地在上面注册账号，创建项目，协作开发吧！</p><p>本文已经同步到我的公众号「前端手札」，喜欢的话可以关注一下哦。</p><p><img src="/images/qianduanshouzha-gzh.png" alt="qianduanshouzha-gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> GitLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> full stack </tag>
            
            <tag> git </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2018/04/25/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/04/25/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git 常用命令记录。（持续更新）</p></blockquote><a id="more"></a><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="2-用户名邮箱配置"><a href="#2-用户名邮箱配置" class="headerlink" title="2. 用户名邮箱配置"></a>2. 用户名邮箱配置</h3><p>设置全局用户属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;champyin&quot;</span><br><span class="line">git config --global user.email &quot;champyin@163.com&quot;</span><br></pre></td></tr></table></figure></p><blockquote><p>–global: 设置当前用户的全局属性，当你的 repository 没有设置项目的 user.name 和 user.email 的时候，会默认用这个。</p></blockquote><p>查看全局用户属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure></p><p>如何知道本地有没有设置属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br></pre></td></tr></table></figure></p><p>如何设置本地属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;champyin002&quot;</span><br><span class="line">gut config user.email &quot;champyin002@163.com&quot;</span><br></pre></td></tr></table></figure></p><h3 id="3-远程仓库管理"><a href="#3-远程仓库管理" class="headerlink" title="3. 远程仓库管理"></a>3. 远程仓库管理</h3><p>克隆远程仓库到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;remote-repo-url&gt;</span><br></pre></td></tr></table></figure></p><p>查看当前配置有哪些远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote </span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><blockquote><p><code>git remote</code> 列出每个远程仓库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程仓库<br><code>git remote -v</code> 显示对应的远程仓库地址。<code>-v</code> 为 <code>-verbose</code> 的简写。</p></blockquote><p>添加远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure></p><blockquote><p>[shortname]是自己为远程仓库取的一个简单的名字，便于以后引用。</p></blockquote><p>修改远程仓库协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:lovecoding/lovecoding.github.io.git</span><br></pre></td></tr></table></figure></p><blockquote><p>将远程仓库origin改为git协议的地址。</p></blockquote><p>查看远程仓库信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name]</span><br><span class="line">git remote show origin #查看所克隆的origin仓库</span><br></pre></td></tr></table></figure></p><p>重命名远程仓库（修改某个远程仓库在本地的简称）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename origin sam #把远程仓库 origin 重命名为 sam</span><br></pre></td></tr></table></figure></p><blockquote><p>对远程仓库的重命名，也会使对应的分支名称发生变化。原来的 origin／master 分支现在成为了 sam／master。</p></blockquote><p>本地移除对应的远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm sam</span><br></pre></td></tr></table></figure></p><h3 id="4-分支管理"><a href="#4-分支管理" class="headerlink" title="4. 分支管理"></a>4. 分支管理</h3><p>查看本地分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>查看各个分支最后一个提交对象的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure></p><p>查看远程分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></p><p>查看所有分支，包括本地和远程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></p><p>创建分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch mytest1</span><br></pre></td></tr></table></figure></p><p>切换分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout mytest1</span><br></pre></td></tr></table></figure></p><p>创建并切换到该分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b mytest2</span><br></pre></td></tr></table></figure></p><p>重命名分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m existBranch newName</span><br></pre></td></tr></table></figure></p><p>重命名当前分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m newName</span><br></pre></td></tr></table></figure></p><p>删除空分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d mytest1</span><br></pre></td></tr></table></figure></p><p>删除有内容的分支，上方的命令会被拒绝，需要使用<code>-D</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D mytest1</span><br></pre></td></tr></table></figure></p><p>删除远程分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete mytest1 //git v1.70 以上</span><br><span class="line">// or</span><br><span class="line">git push origin :mytest1 //git v1.5.0以上 推送一个空的分支到远程分支。</span><br></pre></td></tr></table></figure></p><p>同步远程删除的分支到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote prune [remote-name]</span><br><span class="line">#or</span><br><span class="line">git fetch -p</span><br></pre></td></tr></table></figure></p><p>查看分支于远程的映射关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure></p><h3 id="5-获取远程分支代码"><a href="#5-获取远程分支代码" class="headerlink" title="5. 获取远程分支代码"></a>5. 获取远程分支代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull [remote-name] [remote-branch-name]:[local-branch-name]</span><br><span class="line">git pull origin bugfix:master</span><br></pre></td></tr></table></figure><blockquote><p>注意，分支推送、拉取命令的写法规则是&lt;来源地&gt;:&lt;目的地&gt;。所以 git pull 是[remote-branch-name]:[local-branch-name]，git push 是[local-branch-name]:[remote-branch-name]。</p></blockquote><h3 id="6-上传代码到远程仓库"><a href="#6-上传代码到远程仓库" class="headerlink" title="6. 上传代码到远程仓库"></a>6. 上传代码到远程仓库</h3><p>push 某个分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br><span class="line">git push origin master  # 把本地的master分支推送到远程的origin仓库的master分支。</span><br></pre></td></tr></table></figure></p><p>如果远程有一个 bugfix 分支，我想要有一份自己的 bugfix 来开发。<br>先将远程分支抓取下来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure></p><p>在远程分支的基础上分化一个新的本地分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [local-branch-name] [remote-name]/[remote-branch-name]</span><br><span class="line">git chechout -b bugfix origin/bugfix</span><br></pre></td></tr></table></figure></p><blockquote><p>采用此命令建立的本地分支会自动和远程分支建立映射关系。</p></blockquote><p>修改完代码后，上传到远程 bugfix 分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br><span class="line">git push origin bugfix</span><br><span class="line"># or</span><br><span class="line">git push [remote-name] [local-branch-name]:[remote-branch-name]</span><br><span class="line">git push origin bugfix:bugfix #实现跟上一条命令同样的效果。</span><br></pre></td></tr></table></figure></p><blockquote><p><code>git push origin bugfix</code> 意思为取出在本地的 bugfix 分支，推送到远程仓库的 bugfix 分支中去。<br><code>git push orign bugfix:bugfix</code> 意思为上传完本地的bugfix分支到远程仓库中去，仍旧称它为 bugfix 分支。实现跟上一条命令相同的效果。通过此语法，可以把本地分支推送到某个命名不同的远程分支：例如使用<code>git push origin bugfix:hotfix</code> 来推送，如果远程分支 hotfix 不存在，则会在远程仓库被新建。当我的协作者再次从服务器上抓取数据时，他们将得到一个新的远程分支 origin／hotfix.</p></blockquote><p>push 所有分支（不管是否存在对应的远程分支，将本地的所有分支都推送到远程仓库）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push --all [remote-name]</span><br><span class="line">#example</span><br><span class="line">git push --all origin</span><br></pre></td></tr></table></figure></p><h3 id="7-打tag"><a href="#7-打tag" class="headerlink" title="7. 打tag"></a>7. 打tag</h3><blockquote><p>注意：tag是打在commit上，不是分支上。</p></blockquote><p>轻量级标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0</span><br></pre></td></tr></table></figure></p><p>给历史提交打标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0 88aa731 #历史commit的id的前7位</span><br></pre></td></tr></table></figure></p><p>查看标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></p><p>搜索符合模式的tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l &apos;v0.1.*&apos;</span><br></pre></td></tr></table></figure></p><p>将本地标签同步到远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags #提交所有的tag</span><br><span class="line">git push origin v1.0.0 #提交单个tag</span><br></pre></td></tr></table></figure></p><p>切换到tag</p><blockquote><p>与切换到分支命令相同</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [tagname]</span><br></pre></td></tr></table></figure><p>查看tag信息</p><blockquote><p>用 <code>git show</code> 命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v0.1.1</span><br></pre></td></tr></table></figure><p>删除本地标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1.0.0</span><br></pre></td></tr></table></figure></p><p>将删除标签同步到远程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v1.0.0 #推送空的同名版本到远程</span><br></pre></td></tr></table></figure></p><p>拉取某个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin tag v1.0.0</span><br></pre></td></tr></table></figure></p><h3 id="8-查看提交历史日志"><a href="#8-查看提交历史日志" class="headerlink" title="8. 查看提交历史日志"></a>8. 查看提交历史日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline --abbrev-commit #将commit id显示为缩写（前7位）</span><br></pre></td></tr></table></figure><p>退出查看日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure></p><h3 id="9-删除本地untrack-file"><a href="#9-删除本地untrack-file" class="headerlink" title="9. 删除本地untrack file"></a>9. 删除本地untrack file</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -fd // 删除本地的untrack文件和文件夹</span><br></pre></td></tr></table></figure><h3 id="10-修改已经提交的信息"><a href="#10-修改已经提交的信息" class="headerlink" title="10. 修改已经提交的信息"></a>10. 修改已经提交的信息</h3><p>当你不小心写错了提交信息，理论上，SCM上是不应该修改历史信息的，但是在git中可以修改最后一次提交的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></p><p><code>amend</code> 参数提供了对最后一次commit的修改，对于历史提交，如果想修改，就必须使用 <code>rebase</code> 了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3  #表示要修改当前版本的倒数第三次状态。</span><br></pre></td></tr></table></figure></p><h3 id="11-取消对某个工作区文件的修改"><a href="#11-取消对某个工作区文件的修改" class="headerlink" title="11. 取消对某个工作区文件的修改"></a>11. 取消对某个工作区文件的修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;...</span><br><span class="line">// 例如:</span><br><span class="line">git checkout -- src/views/suport.vue</span><br></pre></td></tr></table></figure><p>该指令的作用是把文件在工作区的修改全部撤销：如果这个文件修改后没有放到暂存区，那撤销修改就回到版本库中的状态（即回到最近一次 <code>git commit</code> 时的状态）；如果这个文件在添加到暂存区后又做了修改，那撤销修改就回到添加暂存区后的状态（即回到最近一次 <code>git add</code> 时的状态）。</p><p>放弃所有修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure></p><h3 id="12-review-changes-查看文件的修改之处"><a href="#12-review-changes-查看文件的修改之处" class="headerlink" title="12. review changes 查看文件的修改之处"></a>12. review changes 查看文件的修改之处</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;file&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注：只能在 <code>git add</code> 之前才能查看到修改的内容</p></blockquote><h3 id="13-其他命令"><a href="#13-其他命令" class="headerlink" title="13. 其他命令"></a>13. 其他命令</h3><p>查看所有文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files # 列出工作区的所有文件</span><br></pre></td></tr></table></figure></p><p>查看某段代码是谁写的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file-name&gt; # 会列出每行代码的提交id、作者以及提交时间。</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置git环境之设置SSH key</title>
      <link href="/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AESSH-key/"/>
      <url>/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AESSH-key/</url>
      
        <content type="html"><![CDATA[<h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><p>配置ssh秘钥，以及使用git协议，每次pull、push可以免去输入账号密码的麻烦。不过记得查看下远程仓库地址是不是https协议，如果是就要要改成git协议才可以不用输入密码。</p><p>配置过程很简单，只需2步：</p><a id="more"></a><h3 id="1-生成秘钥对"><a href="#1-生成秘钥对" class="headerlink" title="1. 生成秘钥对"></a>1. 生成秘钥对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;lovecoding@163.com&quot;</span><br></pre></td></tr></table></figure><p>提示输入文件，直接回车。<br>提示输入密码，直接回车。<br>得到公钥文件id_rsa.pub</p><h3 id="2-设置远程仓库上的秘钥"><a href="#2-设置远程仓库上的秘钥" class="headerlink" title="2. 设置远程仓库上的秘钥"></a>2. 设置远程仓库上的秘钥</h3><p>查看公钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>复制公钥内容，进入github，在setting里，新建SHH key，将公钥内容填进去。</p><h3 id="验证key是否正常工作："><a href="#验证key是否正常工作：" class="headerlink" title="验证key是否正常工作："></a>验证key是否正常工作：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果看到”Hi lovecoding！ you’ve successfully authenticated, but GitHub does not provide shell access.说明设置成功。</p><h3 id="3-将远程仓库地址设置为git协议"><a href="#3-将远程仓库地址设置为git协议" class="headerlink" title="3. 将远程仓库地址设置为git协议"></a>3. 将远程仓库地址设置为git协议</h3><p>查看reomte<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><p>如果发现是https协议的，修改remote<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url remotename git@github.com:useraccount/reponame.git</span><br></pre></td></tr></table></figure></p><h3 id="4-如果到了这一步，提交还提示输入账号密码，那就还要修改下项目配置中的git提交地址"><a href="#4-如果到了这一步，提交还提示输入账号密码，那就还要修改下项目配置中的git提交地址" class="headerlink" title="4. 如果到了这一步，提交还提示输入账号密码，那就还要修改下项目配置中的git提交地址"></a>4. 如果到了这一步，提交还提示输入账号密码，那就还要修改下项目配置中的git提交地址</h3><p>查看项目git配置信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></p><p>此时remote.origin.url的值应该还是https的那个地址。我们需要将它改成git协议的repo地址。<br>这个配置文件在当前项目下的.git目录下的config文件里，我们编辑它，修改remote.origin.url即可。</p><p>这个时候，再来push更新，一定不会再要你输入账号密码了。</p><h3 id="完美！"><a href="#完美！" class="headerlink" title="完美！"></a>完美！</h3>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置git环境之设置remote url的传输协议</title>
      <link href="/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AEremote-url%E7%9A%84%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AEremote-url%E7%9A%84%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="把git的remote-url改为git协议。"><a href="#把git的remote-url改为git协议。" class="headerlink" title="把git的remote url改为git协议。"></a>把git的remote url改为git协议。</h2><p>查看当前remote url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><p>如果是https开头，使用set-url来调整：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:lovecoding/lovecoding.github.io.git</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置git环境之设置用户名和邮箱</title>
      <link href="/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1/"/>
      <url>/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="设置用户名邮箱"><a href="#设置用户名邮箱" class="headerlink" title="设置用户名邮箱"></a>设置用户名邮箱</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;lovecoding@163.com&quot;</span><br><span class="line">git config --global user.name &quot;lovecoding&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶(一)：下载hexo主题，配置博客界面</title>
      <link href="/2018/04/07/%E8%BF%9B%E9%98%B6-%E4%B8%80-%EF%BC%9A%E4%B8%8B%E8%BD%BDhexo%E4%B8%BB%E9%A2%98%EF%BC%8C%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E7%95%8C%E9%9D%A2/"/>
      <url>/2018/04/07/%E8%BF%9B%E9%98%B6-%E4%B8%80-%EF%BC%9A%E4%B8%8B%E8%BD%BDhexo%E4%B8%BB%E9%A2%98%EF%BC%8C%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>hexo主题的下载、安装、启用、验证、和部署。</p></blockquote><a id="more"></a><h2 id="进阶：下载hexo主题，配置博客界面"><a href="#进阶：下载hexo主题，配置博客界面" class="headerlink" title="进阶：下载hexo主题，配置博客界面"></a>进阶：下载hexo主题，配置博客界面</h2><h3 id="1-下载安装hexo主题"><a href="#1-下载安装hexo主题" class="headerlink" title="1. 下载安装hexo主题"></a>1. 下载安装hexo主题</h3><p>经筛选，我选择NexT主题作为我的博客主题。<br>进入blog目录，克隆 <code>hexo-theme-next</code> 主题代码到blog目录下的 <code>themes/next</code> 路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><h3 id="2-启用NexT主题"><a href="#2-启用NexT主题" class="headerlink" title="2. 启用NexT主题"></a>2. 启用NexT主题</h3><p>打开blog根目录下的_config.yml，找到theme字段，将其修改为next。</p><h3 id="3-验证主题"><a href="#3-验证主题" class="headerlink" title="3. 验证主题"></a>3. 验证主题</h3><p>启动hexo本地站点，并启动调试模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure></p><p>当出现 <code>“INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.”</code> 说明启动成功。<br>在浏览器访问localhost:4000，检查主题是否生效。</p><h3 id="4-将新的博客主题部署到github-io"><a href="#4-将新的博客主题部署到github-io" class="headerlink" title="4. 将新的博客主题部署到github.io"></a>4. 将新的博客主题部署到github.io</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>出现 <code>done: git</code> 后，刷新 <a href="https://yc111.github.io" target="_blank" rel="noopener">yc111.github.io</a>，可以看到主题已经变成了next主题。</p><p>更多的关于hexo和next配置，可以参考如下链接。<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo文档</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用hexo+github建立自己的博客</title>
      <link href="/2018/04/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo-github%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/04/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo-github%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>利用hexo和github搭建自己的博客网站并不复杂，只需follow以下3个steps：</p><ol><li>创建github.io page</li><li>搭建本地hexo环境</li><li>将github.io page与hexo关联起来</li></ol><a id="more"></a><h2 id="一、创建github-io-page"><a href="#一、创建github-io-page" class="headerlink" title="一、创建github.io page"></a>一、创建github.io page</h2><h3 id="1-首先要有github账号，没有的话去github-com注册一个。"><a href="#1-首先要有github账号，没有的话去github-com注册一个。" class="headerlink" title="1. 首先要有github账号，没有的话去github.com注册一个。"></a>1. 首先要有github账号，没有的话去<a href="https://github.com" target="_blank" rel="noopener">github.com</a>注册一个。</h3><p>github是一个基于git的web协作社区。</p><h3 id="2-在github上创建一个特殊的repository"><a href="#2-在github上创建一个特殊的repository" class="headerlink" title="2. 在github上创建一个特殊的repository"></a>2. 在github上创建一个特殊的repository</h3><p>特殊在哪呢？这个repo的名字格式被要求为这样：”[your-github-account-name].github.io” 。<br>例如我的账号名是’yc111’，那我的这个repo就是 <code>yc111.github.io</code> 。<br>注意：一定要用 你的github账号名 加上 .github.io 这一整串作为这个 repository 的名字，不能是其他名字，否则不会生成github.io根域名的page。<br>关于这个，在这里<a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="noopener">User, Organization, and Project Pages</a>可以看到更详细的解释。</p><h3 id="3-向第2步创建的仓库任意上传一份文件"><a href="#3-向第2步创建的仓库任意上传一份文件" class="headerlink" title="3. 向第2步创建的仓库任意上传一份文件"></a>3. 向第2步创建的仓库任意上传一份文件</h3><p>主要用于初始化一下仓库，比如上传一份README.md文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd newRepository</span><br><span class="line">echo &quot;# my github.io page&quot; &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commint&quot;</span><br><span class="line">git remote add origin git@github.com:yc111/yc111.github.io.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>如果是首次使用github，需要先<a href="https://yc111.github.io/2018/04/07/配置git环境之设置用户名和邮箱/" target="_blank" rel="noopener">设置一下用户名和邮箱</a>，以及<a href="https://yc111.github.io/2018/04/07/配置git环境之设置SSH-key/" target="_blank" rel="noopener">配置SSH key</a>，最好再<a href="https://yc111.github.io/2018/04/07/配置git环境之设置remote-url的传输协议/" target="_blank" rel="noopener">将传输协议设置为git协议</a>。</p><h3 id="4-验证-github-io-page-是否创建成功"><a href="#4-验证-github-io-page-是否创建成功" class="headerlink" title="4. 验证 github.io page 是否创建成功"></a>4. 验证 github.io page 是否创建成功</h3><p>进入 github 中该 repository 的 <code>settings</code> 页面，滚动到 <code>Github Page</code> 处，可以看到 <code>“your site is published at https://yc111.github.io/</code><br>进入浏览器，输入 <code>https://yc111.github.io</code> ，页面出来了，显示 “my github.io page” 。<br>说明 github.io page 创建成功。</p><h2 id="二、搭建本地hexo环境"><a href="#二、搭建本地hexo环境" class="headerlink" title="二、搭建本地hexo环境"></a>二、搭建本地hexo环境</h2><p>Hexo是一个高效的静态网站生成框架。通过hexo，可以轻松使用markdown编辑文章。</p><h3 id="1-Hexo是基于node-js的，所以首先要安装node-js。"><a href="#1-Hexo是基于node-js的，所以首先要安装node-js。" class="headerlink" title="1. Hexo是基于node.js的，所以首先要安装node.js。"></a>1. Hexo是基于node.js的，所以首先要安装node.js。</h3><p>去<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">node官网</a>下载最新版，然后安装。</p><h3 id="2-在本地创建一个文件夹，用于存放hexo工程。"><a href="#2-在本地创建一个文件夹，用于存放hexo工程。" class="headerlink" title="2. 在本地创建一个文件夹，用于存放hexo工程。"></a>2. 在本地创建一个文件夹，用于存放hexo工程。</h3><p>为便于描述，假设创建的文件夹命名为：blog。</p><h3 id="3-安装hexo（全局安装）。"><a href="#3-安装hexo（全局安装）。" class="headerlink" title="3. 安装hexo（全局安装）。"></a>3. 安装hexo（全局安装）。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><h3 id="4-初始化hexo。"><a href="#4-初始化hexo。" class="headerlink" title="4. 初始化hexo。"></a>4. 初始化hexo。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h3 id="5-生成静态页面"><a href="#5-生成静态页面" class="headerlink" title="5. 生成静态页面"></a>5. 生成静态页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><h3 id="6-本地启动"><a href="#6-本地启动" class="headerlink" title="6. 本地启动"></a>6. 本地启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>如果看到 <code>“INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.”</code> ，说明启动成功。</p><h3 id="7-打开本地博客网址，验证hexo环境。"><a href="#7-打开本地博客网址，验证hexo环境。" class="headerlink" title="7. 打开本地博客网址，验证hexo环境。"></a>7. 打开本地博客网址，验证hexo环境。</h3><p>在浏览器打开 localhost:4000 ，可以看到hexo自动生成的 <code>hello world</code> 页面，hexo环境搭建成功！</p><h2 id="三、将-github-io-page-与-hexo-关联起来"><a href="#三、将-github-io-page-与-hexo-关联起来" class="headerlink" title="三、将 github.io page 与 hexo 关联起来"></a>三、将 github.io page 与 hexo 关联起来</h2><p>在blog目录下有一个 <code>_config.yml</code> 文件，它是hexo的站点配置文件，要将 github.io 与 hexo 关联起来，首先要配置 <code>_config.yml</code> 里的 <code>deploy</code> 字段。</p><h3 id="1-编辑-config-yml-配置deploy-字段。"><a href="#1-编辑-config-yml-配置deploy-字段。" class="headerlink" title="1. 编辑 _config.yml 配置deploy 字段。"></a>1. 编辑 <code>_config.yml</code> 配置<code>deploy</code> 字段。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><p>翻到最下面，将deploy字段的值配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yc111/yc111.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>注：vim进入编辑的命令为<code>i</code>，退出编辑模式的方法为按<code>ESC</code>键，按<code>:</code>号进入命令模式，保存并退出命令为<code>wq</code>。</p><h3 id="2-安装hexo的deploy工具。"><a href="#2-安装hexo的deploy工具。" class="headerlink" title="2. 安装hexo的deploy工具。"></a>2. 安装hexo的deploy工具。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deploy-git --save</span><br></pre></td></tr></table></figure><h3 id="3-将本地hexo静态网页部署到github上。"><a href="#3-将本地hexo静态网页部署到github上。" class="headerlink" title="3. 将本地hexo静态网页部署到github上。"></a>3. 将本地hexo静态网页部署到github上。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>当出现 <code>“INFO Deploy done：git”</code> 的时候，说明部署完毕。</p><h3 id="4-验证部署结果"><a href="#4-验证部署结果" class="headerlink" title="4. 验证部署结果"></a>4. 验证部署结果</h3><p>在浏览器打开 <a href="http:s//yc111.github.io" target="_blank" rel="noopener">yc111.github.io</a><br>可以看到本地的hexo博客出现在了 github.io 网站上。<br>同时，名为 <code>yc111.github.io</code> 的 repository 下可以看到被上传了文件和代码（hexo工程blog目录下的public目录）<br>说明 github.io page 与 hexo 关联成功！</p><h3 id="一些hexo的常用命令"><a href="#一些hexo的常用命令" class="headerlink" title="一些hexo的常用命令"></a>一些hexo的常用命令</h3><p>以后要部署新的文章，只需按以下步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  #清除缓存，避免一些奇怪的问题</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>其他常用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;newArticleTitle&quot;  #创建文章 可以简写为hexo n</span><br><span class="line">hexo new page &quot;newPageName&quot;  #创建页面</span><br><span class="line">hexo generate  #生成静态页面至public目录 可以简写为hexo g</span><br><span class="line">hexo deploy  #将public目录部署到github 可以简写为hexo d</span><br><span class="line">hexo server  #启动本地服务 可以简写为hexo s</span><br><span class="line">hexo help  #hexo帮助</span><br><span class="line">hexo version  #查看版本信息</span><br></pre></td></tr></table></figure></p><p>组合命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g  #生成页面并启动本地服务</span><br><span class="line">hexo d -g  #生成页面并部署到github</span><br></pre></td></tr></table></figure></p><h3 id="至此，就完成了一个博客网站的搭建。"><a href="#至此，就完成了一个博客网站的搭建。" class="headerlink" title="至此，就完成了一个博客网站的搭建。"></a>至此，就完成了一个博客网站的搭建。</h3>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-widows</title>
      <link href="/2018/04/06/node-widows/"/>
      <url>/2018/04/06/node-widows/</url>
      
        <content type="html"><![CDATA[<h2 id="使用node-windows-将node服务变成windows服务进行管理"><a href="#使用node-windows-将node服务变成windows服务进行管理" class="headerlink" title="使用node-windows 将node服务变成windows服务进行管理"></a>使用node-windows 将node服务变成windows服务进行管理</h2><p><a href="https://www.npmjs.com/package/node-windows" target="_blank" rel="noopener">npm主页</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
