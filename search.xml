<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用echarts展示旅行足迹</title>
      <link href="/2019/09/27/%E5%88%A9%E7%94%A8echarts%E5%B1%95%E7%A4%BA%E6%97%85%E8%A1%8C%E8%B6%B3%E8%BF%B9/"/>
      <url>/2019/09/27/%E5%88%A9%E7%94%A8echarts%E5%B1%95%E7%A4%BA%E6%97%85%E8%A1%8C%E8%B6%B3%E8%BF%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直有个环游世界的梦，周游列国，体验不同国家的人类文明，寻山访水，体验造物主大自然的伟大造化。毕竟人生不止眼前的苟且，还有诗和远方。这么多年以来，陆续走过了一些地方，每到一个地方，都让我离梦想又近了一些。虽然我知道这比起环游世界来说，还差不知道多少个山头，但是我一直在往这个梦努力，靠近。希望终有一天，我可以笑着对自己说，恭喜你，你实现了你的梦想，你的人生很有意义，你没有白活。</p><p>6年前，因为工作的原因，我接触过地图应用的开发，从那时起，我对地图的热爱就埋在了心底。今年年中我带爸妈旅了旅游，去了一些我没去过的地方，我好想有个地图可以让我点亮一下，记录一下我到过的新的“领土”。搜了下市面上已经存在的地图应用，都不是我想要的，唯一比较符合我的需求的是百度旅游里面的一个小功能，叫做足迹地图，但是似乎早就停止了维护，数据停留在2016年。。。</p><p>找不到趁手的工具，那就自己打造一把。是啊，为什么不自己开发一个呢？说干就干。</p></blockquote><a id="more"></a><h2 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h2><p>首先用 <code>cyt-cli</code> 快速搭建项目框架。<a href="https://www.npmjs.com/package/cyt-cli" target="_blank" rel="noopener">cyt-cli地址</a></p><blockquote><p><code>cyt-cli</code> 是一款可以快速创建前端工程的脚手架，具有比较完善的webpack4配置，目前支持纯js、vue、react等语言版本。<br>如果没有安装 <code>cyt-cli</code> ，先全局安装一下：<code>npm i -g cyt-cli</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cyt-cli create footprint</span><br><span class="line">✔ fetching template ...</span><br><span class="line">? please choose a template to create roject (Use arrow keys)</span><br><span class="line">❯ swan-template </span><br><span class="line">  swan-vue-template </span><br><span class="line">  swan-react-template</span><br></pre></td></tr></table></figure><p>因为想快速做出雏形来，所以使用最简单的模版就行，选择第一个 <code>swan-template</code>。<br>等待一会，工程就搭建好了。<br>生成的工程目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">|--build/ # webpack配置文件</span><br><span class="line">|    |-- webpack.base.js</span><br><span class="line">|    |-- webpack.dev.js</span><br><span class="line">|    |-- webpack.prod.js</span><br><span class="line">|--public/ # 首页模版</span><br><span class="line">|    |-- index.html</span><br><span class="line">|--src/</span><br><span class="line">|    |-- assets/ # 静态资源，比如中国地图数据</span><br><span class="line">|    |-- components/ # 项目组件</span><br><span class="line">|    |       |--  foo.js</span><br><span class="line">|    |       |--  bar.js</span><br><span class="line">|    |-- icon/ # 字体图标</span><br><span class="line">|    |-- images/ # 图片资源</span><br><span class="line">|    |-- theme/ # 样式文件</span><br><span class="line">|    |-- index.js # 项目入口</span><br><span class="line">|--.babel.js # babel配置</span><br><span class="line">|--.browserslistrc.json # 浏览器支持规则</span><br><span class="line">|--.gitignore </span><br><span class="line">|--package.json</span><br><span class="line">|--postcss.config.js # postcss插件配置</span><br><span class="line">|--README.md</span><br></pre></td></tr></table></figure></p><p>安装一下依赖包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd footprint</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure></p><h2 id="地图选型"><a href="#地图选型" class="headerlink" title="地图选型"></a>地图选型</h2><p>地图展示我选择了 <code>echarts</code>。 <a href="https://echarts.apache.org" target="_blank" rel="noopener">echarts官网</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save echarts</span><br></pre></td></tr></table></figure></p><h2 id="应用开发"><a href="#应用开发" class="headerlink" title="应用开发"></a>应用开发</h2><p>我的核心需求很简单，就是可以把我去过的国家、省、市在地图上展示出来即可。<br>先实现国内的省，开发逻辑很简单：</p><h3 id="1-引入echarts"><a href="#1-引入echarts" class="headerlink" title="1.引入echarts"></a>1.引入<code>echarts</code></h3><p>按需引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import echarts from &apos;echarts/lib/echarts&apos;;</span><br><span class="line">import &apos;echarts/lib/chart/map&apos;;</span><br><span class="line">import &apos;echarts/lib/component/tooltip&apos;;</span><br><span class="line">import &apos;echarts/lib/component/title&apos;;</span><br><span class="line">import &apos;echarts/lib/component/visualMap&apos;;</span><br><span class="line">import &apos;echarts/lib/component/legend&apos;;</span><br><span class="line">import &apos;echarts/lib/component/toolbox&apos;;</span><br></pre></td></tr></table></figure></p><h3 id="2-处理用户数据"><a href="#2-处理用户数据" class="headerlink" title="2.处理用户数据"></a>2.处理用户数据</h3><p>给<code>series</code>的<code>data</code>用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">let handleData = function(rawdata) &#123;</span><br><span class="line">    rowData.forEach(item =&gt; &#123;</span><br><span class="line">        item.value = FREQUENCY[item.value]</span><br><span class="line">        if (item.value !== NEVER) &#123;</span><br><span class="line">            item.label = &#123; show: true, color: LEBEL_COLOR &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (item.value === NEVER) &#123;</span><br><span class="line">            never.push(item);</span><br><span class="line">        &#125; else if (item.value === ONECE) &#123;</span><br><span class="line">            onece.push(item);</span><br><span class="line">        &#125; else if (item.value === AFEWTIMES) &#123;</span><br><span class="line">            afewtimes.push(item);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            usually.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    series = [usually, afewtimes, onece, never].map((item, index) =&gt; &#123;</span><br><span class="line">        let temp = &#123;</span><br><span class="line">            type: &apos;map&apos;,</span><br><span class="line">            map: mapType,</span><br><span class="line">            roam: true,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">                emphasis: &#123; label: &#123; show: true &#125; &#125;,</span><br><span class="line">                areaColor: &apos;#fff&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        temp.name = legendData[index];</span><br><span class="line">        temp.data = item;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-注册map"><a href="#3-注册map" class="headerlink" title="3.注册map"></a>3.注册<code>map</code></h3><p>echarts有个registerMap方法，echarts.registerMap(mapName, geoJson, specialAreas).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- mapName：地图名称，一定要与option-&gt;series-&gt;map对应的值相同。</span><br><span class="line">- geoJson：GeoJson格式的数据，具体格式见 http://geojson.org/。</span><br><span class="line">- specialAreas：可选。将地图中的部分区域缩放到合适的位置，可以使得整个地图的显示更加好看。</span><br></pre></td></tr></table></figure></p><p>geoJson是地理信息数据，一般都很大，当然通过异步获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">util.get(&apos;assets/china.json&apos;).then(data =&gt; &#123;</span><br><span class="line">    let chinaJson = data;</span><br><span class="line">    myChart.hideLoading();</span><br><span class="line">    // 注册地图</span><br><span class="line">    echarts.registerMap(mapName, chinaJson, &#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>ECharts3提供的矢量地图数据，在4版本后已经不提供下载服务了。官网的解释是“由于部分数据不符合国家《测绘法》规定”。不过，只要不商用，这些矢量数据还是可以使用的。有需要可以到我这里获取<a href="https://github.com/yc111/echarts3-geojson" target="_blank" rel="noopener">https://github.com/yc111/echarts3-geojson</a></p></blockquote><h3 id="4-配置option显示地图"><a href="#4-配置option显示地图" class="headerlink" title="4.配置option显示地图"></a>4.配置option显示地图</h3><p>注册地图后进行其他配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 指定图表的配置项和数据</span><br><span class="line">let option = &#123;</span><br><span class="line">    color: _color,</span><br><span class="line">    title: _title,</span><br><span class="line">    tooltip: _tooltip,</span><br><span class="line">    legend: _legend,</span><br><span class="line">    visualMap: _visualMap,</span><br><span class="line">    toolbox: _toolbox,</span><br><span class="line">    series: series</span><br><span class="line">&#125;;</span><br><span class="line">// 使用刚指定的配置项和数据显示图表</span><br><span class="line">myChart.setOption(option);</span><br></pre></td></tr></table></figure></p><h2 id="添加Travis-CI持续集成"><a href="#添加Travis-CI持续集成" class="headerlink" title="添加Travis CI持续集成"></a>添加Travis CI持续集成</h2><p>花了大概一天时间，雏形做好（感觉很大一部分时间在调地图颜色…）。我把项目部署在了github page上，但是每次build之后，都要手动部署，太麻烦。</p><p>于是我用 Travis CI 给项目做了持续集成，现在只要代码一提交，就会自动部署了。</p><p>具体关于Travis的详细配置，可以参考我的另一篇文章：<a href="http://champyin.com/2019/09/27/%E5%88%A9%E7%94%A8Travis-CI-github%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/">利用Travis CI+github实现持续集成和自动部署</a></p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p>项目预览地址：<a href="http://champyin.com/footprint/">http://champyin.com/footprint/</a><br><img src="/images/footprint.jpg" alt="footprint.jpg"><br>暂时还比较简陋，并且只支持省。以后我会把世界地图，和城市地图都加进来（毕竟也是出过境的人，哈哈），实现地图下钻，并且优化用户数据设置，不断完善下去。</p><p>项目源码地址：<a href="https://github.com/yc111/footprint" target="_blank" rel="noopener">https://github.com/yc111/footprint</a><br>欢迎star。如果你喜欢，可以fork本项目，然后打造属于你自己的足迹应用。</p><p>–<br>欢迎转载，转载请注明出处：<br><a href="https://champyin.com/2019/09/27/%E5%88%A9%E7%94%A8echarts%E5%B1%95%E7%A4%BA%E6%97%85%E8%A1%8C%E8%B6%B3%E8%BF%B9/">https://champyin.com/2019/09/27/%E5%88%A9%E7%94%A8echarts%E5%B1%95%E7%A4%BA%E6%97%85%E8%A1%8C%E8%B6%B3%E8%BF%B9/</a></p><p>本文同步发表于：</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> echarts </tag>
            
            <tag> map </tag>
            
            <tag> footprint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode中如何使编辑器根据屏幕宽度自动换行</title>
      <link href="/2019/09/20/vscode%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%BC%96%E8%BE%91%E5%99%A8%E6%A0%B9%E6%8D%AE%E5%B1%8F%E5%B9%95%E5%AE%BD%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/"/>
      <url>/2019/09/20/vscode%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%BC%96%E8%BE%91%E5%99%A8%E6%A0%B9%E6%8D%AE%E5%B1%8F%E5%B9%95%E5%AE%BD%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>vscode中默认是不会自动换行的，也就是说当你查看一个压缩后的代码后，只会显示一行。。。很难看出内容的多少也不利于查找定位内容。</p></blockquote><a id="more"></a><p>在vscode中可以设置是否自动换行，进入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code -&gt; Preference -&gt; Settings</span><br></pre></td></tr></table></figure></p><p>然后在配置界面，搜索 <code>work-wrap</code>，找到 <code>Editor: Work Wrap</code> 选项：<br><img src="/images/vscode-set-work-wrap1.jpg" alt=""></p><p>将<code>off</code>改成<code>on</code>即可。<br><img src="/images/vscode-set-work-wrap2.jpg" alt=""></p><p>–<br>GoodLuck!</p>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何配置多个ssh key</title>
      <link href="/2019/08/29/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key/"/>
      <url>/2019/08/29/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们都知道在使用git管理代码时，要推送代码到远程仓库时，为了不想每次都输入账号密码，会配置一下ssh key。但是如果你有多个github账号，或者同时还有gitlab或者是gitee账号，我在推送到这三个账号的仓库都不想输入用户名密码，可不可以把github上使用的ssh key跟其他的账号共享呢？我没有这样试过，不过即便是可以，也不太安全吧。最好的做法就是为这些账号分别创建ssh key，分别配置。</p><p>配置单个SSH key，可以参考：<a href="https://champyin.com/2018/04/07/配置git环境之设置SSH-key/">配置git环境之设置SSH key</a>。<br>而配置多个SSH key未必都熟悉。其实方法也很简单：</p></blockquote><a id="more"></a><h4 id="1-生成ssh-key"><a href="#1-生成ssh-key" class="headerlink" title="1. 生成ssh key"></a>1. 生成ssh key</h4><p>第一个，给github用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &apos;xxx@abc.com&apos; -f ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure></p><p>第二个，给gitee用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &apos;xxx@edf.com&apos; -f ~/.ssh/gitee_id_rsa</span><br></pre></td></tr></table></figure></p><p>由于指定了文件名，可以一路回车，不用输入密码。<br>然后～/.ssh目录下会出现4个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">github_id_rsa</span><br><span class="line">github_id_rsa.pub</span><br><span class="line">gitee_id_rsa</span><br><span class="line">gitee_id_rsa.pub</span><br></pre></td></tr></table></figure></p><h3 id="2-在～-ssh-目录下创建config文件。"><a href="#2-在～-ssh-目录下创建config文件。" class="headerlink" title="2. 在～/.ssh 目录下创建config文件。"></a>2. 在～/.ssh 目录下创建config文件。</h3><p>打开～/.ssh目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open ~/.ssh</span><br></pre></td></tr></table></figure></p><p>编辑config文件，写入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># github</span><br><span class="line">Host github.com # host名字可以随意，自己能识别就好，我这里直接使用了网站域名</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br><span class="line"></span><br><span class="line"># gitee</span><br><span class="line">Host my.gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/gitee_id_rsa</span><br></pre></td></tr></table></figure></p><h3 id="3-将为不同账号生成的公钥，填入各自网站的ssh-key配置中。"><a href="#3-将为不同账号生成的公钥，填入各自网站的ssh-key配置中。" class="headerlink" title="3. 将为不同账号生成的公钥，填入各自网站的ssh key配置中。"></a>3. 将为不同账号生成的公钥，填入各自网站的ssh key配置中。</h3><p>可以通过cat查看公钥内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/github_id_rsa.pub</span><br></pre></td></tr></table></figure></p><h3 id="4-检测配置成没成功"><a href="#4-检测配置成没成功" class="headerlink" title="4. 检测配置成没成功"></a>4. 检测配置成没成功</h3><p>检测方法：<code>ssh -T git@Host</code>, Host 就是你之前在config文件中配置的Host 的值。<br>检测github的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>检测gitee的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@my.gitee.com</span><br></pre></td></tr></table></figure></p><p>如果有提示问要不要把这个RSA host key 添加到 <code>konwn_host</code> 列表中，选择yes。<br>最后如果看到类似如下的提示，说明配置成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxxx! You&apos;ve successfully authenticated,but...... access.</span><br></pre></td></tr></table></figure></p><h3 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h3><blockquote><p>科普：SSH：Secure Shell，是建立在应用层基础上的安全协议。github要求推送代码的用户是合法的，所以每次推送都需要输入账号和密码，用于验证你是否为合法用户，为了省去每次都要输入密码的步骤，采用ssh公钥秘钥，也就是ssh key来验证，公钥放到github上，推送代码时，git会检测你本地的私钥是否跟github上的公钥配对。ssh key可以理解为你的身份标识，公钥放在github上表明你是这个项目的一个开发人员，公钥匙可以被截获的，但是私钥在本地别人就无法截获，ssh key可以保证每次传输都是安全的。</p></blockquote><p>Have a nice day!</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm link详解</title>
      <link href="/2019/08/27/npm-link%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/27/npm-link%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>npm install</code> 可以把发布在npmjs平台上的模块包下载到本地，<code>npm istall -g</code> 可以把包下下来的同时，还帮我们配置好全局变量，让我们可以直接使用命令而不是通过node来执行或者配置<code>package.json</code> 的script脚本来run。但这仅限于已经发布的包，那对于未发布的包，要怎么测试使用呢？总不能把一个未经测试的包发布出去然后install下来这样测试吧，这样npm上面的包谁还敢用。所以npm上的包一定只能放经过测试考验的比较完善的包。而包的本地测试，就需要通过npm的一个命令了：<code>npm link</code>。</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>npm link</code> 可以帮助我们模拟包安装后的状态，它会在系统中做一个快捷方式映射，让本地的包就好像install过一样这么使用。</p><a id="more"></a><p>在mac中，我们在终端可以直接敲的命令，其实是在执行<code>/usr/local/bin</code>目录下的脚本，这个目录可以认为是我们的全局命令所在的地方。</p><p>而当我们在<code>npm install -g</code>的时候，其实是将相关文件安装在<code>/usr/local/lib/node_modules</code>目录下，而同时在全局命令<code>/usr/local/bin</code>目录下会有一个映射脚本，将其指向lib下的真实文件。这么做的好处是，可以在保证只有一份可执行文件的前提下，给命令取别名。</p><p>同样的，<code>npm link</code> 做的事情也是一样，唯一的区别是，它在lib下的 <code>node_modules</code> 里不是存的真实的文件，而是存了一个快捷方式，指向你当前执行 <code>npm link</code> 的目录。如果开发的的是node包，则执行的命令名和真实执行的文件入口，则是根据项目的 <code>package.json</code> 里 <code>bin</code> 的配置来获取。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd projectdir</span><br><span class="line">npm link</span><br></pre></td></tr></table></figure><p>然后会看到输出类似如下的链接信息，说明成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/yourpakagename -&gt; /usr/local/lib/node_modules/yourpackagename/xxx</span><br><span class="line">/usr/local/lib/node_modules/yourpackagename/xxx -&gt; /Users/username/Documents/xxx(your real project path)</span><br></pre></td></tr></table></figure></p><h4 id="全局link"><a href="#全局link" class="headerlink" title="全局link"></a>全局link</h4><p>一般是开发node包，可以直接在终端运行的，做<code>npm link</code>之前，需要在 <code>package.json</code> 里配置 <code>bin</code> 字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># package.json</span><br><span class="line">&quot;bin&quot; : &#123;</span><br><span class="line">&quot;yourcommandname&quot;: &quot;./bin/yourcommandname&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再在当前目录下运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure></p><p>成功后，就可以直接在终端执行 <code>yourcommandname</code> 了。</p><h4 id="项目下link"><a href="#项目下link" class="headerlink" title="项目下link"></a>项目下link</h4><p>如果是前端包，不需要直接在终端运行，比如UI组件库，那需要做两次link。<br>先进入待测试组件库目录，将开发的包link到全局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure></p><p>之后，再进入要使用该组件库的工程，然后在工程中link这个组件库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link youruilib</span><br></pre></td></tr></table></figure></p><p>现在你就可以在你的工程中使用这个ui组件库，就好像这个ui库被install到工程中一样。</p><p>GoodLuck！</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在mac中管理和随时切换node版本</title>
      <link href="/2019/08/26/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%AD%E7%AE%A1%E7%90%86%E5%92%8C%E9%9A%8F%E6%97%B6%E5%88%87%E6%8D%A2node%E7%89%88%E6%9C%AC/"/>
      <url>/2019/08/26/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%AD%E7%AE%A1%E7%90%86%E5%92%8C%E9%9A%8F%E6%97%B6%E5%88%87%E6%8D%A2node%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前用windows的电脑的时候，曾使用 <code>nvm-windows</code> 工具来管理开发环境中的node版本。快速在各个版本的node环境中切换的体验非常好。而在mac中，由于开发环境比较稳定，则没有使用这类工具来管理。近期由于项目的需要，有了在mac下频繁切换node版本的需求。才有了这篇文章。</p></blockquote><h2 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h2><p>我根据第一直觉，在npm上搜索 <code>nvm</code>，竟没有 <code>nvm</code> 的精确匹配，搜索结果第一位是一个叫 <code>n</code> 的包，点进去，也没个README说明（其实是当时我的网络不好README没有加载出来…）。(说实话，要不是发现它的作者是tj大神，我后来可能不会再次点开它，可能我就错过了一个非常好的工具。）</p><p>诧异过后，我转到github，搜索 <code>nvm</code>。 找是找到了，然而，它的安装方式，让我觉得不太友好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>为什么nvm没有pacakge版？不如看看那个”连README都没有”的 <code>n</code> 是否能用。我点开了 <code>n</code> 的github页面。详细的使用说明映入眼帘，粗略读了一遍，感觉有戏。仔细操作一遍，这感觉，怎么说呢，这是捡到宝了呀！</p><p><strong> 就它了！ n！ </strong></p><h2 id="如何使用-n-管理mac上的node版本"><a href="#如何使用-n-管理mac上的node版本" class="headerlink" title="如何使用 n 管理mac上的node版本"></a>如何使用 <code>n</code> 管理mac上的node版本</h2><a id="more"></a><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br></pre></td></tr></table></figure><h3 id="2-修改几个本地目录的拥有者"><a href="#2-修改几个本地目录的拥有者" class="headerlink" title="2. 修改几个本地目录的拥有者"></a>2. 修改几个本地目录的拥有者</h3><p>因为node环境是全局的，需要安装到系统目录下，涉及目录有 <code>/usr/local/bin</code>、<code>usr/local/lib</code>、<code>/usr/local/include</code>、<code>/usr/local/share</code>，这几个目录的拥者是root，其他用户没有权限操作他们。如下命令可以将他们的拥有者从root改为当前用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) /usr/local/bin /usr/local/lib /usr/local/include /ur/local/share</span><br></pre></td></tr></table></figure></p><p>另外，n 会在系统目录下创建一个目录，也需要修改下它的拥有者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) /usr/local/n</span><br></pre></td></tr></table></figure></p><p>关于 <code>chown</code> 命令，我的另一篇文章有详细说明：<strong> <a href="https://yc111.github.io/2019/08/26/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9mac%E4%B8%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%A5%E6%9C%89%E8%80%85/" target="_blank" rel="noopener">如何修改mac中文件夹和文件的拥有者</a> </strong></p><h3 id="3-安装指定版本的node"><a href="#3-安装指定版本的node" class="headerlink" title="3. 安装指定版本的node"></a>3. 安装指定版本的node</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n 10.16.3 //下载并安装node 10.16.3</span><br><span class="line">n latest //下载并安装node 最新版本</span><br><span class="line">n lts //下载并安装node 长期稳定维护版</span><br></pre></td></tr></table></figure><h3 id="4-切换node版本"><a href="#4-切换node版本" class="headerlink" title="4. 切换node版本"></a>4. 切换node版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n //列出所有缓存的node版本</span><br><span class="line">    node/4.4.4</span><br><span class="line">  ο node/8.11.1</span><br><span class="line">    node/10.16.3</span><br><span class="line">Use up/down arrow keys to select a version, return key to install, q to quit</span><br><span class="line">-&gt; 上下键选择当前需要的版本，回车</span><br><span class="line">-&gt; done</span><br></pre></td></tr></table></figure><p>用 <code>node -v</code> 查看版本是否生效。</p><h3 id="5-删除node版本"><a href="#5-删除node版本" class="headerlink" title="5. 删除node版本"></a>5. 删除node版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//删除指定版本</span><br><span class="line">n rm xxx</span><br><span class="line">//删除当前版本外的所有版本</span><br><span class="line">n prune</span><br><span class="line">//卸载当前已安装的node</span><br><span class="line">n uninstall</span><br></pre></td></tr></table></figure><h3 id="6-其他命令"><a href="#6-其他命令" class="headerlink" title="6. 其他命令"></a>6. 其他命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n ls //查看已下载的node版本列表</span><br></pre></td></tr></table></figure><p><strong> 补充 </strong><br><code>n</code> 的获取node的源路径为node官网<code>https://nodejs.org/dist/</code>，在国内访问，非常慢，经常由于太慢而发生超时错误导致下载失败。解决方案：修改node镜像源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export N_NODE_DOWNLOAD_MIRROR=https://npm.taobao.org/mirrors/node</span><br></pre></td></tr></table></figure></p><p>将node镜像指向淘宝镜像。再来操作 <code>n</code> 命令，是不是速度嗖嗖的了。</p><p>GOOD LUCK！</p><hr><p>参考：<br>n （npm）：<a href="https://www.npmjs.com/package/n" target="_blank" rel="noopener">https://www.npmjs.com/package/n</a><br>n （github）：<a href="https://github.com/tj/n" target="_blank" rel="noopener">https://github.com/tj/n</a><br>nvm ：<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a><br>nvm-window ：<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> node </tag>
            
            <tag> n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何修改mac中文件夹和文件的拥有者</title>
      <link href="/2019/08/26/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9mac%E4%B8%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%A5%E6%9C%89%E8%80%85/"/>
      <url>/2019/08/26/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9mac%E4%B8%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%8B%A5%E6%9C%89%E8%80%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在mac上开发，涉及在系统目录（指操作系统自带的那些目录，比如<code>／</code>、 <code>／usr</code>、 <code>／usr／local／bin</code>  等）创建文件夹或者文件时，会出现由于权限不足导致创建失败的问题。这是由于，这些目录属于 <code>root</code> 用户， 而当前登录mac的一般都是非root用户，而非root用户没有权限修改root用户直接管辖的目录和文件。那么如何让用户拥有这些目录的修改权限呢？</p></blockquote><a id="more"></a><p>解决办法有两个：</p><ul><li>方法一：改成使用root登录，这样就具有对操作系统的最大权限，可以为所欲为。但是，不推荐这么做，因为太危险。</li><li>方法二：将你要操作的目录的权限从root手里夺过来，也即修改目录的拥有者。推荐。</li></ul><h2 id="如何修改目录的拥有者"><a href="#如何修改目录的拥有者" class="headerlink" title="如何修改目录的拥有者"></a>如何修改目录的拥有者</h2><p>使用linux命令 <code>chown</code> 。 </p><h3 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] 所有者[:组] 文件</span><br></pre></td></tr></table></figure><p><code>chown</code> 将指定文件的拥有者改为指定的用户或者用户组，用户可以是用户名或者用户ID，组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用 <code>chown</code> 命令，在将文件拷贝到另一个用户的目录下后，让用户拥有使用该文件的权限。</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p><strong> 把 <code>／usr/local/bin</code> 和 <code>／usr/local/lib</code> 这两个目录以及其子目录的拥有者从root改成当前用户：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) /usr/local/bin ／usr/local/lib</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li><code>chown</code> change owner 的缩写。</li><li><code>$(whoami)</code> who am i ，获取当前的用户。</li><li><code>-R</code> –recursive 的缩写，递归处理，将指定目录和所有子目录一并处理。</li></ul><p><strong> 执行完命令，可以用 <code>ls -l</code> 来查看一下是否修改成功。</strong></p><h3 id="常用选项列表："><a href="#常用选项列表：" class="headerlink" title="常用选项列表："></a>常用选项列表：</h3><p>必要参数</p><ul><li><code>-c</code> ：–changes 的缩写，当发生改变时输出调试信息，仅显示更改部分的信息</li><li><code>-f</code> ：不显示错误信息，忽略错误信息</li><li><code>-h</code> ：修复符号链接</li><li><code>-R</code> ：–recursive 的缩写, 递归处理，将指定目录以及其子目录下的所有文件一并处理</li><li><code>-v</code> ：–verbose 的缩写, 显示指令执行过程的详细的处理信息<br>选择参数</li><li><code>--help</code> ：显示帮助信息</li><li><code>--version</code> ：显示版本信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iphone AirDrop 无法发现mac的解决办法</title>
      <link href="/2019/08/13/iphone-AirDrop-%E6%97%A0%E6%B3%95%E5%8F%91%E7%8E%B0mac%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2019/08/13/iphone-AirDrop-%E6%97%A0%E6%B3%95%E5%8F%91%E7%8E%B0mac%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前几天想把手机上的照片传到mac上，发现在AirDrop里看不到我的mac了。以为是电脑太久没重启抽了，因为以前是可以找到的。于是重启了mac，结果没用。后来求助网络，才终于搞定。在此记下方法，以备以后遇到同样的问题又忘记怎么处理。</p></blockquote><a id="more"></a><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>先确保手机（iPhone）上的蓝牙打开，<code>AirDrop</code> 开启，并对所有人可见。</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>确保 <code>mac</code> 上 <code>AirDrop</code> 开启。具体操作：打开 <code>Finder</code> 中的 <code>AirDrop</code> ，并设置成 <code>所有人可见</code>。不过此时手机上的 <code>AirDrop</code> 仍然看不到 <code>mac</code>。</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>确保 <code>mac</code> 上蓝牙开启。具体操作：打开 <code>设置</code> -&gt; <code>蓝牙</code> -&gt; <code>打开蓝牙</code>。</p><h2 id="第四步-（关键）"><a href="#第四步-（关键）" class="headerlink" title="第四步 （关键）"></a>第四步 （关键）</h2><!-- more --><p><code>mac</code> 和 <code>iPhone</code> 蓝牙配对。具体操作：在 <code>mac</code> 的蓝牙设置界面，应该可以看到你的 <code>iPhone</code> 了。点击这个 <code>iPhone</code> 旁边的 <code>配对</code> 按钮。然后手机会收到一个配对请求，点接受。等待一会，就会配对成功。</p><p>PS：如果第四部看到手机已经是配对状态，则移除后重新配对。</p><p>这时，在mac和iPhone的AirDrop中就可以互相看见彼此了，然后就可以愉快地互传文件了。</p><p>Have a nice day!</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iphone </tag>
            
            <tag> mac </tag>
            
            <tag> airdrop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加chrome扩展程序技巧</title>
      <link href="/2019/01/29/%E6%B7%BB%E5%8A%A0chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/01/29/%E6%B7%BB%E5%8A%A0chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们给chrome 浏览器添加扩展程序，有时会遭到 chrome 的限制，比如只能通过 chrome 商城添加，而 chrome 商城需要墙外的环境，大多数时候不一定当前电脑可以翻墙。那么就需要一些技巧来添加这些扩展程序。</p></blockquote><a id="more"></a><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li><p>在扩展程序界面，打开开发者模式。</p></li><li><p>然后将下载好的 <code>.crx</code> 扩展程序文件拖拽到插件管理界面。</p></li></ul><blockquote><p>该方法通常是可行的，不过也有的时候赶上某些 chrome 版本，不允许拖拽安装。那么可以尝试第方法2：</p></blockquote><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ul><li><p>首先将下载好的 <code>.crx</code> 扩展程序文件修改后缀为 <code>.rar</code>，然后解压它，在解压的文件夹内，找到 <code>_metadata</code> 文件夹，将下划线去掉，改为 <code>metadata</code>。 </p></li><li><p>然后在 chrome 插件管理界面，打开开发者模式，点击 ‘加载已解压的扩展程序’，选择刚才解压并修改后的文件夹，确定，即可。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
            <tag> browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何创建空白git分支</title>
      <link href="/2019/01/29/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%99%BDgit%E5%88%86%E6%94%AF/"/>
      <url>/2019/01/29/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%99%BDgit%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在管理前端代码工程时，有时需要创建一个干净的分支，比如用于放文档，或者全新的版本分支。但是普通的创建分支命令，会将历史日志带过去。那么对于有代码洁癖和强迫症的人（比如我）来说，是不能忍的。强大的git为我们这些人准备了创建空白git分支的方法。掌握后受用无穷。</p></blockquote><p>步骤：</p><h2 id="1-创建无父节点的分支"><a href="#1-创建无父节点的分支" class="headerlink" title="1. 创建无父节点的分支"></a>1. 创建无父节点的分支</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan orphanbranch</span><br></pre></td></tr></table></figure><p>参数 <code>orphan</code> 的作用一个是拷贝当前所在分支的所有文件，另一个是没有父节点，即意味着没有历史记录，是一个外圈独立的干净的分支。<br><img src="/images/git-checkout---orphan.jpg" alt="git-checkout---orphan.jpg"></p><h2 id="2-删除该分支下所有文件"><a href="#2-删除该分支下所有文件" class="headerlink" title="2. 删除该分支下所有文件"></a>2. 删除该分支下所有文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -rf .</span><br></pre></td></tr></table></figure><p>这个操作不会影响历史记录。即不会在log里面出现delete的日志。<br><img src="/images/git-rm.jpg" alt="git-rm.jpg"></p><h2 id="3-创建一个初始文件，比如readme，并提交"><a href="#3-创建一个初始文件，比如readme，并提交" class="headerlink" title="3. 创建一个初始文件，比如readme，并提交"></a>3. 创建一个初始文件，比如readme，并提交</h2><p>因为在第一步之后，虽然却换到了 <code>newemptybranch</code> 分支，但是通过 <code>git branch -a</code> 是还看不到当前分支的。必须在这个空白的分支进行一次初始提交，才可以看到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch README.md</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;add readme&quot;</span><br></pre></td></tr></table></figure></p><p><img src="/images/git-branch-a.jpg" alt="git-branch-a.jpg"></p><h2 id="4-一个干净的空白分支诞生"><a href="#4-一个干净的空白分支诞生" class="headerlink" title="4. 一个干净的空白分支诞生"></a>4. 一个干净的空白分支诞生</h2><p>现在可以通过分支查看命令看到当前干净分支啦。<br>用日志命令可以看到，当前分支只有一条添加readme的记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br><span class="line">git log --oneline</span><br></pre></td></tr></table></figure></p><p><img src="/images/git-branch-a-git-log.jpg" alt="git-branch-a-git-log.jpg"></p><p>Good luck！</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> branch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶(四)：给博客添加站内搜索功能</title>
      <link href="/2019/01/26/%E8%BF%9B%E9%98%B6-%E5%9B%9B-%EF%BC%9A%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/01/26/%E8%BF%9B%E9%98%B6-%E5%9B%9B-%EF%BC%9A%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不知不觉坚持写博客已经快一年了，博客文章破50，虽然平均每个月4到5篇不算什么，但是对于平时一心扑到工作简直没有时间生活的我来说，已经很不容易了。虽然文章可能没有高大上的标题，也没有涉及太多前沿的技术，但是起码我记录下了我的一些小经验，累积了自己的一个小知识库。其实我还有很多内容没来及的记录，希望以后能通过博客沉淀更多的知识，同时帮助到更多的人。</p><p>言归正传，文章一多，有时自己想翻查一个内容，要找好久，要是有站内查找功能就好了。于是仔细查阅了工程yml配置，果然发现在theme下的<code>_config.yml</code>有个<code>local_search</code>配置项，满心欢心把它设为<code>true</code>。结果搜索图标是出来了，但是点击后除了在页面加了一个全局loading就什么都没有了。看来还需要额外的操作。百度了一番，原来hexo提供了的search插件，需要手动安装才可以使用站内搜索。</p></blockquote><a id="more"></a><p>3步搞定：</p><h2 id="1-安装两个插件"><a href="#1-安装两个插件" class="headerlink" title="1.安装两个插件"></a>1.安装两个插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-generator-search hexo-generator-searchdb</span><br></pre></td></tr></table></figure><h2 id="2-配置hexo主配置文件（位于工程根目录下）-config-yml"><a href="#2-配置hexo主配置文件（位于工程根目录下）-config-yml" class="headerlink" title="2.配置hexo主配置文件（位于工程根目录下）_config.yml"></a>2.配置hexo主配置文件（位于工程根目录下）<code>_config.yml</code></h2><p>在最后面追加这段，注意2个空格的缩进，这个是yml缩进语法，不能随意。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># local_search</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p><h2 id="3-配置hexo主题下的配置文件（位于theme-gt-next下）-config-yml"><a href="#3-配置hexo主题下的配置文件（位于theme-gt-next下）-config-yml" class="headerlink" title="3.配置hexo主题下的配置文件（位于theme-&gt;next下）_config.yml"></a>3.配置hexo主题下的配置文件（位于theme-&gt;next下）<code>_config.yml</code></h2><blockquote><p>将<code>enable</code>设为<code>true</code>。这一步我在一开始就已经做过了～</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure><p>重新<code>hexo g</code>, <code>hexo s</code>，刷新页面，点击搜索图标，就可以看到搜索弹出框了，输入关键字，可以看到匹配到文章。<br><img src="/images/hexo-local-search.jpg" alt=""></p><p>GOOD LUCK!</p><hr><p>参考资料：<br><a href="https://www.jianshu.com/p/519b45730824" target="_blank" rel="noopener">https://www.jianshu.com/p/519b45730824</a><br><a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">https://github.com/wzpan/hexo-generator-search</a><br><a href="https://www.npmjs.com/package/hexo-generator-searchdb" target="_blank" rel="noopener">https://www.npmjs.com/package/hexo-generator-searchdb</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm install 高级</title>
      <link href="/2019/01/09/npm-install-%E9%AB%98%E7%BA%A7/"/>
      <url>/2019/01/09/npm-install-%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>npm install</p><p>npm install –production</p><p>npm install –only=prod</p><p>npm install –only=dev</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git clone 高级</title>
      <link href="/2019/01/09/git-clone-%E9%AB%98%E7%BA%A7/"/>
      <url>/2019/01/09/git-clone-%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义克隆下来的目录名"><a href="#自定义克隆下来的目录名" class="headerlink" title="自定义克隆下来的目录名"></a>自定义克隆下来的目录名</h2><p>克隆仓库的命令格式是 <code>git clone [url]</code><br>这个命令会将远程仓库的名字作为你的本地仓库（即项目根目录）的名字。<br>如果你想自己命名本地仓库的名字可以使用这个命令：<code>git clone [url] yourprojectname</code></p><h2 id="克隆指定分支"><a href="#克隆指定分支" class="headerlink" title="克隆指定分支"></a>克隆指定分支</h2><p>如果远程仓库不做设置，默认 <code>git clone</code> 克隆下来的是项目的 <code>master</code> 分支。<br>如果想要获取非 <code>master</code> 分支，可以使用命令指定分支： <code>git clone -b branchname [url]</code><br>比如我要克隆 <code>zrender</code> 项目的 <code>dev</code> 分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b dev https://github.com/ecomfe/zrender</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github和gitlab上的md文档支持相对路径的链接了</title>
      <link href="/2019/01/09/github%E5%92%8Cgitlab%E4%B8%8A%E7%9A%84md%E6%96%87%E6%A1%A3%E6%94%AF%E6%8C%81%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E9%93%BE%E6%8E%A5%E4%BA%86/"/>
      <url>/2019/01/09/github%E5%92%8Cgitlab%E4%B8%8A%E7%9A%84md%E6%96%87%E6%A1%A3%E6%94%AF%E6%8C%81%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E9%93%BE%E6%8E%A5%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>markdown 格式语法中，链接的格式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[链接文字](链接地址)</span><br></pre></td></tr></table></figure></p><p>之前写链接，用 http 协议 url 居多，最近遇到在项目的 README 中要添加另一个文档的链接，由于当前在 dev 分支，如果写分支的仓库 url 路径，那到时候 dev 分支合并到其他分支后，dev 分支被删除后，这个地址岂不是有问题了。如果能用相对路径就好了。</p><p>查了下，居然在 gitlab 上是支持的，在 github 上最近也支持了，真是喜讯。说到喜讯，昨天 github 官网宣布开放免费的 private repository ，也是2019喜讯一桩。</p><h3 id="相对路径使用举例"><a href="#相对路径使用举例" class="headerlink" title="相对路径使用举例"></a>相对路径使用举例</h3><p>如果你的项目结构如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">    text.md</span><br><span class="line">    subpro/</span><br><span class="line">        subtext.md</span><br><span class="line">        subsubpro/</span><br><span class="line">            subsubtext.md</span><br><span class="line">        subsubpro2/</span><br><span class="line">            subsubtext2.md</span><br></pre></td></tr></table></figure><p>那么在 text.md 中链接到 subtext.md 的相对链接这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[this subtext](subpro/subtext.md)</span><br></pre></td></tr></table></figure></p><p>在 text.md 中链接到 subsubtext.me 的相对链接这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[this subsubtext](subpro/subsubpro/subsubprotext.md)</span><br></pre></td></tr></table></figure></p><p>在 subsubtext.md 中链接到 text.md 的相对链接这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[this text](../../text.md)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows批处理常用命令</title>
      <link href="/2018/12/20/windows%E6%89%B9%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/12/20/windows%E6%89%B9%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前阵子在倒腾服务器的时候，需要些一些 windows 批处理来执行任务。就稍微研究了一下。</p></blockquote><h3 id="一、-基本信息"><a href="#一、-基本信息" class="headerlink" title="一、 基本信息"></a>一、 基本信息</h3><ol><li>批处理文件扩展名为 <code>.bat</code> 或者 <code>.cmd</code>。区别：cmd 文件只能在 windows2000 以上的系统才能运行，bat 文件则没有这个限制。</li><li>这个文件的每一行都是一条 DOS 命令。</li><li>可以使用任何文本编辑器创建和修改。</li><li>批处理是一种简单的程序，可以用 <code>if</code> 和 <code>go</code> 来控制流程，也可以使用 <code>for</code> 循环。</li><li>批处理的编程能力远不如 C语言等编程语言，也十分不规范。</li><li>每个编写好的批处理文件都相当于一个 DOS 的外部命令，把它锁在的目录放到 DOS 搜索路径（path）中，即可在任意位置运行。</li><li><code>C:\AUTOEXEC.BAT</code>  是每次系统启动时都会自动运行的，可以将每次启动时都要运行的命令放入该文件中。</li><li>大小写不敏感</li><li>在命令提示下键入批处理文件的名称，或者双击该批处理文件，系统会调用cmd.exe来运行该文件。</li></ol><h3 id="二、-参数"><a href="#二、-参数" class="headerlink" title="二、 参数"></a>二、 参数</h3><a id="more"></a><ol><li><p>系统参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%SystemRoot% === C:\WINDOWS (%windir% 同样)</span><br><span class="line">%ProgramFiles% === C:\Program Files</span><br><span class="line">%USERPROFILE% === C:\Documents and Settings\Administrator (子目录有“桌面”,“开始菜单”,“收藏夹”等)</span><br><span class="line">%APPDATA% === C:\Documents and Settings\Administrator\Application Data</span><br><span class="line">%TEMP% === C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp (%TEM% 同样)</span><br><span class="line">%APPDATA% === C:\Documents and Settings\Administrator\Application Data</span><br><span class="line">%OS% === Windows_NT (系统)</span><br><span class="line">%Path% === %SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem (原本的设置)</span><br><span class="line">%HOMEDRIVE% === C: (系统盘)</span><br><span class="line">%HOMEPATH% === \Documents and Settings\Administrator</span><br><span class="line"></span><br><span class="line">:: 枚举当前的环境变量</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">FOR /F &quot;usebackq delims==&quot; %%i IN (`set`) DO @echo %%i !%%i!</span><br></pre></td></tr></table></figure></li><li><p>给批处理文件传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%[1-9]表示参数，参数是指在运行批处理文件时在文件名后加的以空格(或者Tab)分隔的字符串。</span><br><span class="line">变量可以从%0到%9，%0表示批处理命令本身，其它参数字符串用 %1 到 %9 顺序表示。</span><br><span class="line"></span><br><span class="line">Sample：</span><br><span class="line">call test2.bat &quot;hello&quot; &quot;haha&quot; (执行同目录下的“test2.bat”文件，并输入两个参数)</span><br><span class="line">在“test2.bat”文件里写:</span><br><span class="line">echo %1 (打印: &quot;hello&quot;)</span><br><span class="line">echo %2 (打印: &quot;haha&quot;)</span><br><span class="line">echo %0 (打印: test2.bat)</span><br><span class="line">echo %19 (打印: &quot;hello&quot;9)</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、-基本命令"><a href="#三、-基本命令" class="headerlink" title="三、 基本命令"></a>三、 基本命令</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><h4 id="md"><a href="#md" class="headerlink" title="md"></a>md</h4><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><h4 id="shutdowm"><a href="#shutdowm" class="headerlink" title="shutdowm"></a>shutdowm</h4><h4 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h4><h4 id="符号："><a href="#符号：" class="headerlink" title="符号："></a>符号：</h4><p><code>&gt;</code>        传递并覆盖<br><code>&gt;&gt;</code>       传递并追加<br><code>::</code>       注释</p><p>找到一个比较清晰比较全的一个文档，在<a href="https://segmentfault.com/a/1190000009873409" target="_blank" rel="noopener">这里</a></p><h3 id="四、-例子"><a href="#四、-例子" class="headerlink" title="四、 例子"></a>四、 例子</h3><p>重启的批处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r -f -t 0</span><br></pre></td></tr></table></figure></p><blockquote><p>r: 关闭并重启计算机。<br>f: 强制关闭正在运行的应用程序，不在前台警告用户。<br>t xxx: 设置关闭的超时事件为 xxx 秒。有效范围时0-315360000（10年），默认值为30.</p></blockquote><p>在重启前，将重启时间写入日志(以下已在英文版windows操作系统上检测过)<br>restart.bat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set nowdate=%date:~4, 10%</span><br><span class="line">set nowtime=%time:~0,8%</span><br><span class="line">set content=%nowdate:/=-% %nowtime%</span><br><span class="line">set distpath=&quot;c:\restartlog&quot;</span><br><span class="line">::write log</span><br><span class="line">echo restart time: %content% &gt;&gt; %distpath%\log.txt</span><br><span class="line">shutdown -r -f -t 0</span><br></pre></td></tr></table></figure></p><p>再在windows的计划任务中，将这个脚本配置进去。则当脚本执行，将会在系统的c盘下新建一个目录restartlog，然后在这个目录中创建一个文件log.txt，并在文件中追加写入： “restart time： 当时的时间”，最后重启系统。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows， bat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git如何撤销commit并保留修改</title>
      <link href="/2018/11/27/git%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80commit%E5%B9%B6%E4%BF%9D%E7%95%99%E4%BF%AE%E6%94%B9/"/>
      <url>/2018/11/27/git%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80commit%E5%B9%B6%E4%BF%9D%E7%95%99%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有时 commit 代码的时候，手误或者眼花误将不应该这次提交的文件 commit 了，此时还没有 push 到远程仓库，这个时候可以通过 git 命令，撤销该次 commit，并且本地修改还在，即回到 commit 之前的状态，可以重新选择文件进行提交。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft [commit_id]</span><br></pre></td></tr></table></figure><p>这个 commit_id 可以是历史记录中任一一个，这个命令会让你的代码回到该条 commit 之后的状态，所有的修改都会在，log 中的该条之后的 commit 记录就都删除了。所以也要谨慎使用，一般用于撤销上一次的 commit。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何更改git clone默认检出的分支</title>
      <link href="/2018/11/26/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9git-clone%E9%BB%98%E8%AE%A4%E6%A3%80%E5%87%BA%E7%9A%84%E5%88%86%E6%94%AF/"/>
      <url>/2018/11/26/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9git-clone%E9%BB%98%E8%AE%A4%E6%A3%80%E5%87%BA%E7%9A%84%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<p>一般我们 clone 一个项目都是检出默认的 master 分支。这个其实是可以修改的。</p><p>修改办法：<br>在 git 服务器上，进入该项目的 .git （仓库）文件夹，编辑 HEAD 文件。</p><p>例如想默认为 dev 分支：<br>将 refs/heads/master 改成 refs／heads/dev</p><blockquote><p>该操作需要 git 管理员来完成，修改本地仓库没有用。</p></blockquote><p>在 gitlab 或者 github 的仓库配置中，可以找到，有个默认分支下拉选项，就是做这个设置的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js如何识别图片加载失败</title>
      <link href="/2018/11/26/js%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/"/>
      <url>/2018/11/26/js%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在做项目过程中遇到图片请求失败的时候，图片区域会出现一个原生的碎片图标，非常影响用户体验。这时需要用一个 broken 的图片去代替它，来提升户体验。要做到这一点，首先要在代码中识别图片加载失败这个事情。那么怎么判断一个图片加载失败了呢？</p></blockquote><h1 id="在-js-中使用-onerror-事件"><a href="#在-js-中使用-onerror-事件" class="headerlink" title="在 js 中使用 onerror 事件"></a>在 js 中使用 onerror 事件</h1><p>javascript 给我们提供了一个 <code>onerror</code> 事件，img 标签支持该事件，当装载文档或者图像的过程中发生了错误，就会触发 onerror 事件。<br>我们可以在这个事件中，定义要替换加载不出来的原图的 broken 图片。</p><p>核心代码：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;img src=&quot;img.png&quot; onerror=&quot;myfunction()&quot;&gt;</span><br><span class="line"></span><br><span class="line">// javascript</span><br><span class="line">myfunction() &#123;</span><br><span class="line">this.src=&quot;default.png&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>如果 onerror 指定的图片也不存在的话，会出现无限死循环 404. 解决办法是在 js 中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// javascript</span><br><span class="line">myfunction() &#123;</span><br><span class="line">this.src=&quot;./default.png&quot;;</span><br><span class="line">this.onerror = null; // 添加这个防止默认图片也不存在而陷入死循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="在-Vue-中怎么使用-onerror"><a href="#在-Vue-中怎么使用-onerror" class="headerlink" title="在 Vue 中怎么使用 onerror"></a>在 Vue 中怎么使用 onerror</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;img :src=&quot;item.imgUrl&quot; :onerror=&quot;defaultImg&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line"> data () &#123;</span><br><span class="line"> return &#123;</span><br><span class="line"> defaultImg: &apos;this.src=&quot;./static/images/default.png&quot;&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>有时因为网络比较卡的原因需要多加载几次再判定为是否加载失败。<br>但是有时是因为网络连接断开而加载失败，需要在网络恢复连接时自动加载图片。<br>这是就需要知道，js中怎么识别网络断开和连接的，有两个事件：<code>online</code> 和 <code>offline</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">var isOnLine = true;</span><br><span class="line">var eventList = &#123;&#125;;</span><br><span class="line">window.addEventListener(&apos;offline&apos;, function() &#123;</span><br><span class="line">isOnLine = false;</span><br><span class="line">&#125;)</span><br><span class="line">window.addEventListener(&apos;online&apos;, function() &#123;</span><br><span class="line">if(!isOnline) &#123;</span><br><span class="line">isOnLine = true;</span><br><span class="line">reLine(); // 执行重连后要做的事情 </span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">function reLine() &#123;</span><br><span class="line">for(var key in eventList) &#123;</span><br><span class="line">if(!eventList[key]) continue;</span><br><span class="line">var arg = eventList[key].arg;</span><br><span class="line">var thisOnFn = eventList[key].that;</span><br><span class="line">eventList[key].fun.apply(thisOnFn, arg);</span><br><span class="line">eventList[key] = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">function offLined(fun, arg, that) &#123;</span><br><span class="line">if(!isOnLine) &#123;</span><br><span class="line">var name = fun.name || &apos;__new&apos;;</span><br><span class="line">eventList[name] = &#123;&#125;;</span><br><span class="line">eventList[name].fun = fun;</span><br><span class="line">eventList[name].arg = [].slice.call(arg);</span><br><span class="line">eventList[name].that = that;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">// 重新定义myfunction</span><br><span class="line">myfunction(imgObj, imgSrc, maxErrorNum) &#123;</span><br><span class="line">if(offLined(restImgUrl, arguments, this)) return;</span><br><span class="line">if(maxErrorNum &gt; 0) &#123;</span><br><span class="line">imgObj.onerror = function () &#123;</span><br><span class="line">myFunction(imgObj, imgSrc, maxErrorNum - 1)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">imgObj.src = imgSrc;</span><br><span class="line">&#125;, 500)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">imgObj.src = &apos;./default.png&apos;;</span><br><span class="line">this.onerror = null;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">&lt;img src=&quot;img.png&quot; onerror=&quot;myfunction(this, this.src, 3)&quot;&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js如何获取网页元素的绝对位置</title>
      <link href="/2018/11/25/js%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE/"/>
      <url>/2018/11/25/js%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是网页元素的绝对位置和相对位置"><a href="#什么是网页元素的绝对位置和相对位置" class="headerlink" title="什么是网页元素的绝对位置和相对位置"></a>什么是网页元素的绝对位置和相对位置</h1><p>网页元素的绝对位置，是指该元素的左上角相对于整张网页的左上角的坐标。<br>网页元素的相对位置，是指该元素的左上角相对于视口的左上角的坐标。</p><h1 id="如何获取绝对位置"><a href="#如何获取绝对位置" class="headerlink" title="如何获取绝对位置"></a>如何获取绝对位置</h1><a id="more"></a><p>由于每个元素都有 offsetTop 和 offsetLeft 属性， 表示该元素左上角与父容器（offsetParent对象）左上角的距离。<br>所以可以遍历一下元素的祖先容器，把所有的 offsetTop 加起来得到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&apos;article_container&apos;)</span><br><span class="line">var actualTop = element.offsetTop; // 绝对位置</span><br><span class="line">var current = element.offsetParent;</span><br><span class="line">while (current !== null)&#123;</span><br><span class="line">　　actualTop += current.offsetTop;</span><br><span class="line">　　current = current.offsetParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="如何获取相对位置"><a href="#如何获取相对位置" class="headerlink" title="如何获取相对位置"></a>如何获取相对位置</h1><p>有了绝对位置，获得相对位置就容易了，可以通过绝对坐标减去页面滚动条滚动的距离来得到。<br>滚动条滚动的垂直距离，是 document 对象的 scrollTop 属性，滚动的水平距离，是 document 对象的 scrollLeft 属性。scrollTop 和 scrollLeft 是可以赋值的，并且会立即自动滚动网页到相应位置。可以利用它们改变元素的相对位置。另外，elment.scrollIntoView() 方法也有类似作用，可以使网页元素出现在浏览器窗口的左上角（不过需要在支持 html5 的浏览器才能生效）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var elementScrollTop = document.documentElement.scrollTop; </span><br><span class="line">var relativeTop = actualTop-elementScrollTop; // 相对位置</span><br></pre></td></tr></table></figure></p><h1 id="快速获取元素的绝对位置和相对位置"><a href="#快速获取元素的绝对位置和相对位置" class="headerlink" title="快速获取元素的绝对位置和相对位置"></a>快速获取元素的绝对位置和相对位置</h1><p>使用 js 的 getBoundingClientRect() 方法。她会返回一个对象，包含 left， right， top， bottom 四个属性，分别对应该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var dom = document.getElementById(&apos;article_container&apos;);</span><br><span class="line">// 相对位置</span><br><span class="line">var rLeft = dom.getBoundingClientRect().left;</span><br><span class="line">var rTop = dom.getBoundingClientRect().top;</span><br><span class="line"></span><br><span class="line">// 绝对位置（相对位置+滚动距离）</span><br><span class="line">var aLeft = rLeft + document.documentElement.scrollLeft;</span><br><span class="line">var aTop = rTop + document.documentElement.scrollTop;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jacascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacBook 常用快捷键</title>
      <link href="/2018/11/25/MacBook-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/11/25/MacBook-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="1-新建一个-Tab-样式的终端窗口"><a href="#1-新建一个-Tab-样式的终端窗口" class="headerlink" title="1. 新建一个 Tab 样式的终端窗口"></a>1. 新建一个 Tab 样式的终端窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + T</span><br></pre></td></tr></table></figure><h3 id="2-自带的截图快捷键"><a href="#2-自带的截图快捷键" class="headerlink" title="2. 自带的截图快捷键"></a>2. 自带的截图快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command + Shift + 3 截取整个屏幕，保存图片在桌面</span><br><span class="line">Command + Shift + 4 选取部分屏幕区域，保存图片在桌面</span><br><span class="line">先Command + Shift + 4 再空格， 可以对指定的窗口或者菜单截屏</span><br><span class="line">以上快捷键，加上 Ctrl， 可以把截图保存在剪切板</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> MacBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git log高级使用</title>
      <link href="/2018/11/24/git-log%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/11/24/git-log%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="n-查看最近那次的提交信息"><a href="#n-查看最近那次的提交信息" class="headerlink" title="-n 查看最近那次的提交信息"></a>-n 查看最近那次的提交信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -2 //查看最近2次提交记录</span><br></pre></td></tr></table></figure><h3 id="–-fileName-查看指定文件的提交信息"><a href="#–-fileName-查看指定文件的提交信息" class="headerlink" title="– fileName 查看指定文件的提交信息"></a>– fileName 查看指定文件的提交信息</h3><p>文件名要放到参数的最后位置，通常在前面加上 <code>--</code> 并用空格隔开表示是文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -- file1 file2</span><br></pre></td></tr></table></figure></p><h3 id="branchName-查看某个分支上的提交记录"><a href="#branchName-查看某个分支上的提交记录" class="headerlink" title="branchName 查看某个分支上的提交记录"></a>branchName 查看某个分支上的提交记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log dev</span><br></pre></td></tr></table></figure><h3 id="tagName-查询指定标签的提交记录"><a href="#tagName-查询指定标签的提交记录" class="headerlink" title="tagName 查询指定标签的提交记录"></a>tagName 查询指定标签的提交记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log v1.0.. 查询从v1.0以后的提交历史记录(不包含v1.0) </span><br><span class="line">git log test..master 查询master分支中的提交记录但不包含test分支记录 </span><br><span class="line">git log master..test 查询test分支中的提交记录但不办含master分支记录 </span><br><span class="line">git log master…test 查询master或test分支中的提交记录。 </span><br><span class="line">git log test –not master　　屏蔽master分支</span><br></pre></td></tr></table></figure><h3 id="根据-commit-id-或者-HEAD-查询日志"><a href="#根据-commit-id-或者-HEAD-查询日志" class="headerlink" title="根据 commit id 或者 HEAD 查询日志"></a>根据 commit id 或者 HEAD 查询日志</h3><p>commit id 可以是提交哈希的简写模式，也可以使用HEAD替代。HEAD指向当前分支，HEAD^为最后一个提交，等同于HEAD~1,HEAD~2代表倒数第二次提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log f52c471</span><br></pre></td></tr></table></figure></p><h3 id="–pretty-按指定格式显示日志信息"><a href="#–pretty-按指定格式显示日志信息" class="headerlink" title="–pretty 按指定格式显示日志信息"></a>–pretty 按指定格式显示日志信息</h3><p>可选项有：</p><a id="more"></a><p><code>oneline</code>, <code>short</code>, <code>medium</code>, <code>full</code>, <code>fuller</code>, <code>email</code>, <code>raw</code>, <code>format</code><br>默认为medium，可以通过修改配置文件来指定默认的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log (--pretty=)oneline</span><br></pre></td></tr></table></figure></p><p>常见的 format 选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">选项  说明</span><br><span class="line">%H  提交对象（commit）的完整哈希字串 </span><br><span class="line">%h  提交对象的简短哈希字串 </span><br><span class="line">%T  树对象（tree）的完整哈希字串 </span><br><span class="line">%t  树对象的简短哈希字串 </span><br><span class="line">%P  父对象（parent）的完整哈希字串 </span><br><span class="line">%p  父对象的简短哈希字串 </span><br><span class="line">%an 作者（author）的名字 </span><br><span class="line">%ae 作者的电子邮件地址 </span><br><span class="line">%ad 作者修订日期（可以用 -date= 选项定制格式） </span><br><span class="line">%ar 作者修订日期，按多久以前的方式显示 </span><br><span class="line">%cn 提交者(committer)的名字 </span><br><span class="line">%ce 提交者的电子邮件地址 </span><br><span class="line">%cd 提交日期 </span><br><span class="line">%cr 提交日期，按多久以前的方式显示 </span><br><span class="line">%s  subject 提交说明</span><br><span class="line">%d  body</span><br></pre></td></tr></table></figure></p><p>事例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format:&quot;$h %cn %cr %s&quot;</span><br><span class="line">// 或者</span><br><span class="line">git log --format=&quot;$h %cn %cr %s&quot;</span><br></pre></td></tr></table></figure></p><h2 id="自定义-git-log-–format-后输出内容的颜色"><a href="#自定义-git-log-–format-后输出内容的颜色" class="headerlink" title="自定义 git log –format 后输出内容的颜色"></a>自定义 git log –format 后输出内容的颜色</h2><p><code>git log --format</code> 后，输出的内容是没有颜色区分的，我们其实是可以给输出的内容自定义颜色，便于让内容更有辨识度。<br>方法为在 format 的内容选项前，加上 %C() 选项。其中:</p><ol><li>括号内放代表颜色的字符串，颜色字符串支持24位的RGB值（要带#号）</li><li>也可以是以下的颜色名称：<ul><li>normal</li><li>black</li><li>red</li><li>green</li><li>yellow</li><li>blue</li><li>magenta</li><li>cyan</li><li>white</li></ul></li><li>这些颜色名称还可以跟这些修饰属性绑定使用，可叠加多个使用。注意，这些修饰只能修饰前景色：<ul><li>bold    // 加粗</li><li>dim     // 颜色减淡</li><li>ul      // 下划线</li><li>blink   // 闪烁效果</li><li>reverse // 前景色背景色交换</li></ul></li><li>也可以放两个颜色字符串，第一个将被识别为前景色，第二个将被识别为背景色</li><li>在 git v1.7 版本后，对于 red、green、blue 三个颜色来说，括号是可选的。（但是这样就只能使用一个颜色，即前景色）</li><li>颜色和颜色修饰，是会传播到之后的输出内容样式，除非在内容前或者该内容后，重置颜色和修饰：%Creset。或则剔除修饰：noxxx（xxx 代表修饰名，例如nodim）。<strong>所以每设置完一个内容的颜色，最好是在该内容后紧跟一个%Creset，以防影响后面内容的样式。</strong></li><li>重置颜色和剔除修饰也是会传播的。</li></ol><h3 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h3><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --format=&quot;%C(magenta)%h %C(red)%d %C(yellow)(%cr) %C(green)%s&quot;</span><br></pre></td></tr></table></figure></p><p>效果：<br><img src="/images/git-log--format-with-color1.jpg" alt="git-log--format-with-color1"><br>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --format=&quot;%C(white ul bold magenta)%h%Creset %C(yellow)(%cr)%Creset %C(green)%s%Creset %C(dim)%cd&quot;</span><br></pre></td></tr></table></figure></p><p>效果：<br><img src="/images/git-log--format-with-color2.jpg" alt="git-log--format-with-color2"><br>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --format=&quot;%C(reverse ul black)%h%Creset %C(yellow)(%cr)%Creset %C(green)%s%Creset %C(dim)%cd&quot;</span><br></pre></td></tr></table></figure></p><p>效果：<br><img src="/images/git-log--format-with-color3.jpg" alt="git-log--format-with-color3"></p><h3 id="自定义规则快捷键——别名"><a href="#自定义规则快捷键——别名" class="headerlink" title="自定义规则快捷键——别名"></a>自定义规则快捷键——别名</h3><p>每次都要输入这一长串的命令非常繁琐且容易出错，我们可以将调整好的这一串命令保存在git配置文件里，并给它起一个别名，下次只需要输入这个别名，就可以看到符合自己习惯的日志格式和样式了。</p><ol><li>进入～／.gitconfig</li><li><p>添加：（注意，format后的值必须要用单引号，双引号会报错。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">   logs = log --format=&apos;%C(reverse ul red)%h%Creset %cn  %C(yellow)(%cr)%Creset %C(green)%s%Creset&apos;</span><br></pre></td></tr></table></figure></li><li><p>然后在命令行只需要输入 <code>git logs</code> 就可以得到你要的效果了。</p></li></ol><blockquote><p>更多详细可查看 <a href="https://git-scm.com/docs/pretty-formats" target="_blank" rel="noopener">git documentation Pretty Formats</a></p></blockquote><h3 id="–author-someone-查询指定作者的提交记录"><a href="#–author-someone-查询指定作者的提交记录" class="headerlink" title="–author=someone 查询指定作者的提交记录"></a>–author=someone 查询指定作者的提交记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=sam</span><br></pre></td></tr></table></figure><h3 id="–grep-通过关键字过滤提交日志"><a href="#–grep-通过关键字过滤提交日志" class="headerlink" title="–grep 通过关键字过滤提交日志"></a>–grep 通过关键字过滤提交日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --grep=mod  列出所有包含 mod 字样提交信息的记录</span><br></pre></td></tr></table></figure><h3 id="–graph-以简单的图形方式列出提交记录"><a href="#–graph-以简单的图形方式列出提交记录" class="headerlink" title="–graph 以简单的图形方式列出提交记录"></a>–graph 以简单的图形方式列出提交记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure><h3 id="–name-status-显示新增、修改、删除的文件清单"><a href="#–name-status-显示新增、修改、删除的文件清单" class="headerlink" title="–name-status 显示新增、修改、删除的文件清单"></a>–name-status 显示新增、修改、删除的文件清单</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --name-only</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用nvm+nrm+cmder打造灵活的前端开发环境</title>
      <link href="/2018/11/24/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8nvm-nrm-cmder%E6%89%93%E9%80%A0%E7%81%B5%E6%B4%BB%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/11/24/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8nvm-nrm-cmder%E6%89%93%E9%80%A0%E7%81%B5%E6%B4%BB%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在前端工程开发过程中，不同项目可能会使用不同的 node 环境和 npm 环境，在不同项目中切换时，要不停的卸载安装前端开发环境，非常麻烦。于是有了 nvm 和 nrm，可以通过切换的方式快速设置开发环境版本，再也不要繁琐地卸载安装了，有效的解放了劳动力。</p></blockquote><h3 id="1-nvm"><a href="#1-nvm" class="headerlink" title="1. nvm"></a>1. nvm</h3><p>nvm: node version manager<br>node 版本管理器</p><h3 id="2-nrm"><a href="#2-nrm" class="headerlink" title="2. nrm"></a>2. nrm</h3><p>nrm: npm registry manager<br>npm 版本管理器</p><p>安装 nrm：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nrm -g</span><br></pre></td></tr></table></figure></p><p>添加 registry：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm add npm http://registry.npmjs.org</span><br><span class="line">nrm add taobao https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>查看已添加的 registry：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure></p><p>切换 registry：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm use taobao</span><br><span class="line">nrm use npm</span><br></pre></td></tr></table></figure></p><h3 id="3-cmder"><a href="#3-cmder" class="headerlink" title="3. cmder"></a>3. cmder</h3><p>一款酷炫的命令行终端软件</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nvm </tag>
            
            <tag> nrm </tag>
            
            <tag> cmder </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何查看和设置npm镜像地址</title>
      <link href="/2018/11/24/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%AE%BE%E7%BD%AEnpm%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80/"/>
      <url>/2018/11/24/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%AE%BE%E7%BD%AEnpm%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure><p>在输出信息中可以看到我的 npm 镜像如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">metrics-registry = &quot;https://registry.npmjs.org/&quot;</span><br><span class="line">scope = &quot;&quot;</span><br><span class="line">user-agent = &quot;npm/5.5.1 node/v8.9.3 darwin x64&quot;</span><br></pre></td></tr></table></figure></p><h3 id="设置镜像"><a href="#设置镜像" class="headerlink" title="设置镜像"></a>设置镜像</h3><p>常用的 npm 镜像地址有：<br>npm —- <a href="http://registry.npmjs.org" target="_blank" rel="noopener">http://registry.npmjs.org</a> (默认)<br>cnpm — <a href="http://r.cnpmjs.org" target="_blank" rel="noopener">http://r.cnpmjs.org</a><br>taobao - <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>nj —– <a href="https://registry.nodejitsu.com" target="_blank" rel="noopener">https://registry.nodejitsu.com</a><br>rednpm - <a href="http://registry.mirror.cqupt.edu.cn" target="_blank" rel="noopener">http://registry.mirror.cqupt.edu.cn</a><br>npmMirror <a href="https://skimdb.npmjs.com/registry" target="_blank" rel="noopener">https://skimdb.npmjs.com/registry</a><br>edunpm - <a href="http://registry.enpmjs.org" target="_blank" rel="noopener">http://registry.enpmjs.org</a></p><h4 id="1-临时使用"><a href="#1-临时使用" class="headerlink" title="1. 临时使用"></a>1. 临时使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org install xxx</span><br></pre></td></tr></table></figure><h4 id="2-持久使用"><a href="#2-持久使用" class="headerlink" title="2. 持久使用"></a>2. 持久使用</h4><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure><p>或者直接编辑 <code>~/.npmrc</code> 文件，加入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry = https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><h4 id="3-随时切换"><a href="#3-随时切换" class="headerlink" title="3. 随时切换"></a>3. 随时切换</h4><p>使用 <code>nrm</code> 管理 npm 镜像地址</p><h3 id="检测镜像是否配置成功"><a href="#检测镜像是否配置成功" class="headerlink" title="检测镜像是否配置成功"></a>检测镜像是否配置成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">npm config get disturl</span><br></pre></td></tr></table></figure><blockquote><p><code>npm info underscore</code> 或者 <code>npm info express</code> 也可以用来查看配置是否成功</p></blockquote><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config delete registry</span><br><span class="line">npm config delete disturl</span><br></pre></td></tr></table></figure><p>其他</p><h3 id="查看-npm-安装目录"><a href="#查看-npm-安装目录" class="headerlink" title="查看 npm 安装目录"></a>查看 npm 安装目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm root -g</span><br></pre></td></tr></table></figure><h3 id="查看-npm-的-prefix-和-cache-路径配置信息"><a href="#查看-npm-的-prefix-和-cache-路径配置信息" class="headerlink" title="查看 npm 的 prefix 和 cache 路径配置信息"></a>查看 npm 的 prefix 和 cache 路径配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get prefix</span><br><span class="line">npm config get cache</span><br></pre></td></tr></table></figure><p>安装 node.js 时会自动安装 npm， 默认的缓存路径是 %appdata%\Roaming\npm-cache</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git如何去掉对文件的追踪</title>
      <link href="/2018/11/24/git%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%BD%E8%B8%AA/"/>
      <url>/2018/11/24/git%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%89%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<p>去掉对某些文件的 track：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;file path&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让commit信息带图标</title>
      <link href="/2018/11/24/%E5%A6%82%E4%BD%95%E8%AE%A9commit%E4%BF%A1%E6%81%AF%E5%B8%A6%E5%9B%BE%E6%A0%87/"/>
      <url>/2018/11/24/%E5%A6%82%E4%BD%95%E8%AE%A9commit%E4%BF%A1%E6%81%AF%E5%B8%A6%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git commit 的提交日志上，除了文字，还可以有图标。叫做 git commit emoji。</p></blockquote><p>提交事例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;:tada: Made some changes&quot;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="/images/git-commit-emoji.jpg" alt="git-commit-emoji"></p><h3 id="commit-格式规范："><a href="#commit-格式规范：" class="headerlink" title="commit 格式规范："></a>commit 格式规范：</h3><ol><li>message 摘要不超过50个字，首字母大写，使用祈使语气，句末不要加句号</li><li>引用相关 <code>issue</code> 或 <code>PR</code> 编号 <code>&lt;#110&gt;</code></li></ol><h3 id="emoji-代码列表"><a href="#emoji-代码列表" class="headerlink" title="emoji 代码列表"></a>emoji 代码列表</h3><a id="more"></a> <table><thead><tr><th>emoji</th><th>emoji代码</th><th>语义</th></tr></thead><tbody><tr><td>:tada:(庆祝)</td><td><code>:tada:</code></td><td>初次提交</td></tr><tr><td>:sparkles: (火花)</td><td><code>:sparkles:</code></td><td>引入新功能</td></tr><tr><td>:bookmark: (书签)</td><td><code>:bookmark:</code></td><td>发行/版本标签</td></tr><tr><td>:bug: (bug)</td><td><code>:bug:</code></td><td>修复 bug</td></tr><tr><td>:ambulance: (急救车)</td><td><code>:ambulance:</code></td><td>重要补丁</td></tr><tr><td>:globe_with_meridians: (地球)</td><td><code>:globe_with_meridians:</code></td><td>国际化与本地化</td></tr><tr><td>:lipstick: (口红)</td><td><code>:lipstick:</code></td><td>更新 UI 和样式文件</td></tr><tr><td>:rotating_light: (警车灯)</td><td><code>:rotating_light:</code></td><td>移除 linter 警告</td></tr><tr><td>:wrench: (扳手)</td><td><code>:wrench:</code></td><td>修改配置文件</td></tr><tr><td>:heavy_plus_sign: (加号)</td><td><code>:heavy_plus_sign:</code></td><td>增加一个依赖</td></tr><tr><td>:heavy_minus_sign: (减号)</td><td><code>:heavy_minus_sign:</code></td><td>减少一个依赖</td></tr><tr><td>:arrow_up: (上升箭头)</td><td><code>:arrow_up:</code></td><td>升级依赖</td></tr><tr><td>:arrow_down: (下降箭头)</td><td><code>:arrow_down:</code></td><td>降级依赖</td></tr><tr><td>:zap: (闪电)<br>:racehorse: (赛马)</td><td><code>:zap:</code><br><code>:racehorse:</code></td><td>提升性能</td></tr><tr><td>:chart_with_upwards_trend: (上升趋势图)</td><td><code>:chart_with_upwards_trend:</code></td><td>添加分析或跟踪代码</td></tr><tr><td>:rocket: (火箭)</td><td><code>:rocket:</code></td><td>部署功能</td></tr><tr><td>:white_check_mark: (白色复选框)</td><td><code>:white_check_mark:</code></td><td>增加测试</td></tr><tr><td>:memo: (备忘录)</td><td><code>:memo:</code></td><td>撰写文档</td></tr><tr><td>:hammer: (锤子)</td><td><code>:hammer:</code></td><td>重大重构</td></tr><tr><td>:art: (调色板)</td><td><code>:art:</code></td><td>改进代码结构/代码格式</td></tr><tr><td>:fire: (火焰)</td><td><code>:fire:</code></td><td>移除代码或文件</td></tr><tr><td>:pencil2: (铅笔)</td><td><code>:pencil2:</code></td><td>修复 typo</td></tr><tr><td>:construction: (施工)</td><td><code>:construction:</code></td><td>工作进行中</td></tr><tr><td>:construction_worker: (工人)</td><td><code>:construction_worker:</code></td><td>添加 CI 构建系统</td></tr><tr><td>:green_heart: (绿心)</td><td><code>:green_heart:</code></td><td>修复 CI 构建问题</td></tr><tr><td>:lock: (锁)</td><td><code>:lock:</code></td><td>修复安全问题</td></tr><tr><td>:whale: (鲸鱼)</td><td><code>:whale:</code></td><td>Docker 相关工作</td></tr><tr><td>:apple: (苹果)</td><td><code>:apple:</code></td><td>修复 macOS 下的问题</td></tr><tr><td>:penguin: (企鹅)</td><td><code>:penguin:</code></td><td>修复 Linux 下的问题</td></tr><tr><td>:checkered_flag: (旗帜)</td><td><code>:checked_flag:</code></td><td>修复 Windows 下的问题</td></tr></tbody></table><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>emoji 表情在提交代码的时候不能乱用，否则容易造成误解。为此，开源项目 <a href="https://gitmoji.carloscuesta.me" target="_blank" rel="noopener"><code>gitmoji</code></a> 专门规定了在 github 提交代码时应当遵循的 emoji 规范。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><ol><li>默认情况下在命令行中不会显示出 emoji， 仅显示 emoji 代码。不过可以使用 <a href="https://github.com/mrowa44/emojify" target="_blank" rel="noopener"><code>emojify</code></a> 使得在命令行也可以像显示 emoji，emojify 是一个 shell 脚本。(不过这个脚本已经很老了，最近更新在3年前，而且mac提示已经不支持该命令，后空再找解决方案)</li><li>另外，markdown 也有一系列支持的 emoji，<a href="https://gist.github.com/rxaviers/7360908#file-gistfile1-md" target="_blank" rel="noopener"><code>传送门</code></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js如何获取浏览器窗口大小和网页内容尺寸</title>
      <link href="/2018/11/05/js%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%E5%B0%BA%E5%AF%B8/"/>
      <url>/2018/11/05/js%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9%E5%B0%BA%E5%AF%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是网页的大小和浏览器窗口"><a href="#什么是网页的大小和浏览器窗口" class="headerlink" title="什么是网页的大小和浏览器窗口"></a>什么是网页的大小和浏览器窗口</h1><ul><li>网页大小就是一张网页的全部面积，通常情况，网页大小由内容和CSS样式表决定。</li><li>浏览器窗口大小，是指浏览器窗口中看到的那部分网页面积，又叫视口（viewport）。</li></ul><h1 id="获取浏览器窗口大小"><a href="#获取浏览器窗口大小" class="headerlink" title="获取浏览器窗口大小"></a>获取浏览器窗口大小</h1><p>可以通过windows对象的 innerHeight 属性获取。<br>也可以通过元素的 clientHeight 属性获取。网页上每个元素都有 clientHeight 和 clientWidth 属性。这两个属性指元素的内容部分加上 padding 的大小，不包括 border 和滚动条的大小。<br>大部分情况下 document.documentElement 的大小可以代表浏览器窗口的大小，但是在 IE6 的 quirks 模式中，document.body 才返回正确的值。</p><p>如何获取浏览器窗口高度</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器内部界面的高度，即内容显示区域的高度，F12调试工具的占位会实时改变该值</span><br><span class="line">window.innerHeight</span><br><span class="line"></span><br><span class="line">// 浏览器外部界面即窗体的高度，调试工具的占位不会影响该值</span><br><span class="line">window.outerHeight</span><br><span class="line"></span><br><span class="line">// 表示 HTML 文档所在窗口的可视区域高度，效果同 window.innerHeight</span><br><span class="line">document.documentElement.clientHeight</span><br><span class="line"></span><br><span class="line">// ie6 quirks 模式下表示 body 的可视区域高度，注意：body与浏览器之间有个默认的 margin</span><br><span class="line">document.body.clientHeight</span><br></pre></td></tr></table></figure><p>与高度对应的，还有宽度：<code>window.innerWidth</code> 、<code>window.outerWidth</code>、<code>window.outerWidth</code>、<code>document.documentElement.clientWidth</code>、 <code>document.body.clientWidth</code></p><blockquote><p>说明：window.innerHeight ／ innderWidth 在ie8 及以下不支持，需要通过<br>document.documentElement.clientHeight ／ clientWidth 来替代。所以兼容的写法为：<br><code>window.innerHeight || document.documentElement.clientHeight</code><br><code>window.innderWidth || document.documentElement.clientWidth</code></p></blockquote><h1 id="获取网页内容大小"><a href="#获取网页内容大小" class="headerlink" title="获取网页内容大小"></a>获取网页内容大小</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement.scrollWidth || document.body.scrollWidth</span><br><span class="line">document.documentElement.scrollHeight || document.body.scrollHeight</span><br><span class="line"></span><br><span class="line">document.documentElement.offsetWidth || document.body.offSetWidth</span><br><span class="line">document.documentElement.offsetHeight || document.body.offSetHeight</span><br></pre></td></tr></table></figure><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>通常获取浏览器界面的宽高，是有自适应布局的需要，常常需要跟如下方法配合使用：</p><h3 id="1-window-的尺寸变化事件"><a href="#1-window-的尺寸变化事件" class="headerlink" title="1. window 的尺寸变化事件"></a>1. window 的尺寸变化事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// js</span><br><span class="line">window.onresize()</span><br><span class="line"></span><br><span class="line">// jquery</span><br><span class="line">$(window).resize()</span><br></pre></td></tr></table></figure><h3 id="2-window-的滚动事件"><a href="#2-window-的滚动事件" class="headerlink" title="2. window 的滚动事件"></a>2. window 的滚动事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// js</span><br><span class="line">window.onscroll()</span><br><span class="line"></span><br><span class="line">// jquery</span><br><span class="line">$(window).scroll()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows下模拟域名</title>
      <link href="/2018/10/05/windows%E4%B8%8B%E6%A8%A1%E6%8B%9F%E5%9F%9F%E5%90%8D/"/>
      <url>/2018/10/05/windows%E4%B8%8B%E6%A8%A1%E6%8B%9F%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>在 c盘下 <code>Windows／System32/drivers/etc/host</code> 文件内，可以添加设置域名，将本地起的服务模拟成域名形式，便于相关前端测试，比如测试跨域。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> domain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速使用express搭建服务</title>
      <link href="/2018/10/05/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8express%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/10/05/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8express%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用 express 搭建最简单的服务。需要有 node 环境。</p></blockquote><h4 id="1-安装-express"><a href="#1-安装-express" class="headerlink" title="1. 安装 express"></a>1. 安装 express</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure><h4 id="2-编写最简单的服务"><a href="#2-编写最简单的服务" class="headerlink" title="2. 编写最简单的服务"></a>2. 编写最简单的服务</h4><ul><li>新建 server.js 文件</li><li>打开 server.js 文件，写入：</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;); //引入 express</span><br><span class="line">const app = express(); //执行一下 express</span><br><span class="line">app.use(express.static(__dirname)); //指定静态文件路径</span><br><span class="line">app.listen(3000); //指定监听端口</span><br></pre></td></tr></table></figure><h4 id="3-起服务"><a href="#3-起服务" class="headerlink" title="3. 起服务"></a>3. 起服务</h4><p>命令行进入 server.js 所在目录，然后执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure></p><h4 id="4-done！"><a href="#4-done！" class="headerlink" title="4. done！"></a>4. done！</h4><p>服务已经启动，在浏览器输入 <code>http://localhost:3000</code> 就可以访问页面了。</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="1-添加接口路由"><a href="#1-添加接口路由" class="headerlink" title="1. 添加接口路由"></a>1. 添加接口路由</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//get 请求，访问地址为 `http://localhost:3000/users`</span><br><span class="line">app.get(&apos;/users&apos;, function(req, res) &#123;</span><br><span class="line">res.end(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//put 请求，访问地址为 `http://localhost:3000/users`</span><br><span class="line">app.put(&apos;/users&apos;, function(req, res) &#123;</span><br><span class="line">res.end(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-设置响应头"><a href="#2-设置响应头" class="headerlink" title="2. 设置响应头"></a>2. 设置响应头</h4><p>根据需要，有时得设置响应头，以达到某种目的，比如跨域。<br>在 server.js 文件的定义变量之后，添加一个 app.use：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">//允许哪个源可以访问我</span><br><span class="line">res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://localhost:4000&apos;);</span><br><span class="line"></span><br><span class="line">//允许携带哪个头访问我，多个头，用英文逗号隔开</span><br><span class="line">res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;name&apos;);</span><br><span class="line"></span><br><span class="line">//允许哪个方法访问我</span><br><span class="line">res.setHeader(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT&apos;);</span><br><span class="line"></span><br><span class="line">//允许携带 cookie 访问我</span><br><span class="line">res.setHeader(&apos;Access-Control-Allow-Credentials&apos;, true);</span><br><span class="line"></span><br><span class="line">//允许前端访问哪个头，多个头，用英文逗号隔开</span><br><span class="line">res.setHeader(&apos;Access-Control-Expose-Headers&apos;, &apos;name&apos;);</span><br><span class="line">next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2018/10/05/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2018/10/05/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>浏览器同源策略：<br>请求的地址与平台的协议、域名、端口号，都一致，称为 <code>同域</code>。<br>只要有一个不一样，就称为 <code>跨域</code>。</p><p>cookie、 Localstorage 不能跨域；<br>DOM元素也有同源策略（iframe）；<br>ajax 也不支持跨域。</p><p>可以跨域的 html 标签：<br><code>link</code>、 <code>img</code>、 <code>script</code></p><p>如何实现跨域：</p><ol><li>jsonp</li><li>cors</li><li>postMessage</li><li>document.domain</li><li>window.name</li><li>location.hash</li><li>http-proxy</li><li>ngix</li><li>WebSocket</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用gitbook发布自己的书籍</title>
      <link href="/2018/10/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gitbook%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
      <url>/2018/10/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gitbook%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B9%A6%E7%B1%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>利用开源项目 gitbook，自己写本书吧～</p><p>前言：gitbook 平台在今年的4月9日发布了新的版本v2。新的版本官网已经变成 <a href="www.gitbook.com"><code>www.gitbook.com</code></a> （旧的地址为 <a href="legacy.gitbook.com"><code>legacy.gitbook.com</code></a> ）。新旧版本有很多的不一样，网上很多资料都是针对旧版。 比如新版不再支持把每本书作为一个 <code>Git Repository</code> 来进行版本管理。（以前是可以针对每本书从本地 <code>git push</code> 到 gitbook 的），这点也是坑了我很久（坑一个强迫症重度患者的结果就是，不扒出被坑的根本原因誓不罢休）。更多 v2 的重大改变可以看 <a href="https://docs.gitbook.com/v2-changes/important-differences" target="_blank" rel="noopener">这里</a>。</p></blockquote><p>以下的所有操作都是针对新版的 gitbook。</p><p>使用 gitbook 编写一本书的步骤如下：</p><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="1-全局安装-gitbook-cli"><a href="#1-全局安装-gitbook-cli" class="headerlink" title="1. 全局安装 gitbook-cli"></a>1. 全局安装 gitbook-cli</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gitbook-cli -g</span><br></pre></td></tr></table></figure><h3 id="2-查看-gitbook-版本"><a href="#2-查看-gitbook-版本" class="headerlink" title="2. 查看 gitbook 版本"></a>2. 查看 gitbook 版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook --version</span><br></pre></td></tr></table></figure><p>  我在查看 gitbook 版本的时候，他会自动安装一些插件，等了一会安装完才出的版本信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLI version: 2.3.2</span><br><span class="line">GitBook version: 3.2.3</span><br></pre></td></tr></table></figure></p><h3 id="3-初始化-gitbook"><a href="#3-初始化-gitbook" class="headerlink" title="3. 初始化 gitbook"></a>3. 初始化 gitbook</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></figure><h3 id="4-编辑书籍"><a href="#4-编辑书籍" class="headerlink" title="4. 编辑书籍"></a>4. 编辑书籍</h3><ul><li><p>一个 gitbook 项目至少要包含 README.md 和 SUMMARY.md，书本的第一页内容是从文件 README.md 文件中提取的。如果这个文件名没有出现在 SUMMARY.md 文件中，则它会被添加为章节的第一个条目。而由于一些托管在 github 上的书更喜欢将 README.md 作为项目的介绍而不是书的介绍，从 gitbook v2 起，可以在 book.json 中指定某个文件作为 README。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;structure&quot;: &#123;</span><br><span class="line">&quot;readme&quot;: &quot;myIntro.md&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>gitbook 使用文件 SUMMARY.md 来定义书本的章节和子章节的结构。它用来生成书本内容的预览表。它的格式是一个简单的链接列表。另外可以在里面添加一些 markdown 格式的标题和分割线。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 概要</span><br><span class="line">* [章节 1](chapter1.md)</span><br><span class="line">* [章节 2](chapter2.md)</span><br><span class="line">* [章节 3](chapter3.md)</span><br><span class="line"></span><br><span class="line"># 基础</span><br><span class="line">* [章节 1](chapter1/README.md)</span><br><span class="line">  * [1.1 a](chapter1/a.md)</span><br><span class="line">  * [1.2 b](chapter1/b.md)</span><br><span class="line">---</span><br><span class="line">* [章节 2](chapter2/README.md)</span><br><span class="line">  * [2.1 c](chapter2/c.md)</span><br><span class="line">  * [2.2 d](chapter2/d.md)</span><br><span class="line"></span><br><span class="line"># 进阶</span><br><span class="line">* [章节 3](chapter3/README.md)</span><br></pre></td></tr></table></figure></li><li><p>编写文章内容<br>接下来就可以在相应的 md 文件里书写内容了。</p></li></ul><h3 id="5-启动-gitbook-本地服务"><a href="#5-启动-gitbook-本地服务" class="headerlink" title="5. 启动 gitbook 本地服务"></a>5. 启动 gitbook 本地服务</h3><p>写完内容，可以通过以下方式来预览书本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></figure></p><p>  <code>gitbook serve</code> 命令实际上是先调用 <code>gitbook build</code> 编译书籍，然后启动一个 web 服务器，监听在本地的4000端口。</p><h2 id="gitbook-进阶"><a href="#gitbook-进阶" class="headerlink" title="gitbook 进阶"></a>gitbook 进阶</h2><p>以上所说的都是在本地的操作，如何让别人也可以访问自己的书籍，除了自己买域名，还可以利用现有的互联网平台：gitbook.com、 github.com、 gitlab.com（gitlab也是听说可以有 gitlab pages，没有实际操作过，先略过）</p><h3 id="1-在-gitbook-com-上发布和管理书籍"><a href="#1-在-gitbook-com-上发布和管理书籍" class="headerlink" title="1. 在 gitbook.com 上发布和管理书籍"></a>1. 在 gitbook.com 上发布和管理书籍</h3><ul><li>需要先注册 gitbook 账号。可以单独注册，也可以使用 github 账号关联登录。</li><li>然后先创建一个 Orgnization 。</li><li>再在这个 Orgnization 里面创建一个 Space（旧版叫 Book）。这个就是你的书籍项目了。</li><li>然后就可以在线写书了～书籍的在线浏览地址为：<code>https://yourorgnizationname.gitbook.io/yourspacename</code></li></ul><h3 id="2-在-github-com-上发布和管理书籍"><a href="#2-在-github-com-上发布和管理书籍" class="headerlink" title="2. 在 github.com 上发布和管理书籍"></a>2. 在 github.com 上发布和管理书籍</h3><p>在前面说的本地操作，编辑和预览书籍后，可以把 build 之后的结果，上传到 github 上面，然后利用 github pages 来发布书籍。</p><ul><li>首先在 github 上新建一个跟你的书籍同名的 repository。</li><li>然后将远程仓库地址添加到本地，然后将编译后的 <code>_book</code> 目录 push 到远程。</li><li>然后在 github 上设置一下 github pages，具体方法和步骤我在另一个文章中详细介绍过：<a href="https://yc111.github.io/2018/10/05/如何给github项目建立自己的主页/" target="_blank" rel="noopener">如何给github项目建立自己的主页</a>。</li><li>在设置完后，就可以通过 <code>https://githubusername.github.io/projectname</code> 来浏览你的书了。</li></ul><h3 id="3-gitbook-与-github-关联同步"><a href="#3-gitbook-与-github-关联同步" class="headerlink" title="3. gitbook 与 github 关联同步"></a>3. gitbook 与 github 关联同步</h3><p>新版 gitbook.com 不支持本地版本管理了，但是对 github 的集成支持的不错。可以通过配置，实现在 github 项目里面提交内容，gitbook 平台会自动同步过去。</p><ul><li>在 gitbook 平台里，进入要设置的 space，也就是你的书。</li><li>点左下角的配置按钮，进入配置，点击 Intergrations ，找到 github。</li><li>点击 link you github repository 按钮，根据向导，登录 github ，选择 reposirory，选择分支，完成绑定和同步。(你还可以选择是 gitbook 同步 github ，还是 github 同步 gitbook)<blockquote><p>需要注意的是：绑定的 github 仓库分支里面要是 gitbook 的源码，也就是那些 md 文件。而不是 build 之后生成的 html 文件。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何给github项目建立自己的主页</title>
      <link href="/2018/10/05/%E5%A6%82%E4%BD%95%E7%BB%99github%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/"/>
      <url>/2018/10/05/%E5%A6%82%E4%BD%95%E7%BB%99github%E9%A1%B9%E7%9B%AE%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>想给 github 项目发布一个可访问的地址，网上的资料虽然多，但是乱。总的来讲，分为两种方法：一种是通过 github 的 <a href="https://htmlpreview.github.io/" target="_blank" rel="noopener"><code>htmlpreview</code></a> 插件来展示。另一种就是通过 github pages 来展示。关于 github pages 网上很多人对它有误解，认为一定要先创建 <code>username.github.io</code> 这个 repository 才可以，其实并不需要；还有人认为一定要把要展示的静态资源放在项目的 gh-pages 分支上才可以，其实也不用。</p></blockquote><p>总结一下我利用 github pages 给自己的项目创建主页的方法。</p><p>步骤如下：</p><a id="more"></a><h4 id="1-在-github-上建立项目-repository。"><a href="#1-在-github-上建立项目-repository。" class="headerlink" title="1. 在 github 上建立项目 repository。"></a>1. 在 github 上建立项目 repository。</h4><h4 id="2-进入该-repository-的-Settings。"><a href="#2-进入该-repository-的-Settings。" class="headerlink" title="2. 进入该 repository 的 Settings。"></a>2. 进入该 repository 的 Settings。</h4><h4 id="3-在-Options-里面，-找到-GitHub-Pages。"><a href="#3-在-Options-里面，-找到-GitHub-Pages。" class="headerlink" title="3. 在 Options 里面， 找到 GitHub Pages。"></a>3. 在 Options 里面， 找到 GitHub Pages。</h4><h4 id="4-为项目选择用于主页的分支，-然后保存。"><a href="#4-为项目选择用于主页的分支，-然后保存。" class="headerlink" title="4. 为项目选择用于主页的分支， 然后保存。"></a>4. 为项目选择用于主页的分支， 然后保存。</h4><h4 id="5-然后就可以在浏览器输入-https-username-github-io-projectname-来访问项目主页了。"><a href="#5-然后就可以在浏览器输入-https-username-github-io-projectname-来访问项目主页了。" class="headerlink" title="5. 然后就可以在浏览器输入 https://username.github.io/projectname 来访问项目主页了。"></a>5. 然后就可以在浏览器输入 <a href="https://username.github.io/projectname" target="_blank" rel="noopener">https://username.github.io/projectname</a> 来访问项目主页了。</h4><blockquote><p>当然前提是在该分支下有用于展示的 html 文件，比如 index.html</p></blockquote><hr><p>另附上 github 的 <code>htmlpreview</code> 地址：<br><a href="https://htmlpreview.github.io/" target="_blank" rel="noopener">https://htmlpreview.github.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在mac上查看隐藏文件</title>
      <link href="/2018/10/05/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"/>
      <url>/2018/10/05/%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E6%9F%A5%E7%9C%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在 Finder 里，按 <code>Cmd + Shift + .</code> 即可切换隐藏文件的显隐。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶(三)：博客域名升级</title>
      <link href="/2018/09/29/%E8%BF%9B%E9%98%B6-%E4%B8%89-%EF%BC%9A%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E5%8D%87%E7%BA%A7/"/>
      <url>/2018/09/29/%E8%BF%9B%E9%98%B6-%E4%B8%89-%EF%BC%9A%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<ol><li>购买域名，我是在阿里云上购买的，.com域名。<ul><li>先查询你想的域名是否已经被注册，如果有那就要另想一个了。</li><li>选择购买时长，一次买长一点的好像比一年一年买要划得来，而且也不容易被别人抢注。</li><li>然后购买，购买前要实名认证。</li></ul></li><li>配置DNS，添加记录，将github page域名添加进去。</li><li>github上配置custom domain，设置为新购买的域名。</li><li>hexo source里添加CNAME文件，内容为新购买的域名。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> domain </tag>
            
            <tag> hexo </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用json-server+faker模拟API服务和数据</title>
      <link href="/2018/09/26/%E5%88%A9%E7%94%A8json-server-faker%E6%A8%A1%E6%8B%9FAPI%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/09/26/%E5%88%A9%E7%94%A8json-server-faker%E6%A8%A1%E6%8B%9FAPI%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> json-sever </tag>
            
            <tag> faker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中的Date</title>
      <link href="/2018/09/26/javascript%E4%B8%AD%E7%9A%84Date/"/>
      <url>/2018/09/26/javascript%E4%B8%AD%E7%9A%84Date/</url>
      
        <content type="html"><![CDATA[<h2 id="chrome下"><a href="#chrome下" class="headerlink" title="chrome下"></a>chrome下</h2><p>结论：</p><h4 id="1-日期有前置0，则会解析为-UTC-时间，没有前置0，则会解析为本地时间。"><a href="#1-日期有前置0，则会解析为-UTC-时间，没有前置0，则会解析为本地时间。" class="headerlink" title="1. 日期有前置0，则会解析为 UTC 时间，没有前置0，则会解析为本地时间。"></a>1. 日期有前置0，则会解析为 UTC 时间，没有前置0，则会解析为本地时间。</h4><p>例如<br><code>new Date(&#39;2018-09-26&#39;).getTime()</code> 获取的是距离1970年1月1日0点UTC时间。<br><code>new Date(&#39;2018-9-26&#39;).getTime()</code> 获取的是距离1970年1月1日0点本地时间。</p><h4 id="2-Date-now-、-new-Date-、-new-Date-getTime-获取的都是距离1970年1月1日0点本地时间。"><a href="#2-Date-now-、-new-Date-、-new-Date-getTime-获取的都是距离1970年1月1日0点本地时间。" class="headerlink" title="2. Date.now()、 +new Date()、 new Date().getTime(), 获取的都是距离1970年1月1日0点本地时间。"></a>2. <code>Date.now()</code>、 <code>+new Date()</code>、 <code>new Date().getTime()</code>, 获取的都是距离1970年1月1日0点本地时间。</h4><blockquote><p>检验依据：<code>Date.UTC()</code> 该方法使用的是UTC时间。而 <code>Date.UTC(2018, 8, 26)</code> 跟 <code>Date.now()</code>、 <code>+new Date()</code>、 <code>new Date().getTime()</code> 获得的值相差8个小时。</p></blockquote><h2 id="ie下"><a href="#ie下" class="headerlink" title="ie下"></a>ie下</h2><a id="more"></a><p>结论：</p><h4 id="1-不支持非UTC格式的-new-Date"><a href="#1-不支持非UTC格式的-new-Date" class="headerlink" title="1. 不支持非UTC格式的 new Date()."></a>1. 不支持非UTC格式的 <code>new Date()</code>.</h4><h4 id="2-并且-Date-now-、-new-Date-、-new-Date-getTime-获取的都是距离1970年1月1日0点的UTC时间。"><a href="#2-并且-Date-now-、-new-Date-、-new-Date-getTime-获取的都是距离1970年1月1日0点的UTC时间。" class="headerlink" title="2. 并且 Date.now()、 +new Date()、 new Date().getTime() 获取的都是距离1970年1月1日0点的UTC时间。"></a>2. 并且 <code>Date.now()</code>、 <code>+new Date()</code>、 <code>new Date().getTime()</code> 获取的都是距离1970年1月1日0点的UTC时间。</h4><blockquote><p>检验依据：而 <code>Date.UTC(2018, 8, 26)</code> 跟 <code>Date.now()</code>、 <code>+new Date()</code>、 <code>new Date().getTime()</code> 获得的值在同一个时区。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10下中文输入法简繁切换快捷键</title>
      <link href="/2018/09/26/win10%E4%B8%8B%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%AE%80%E7%B9%81%E5%88%87%E6%8D%A2%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/09/26/win10%E4%B8%8B%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%AE%80%E7%B9%81%E5%88%87%E6%8D%A2%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>在中文输入法下，按 ctr+shift+f 。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git reflog</title>
      <link href="/2018/09/25/git-reflog/"/>
      <url>/2018/09/25/git-reflog/</url>
      
        <content type="html"><![CDATA[<p>git log 查看的是 commit 记录。<br>git reflog 查看的是所有的 HEAD 改变的记录。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> reflog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让本地分支与远程分支建立映射关系</title>
      <link href="/2018/09/25/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E4%B8%8E%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2018/09/25/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E4%B8%8E%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git 建分支很 cheap，本地和远程都常常各自拥有大量分支，有时本地分支需要跟某个新的远程分支建立追踪映射，以便于在 pull、 push 等操作时，简化命令，也在一定程度上防止误传到其他分支。今天建立了新的远程分支，本地不想弄一个新的跟它对应，想用当前分支换个关联，用到了该技能。</p></blockquote><h3 id="核心命令"><a href="#核心命令" class="headerlink" title="核心命令"></a>核心命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=[remote-name/remote-branch-name]</span><br></pre></td></tr></table></figure><h3 id="详解"><a href="#详解" class="headerlink" title="详解:"></a>详解:</h3><a id="more"></a><p>完成同样效果的命令还有：</p><h4 id="git-1-8-以上"><a href="#git-1-8-以上" class="headerlink" title="git 1.8 以上"></a>git 1.8 以上</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -u [remote-name/remote-branch-name]</span><br><span class="line"># or 如果要关联的本地分支不是当前分支</span><br><span class="line">git branch -u [remote-name/remote-branch-name] [local-branch-name]</span><br></pre></td></tr></table></figure><p>如果比较喜欢比较长的命令写法(我比较喜欢，是不是很变态，哈哈)，可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=[remote-name/remote-branch-name]</span><br><span class="line"># or 如果要关联的本地分支不是当前分支</span><br><span class="line">git branch --set-upstream-to=[remote-name/remote-branch-name] [local-branch-name]</span><br></pre></td></tr></table></figure></p><p>例如，我有个本地分支 dev，想跟远程 origin 的 v1.1 关联：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#如果当前就在 dev 分支上：</span><br><span class="line">git branch -u origin/v1.1</span><br><span class="line">#or</span><br><span class="line">git branch --set-upstream-to=origin/v1.1</span><br><span class="line"></span><br><span class="line">#如果当前不在 dev 分支上：</span><br><span class="line">git branch -u origin/v1.1 dev</span><br><span class="line">#or</span><br><span class="line">git branch --set-upstream-to=origin/v1.1 dev</span><br></pre></td></tr></table></figure></p><h4 id="git-1-7-以上（已经在2-几版本停用）"><a href="#git-1-7-以上（已经在2-几版本停用）" class="headerlink" title="git 1.7 以上（已经在2.几版本停用）"></a>git 1.7 以上（已经在2.几版本停用）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream dev origin/v1.1</span><br></pre></td></tr></table></figure><h3 id="如果要在-check-分支的时候进行映射"><a href="#如果要在-check-分支的时候进行映射" class="headerlink" title="如果要在 check 分支的时候进行映射"></a>如果要在 check 分支的时候进行映射</h3><p>check 到与远程分支同名的本地分支 v1.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track origin/v1.1   #git 1.6.2 以上</span><br></pre></td></tr></table></figure></p><p>check 到与远程分支不同名的分支 dev2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev2 origin/v1.1</span><br></pre></td></tr></table></figure></p><h3 id="查看本地分支与远程分支的映射情况"><a href="#查看本地分支与远程分支的映射情况" class="headerlink" title="查看本地分支与远程分支的映射情况"></a>查看本地分支与远程分支的映射情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> branch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让远程仓库回退到某个之前的版本</title>
      <link href="/2018/09/23/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9B%9E%E9%80%80%E5%88%B0%E6%9F%90%E4%B8%AA%E4%B9%8B%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC/"/>
      <url>/2018/09/23/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9B%9E%E9%80%80%E5%88%B0%E6%9F%90%E4%B8%AA%E4%B9%8B%E5%89%8D%E7%9A%84%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>pull 代码再次遇到冲突，这次突发奇想，想试试用 git stash 来处理，结果 push 完，队友反映她 pull 后好多代码被重置，并且遇到严重冲突，受牵连70几个文件。我查看了下 commit 记录，惊讶地发现，我处理完冲突传上去的代码确实都变成了我本地的老代码，pull 下来的修改都被我重置了。都是乱用 git stash 的错。。还好发现的及时，我立即决定撤回远程仓库中我的那次 push，让代码回滚到我 push 前的状态。一番资料查找，顺利搞定。</p></blockquote><p>只需五步，方法如下：</p><h3 id="1-查看-commit-日志，确定要回滚到的-commit-id（前7位即可）"><a href="#1-查看-commit-日志，确定要回滚到的-commit-id（前7位即可）" class="headerlink" title="1. 查看 commit 日志，确定要回滚到的 commit id（前7位即可）"></a>1. 查看 commit 日志，确定要回滚到的 commit id（前7位即可）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>找到要回到的那次 commit ，复制 commit id，比如我这里是 b8b2df7</p><h3 id="2-先备份下当前版本"><a href="#2-先备份下当前版本" class="headerlink" title="2. 先备份下当前版本"></a>2. 先备份下当前版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b old_dev</span><br><span class="line">git push origin old_dev:old_dev</span><br></pre></td></tr></table></figure><h3 id="3-本地回滚到指定代码版本"><a href="#3-本地回滚到指定代码版本" class="headerlink" title="3. 本地回滚到指定代码版本"></a>3. 本地回滚到指定代码版本</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard b8b2df7</span><br></pre></td></tr></table></figure><h3 id="4-删除远程对应的分支"><a href="#4-删除远程对应的分支" class="headerlink" title="4. 删除远程对应的分支"></a>4. 删除远程对应的分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin :dev</span><br><span class="line">//or</span><br><span class="line">git push origin --delete dev</span><br></pre></td></tr></table></figure><h3 id="5-重新创建远程分支"><a href="#5-重新创建远程分支" class="headerlink" title="5. 重新创建远程分支"></a>5. 重新创建远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev:dev</span><br></pre></td></tr></table></figure><h3 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h3><blockquote><p>或者，不使用删除分支再建分支的方法，这个要两部，有些麻烦，可以使用强制推送，只需一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev:dev -f  #因为reset后本地仓库落后于远程仓库，因此要强制提交</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> reset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何撤销 git add 和 git commit </title>
      <link href="/2018/09/19/%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80-git-add-%E5%92%8C-git-commit/"/>
      <url>/2018/09/19/%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80-git-add-%E5%92%8C-git-commit/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于心急，提交代码的时候，commit 后，发现多提交了一个文件，然后第一想法是使用 <code>rebase</code> 来修改提交，然后我把那个多提交的文件，恢复成修改前的样子，然后打算在 <code>git add .</code> 之后进行 rebase ，结果查看状态发现，它把我之前在编辑器里面忽略的一个文件也给加进来了…所以这个时候，我既多 commit 了， 又多 add 了…蜜汁尴尬…</p></blockquote><p>经过查找资料，问题解决，又 get 到 git 的新技能：</p><h3 id="1-git-add-多了"><a href="#1-git-add-多了" class="headerlink" title="1. git add 多了"></a>1. git add 多了</h3><a id="more"></a><ul><li>git status 查看下 add 的文件</li><li>git reset HEAD 。如果后面什么都不跟，就是把上一次的 git add 全部撤销。<br>or</li><li>git reset HEAD xxx/xxx/xxx.js ，则对某个文件进行撤销 add。</li></ul><h3 id="2-git-add-多了之后，又-commit-了"><a href="#2-git-add-多了之后，又-commit-了" class="headerlink" title="2. git add 多了之后，又 commit 了"></a>2. git add 多了之后，又 commit 了</h3><ul><li>先使用 git log –oneline 查看节点，找到这次 commit 的上一次 commit 记录。</li><li>然后 git reset commit_id 。退回到上一个提交的节点，代码还是原来你修改的样子，即提交前的样子。</li></ul><h3 id="3-使用-git-revert-还原已经提交的修改（这个没有验证过）"><a href="#3-使用-git-revert-还原已经提交的修改（这个没有验证过）" class="headerlink" title="3. 使用 git revert 还原已经提交的修改（这个没有验证过）"></a>3. 使用 git revert 还原已经提交的修改（这个没有验证过）</h3><p>使用 git revert 后，此次操作之前和之后的 commit 和 history 都会保留，并且把这次撤销作为一次最新的提交。</p><ul><li>git revert HEAD 撤销前一次 commit</li><li>git revert HEAD^ 撤销前一次 commit</li><li>git revert commit_id 撤销指定的版本，撤销也会作为一次提交进行保存。<br>git revert 是提交一个新的版本，将需要 revert 的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> reset </tag>
            
            <tag> revert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶(二)：hexo博客配置</title>
      <link href="/2018/09/19/%E8%BF%9B%E9%98%B6-%E4%BA%8C-%EF%BC%9Ahexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/19/%E8%BF%9B%E9%98%B6-%E4%BA%8C-%EF%BC%9Ahexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="进阶-二-：hexo博客配置"><a href="#进阶-二-：hexo博客配置" class="headerlink" title="进阶(二)：hexo博客配置"></a>进阶(二)：hexo博客配置</h2><h3 id="1-添加评论系统"><a href="#1-添加评论系统" class="headerlink" title="1. 添加评论系统"></a>1. 添加评论系统</h3><p>hexo官方提供了很多评论系统的配置，我选择的是’来必力’。<br>我先注册了<a href="https://livere.com" target="_blank" rel="noopener">来必力</a>，<br>然后创建了一个liverre city，获取到代码中的 <code>uid</code> ，<br>然后编辑 <code>hexo</code> 主题配置文件 <code>_config.yml</code> , 编辑 <code>livere_uid</code> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liverre_uid: #我在来必力获取的uid</span><br></pre></td></tr></table></figure></p><h3 id="2-添加-tags-页面"><a href="#2-添加-tags-页面" class="headerlink" title="2. 添加 tags 页面"></a>2. 添加 tags 页面</h3><a id="more"></a><ol><li><p>在终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li><li><p>在生成的 tags 目录下，编辑 index.md ，添加 tags 字段，屏蔽该页的评论功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-09-09 22:51:31</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>在 <code>_config.yml</code> 文件中，编辑menu字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home:/</span><br><span class="line">  archives: /archives</span><br><span class="line">  tags: /tags</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-添加-categories-页面"><a href="#3-添加-categories-页面" class="headerlink" title="3. 添加 categories 页面"></a>3. 添加 categories 页面</h3><ol><li><p>在终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li><li><p>在生成的 categories 目录下，编辑 index.md ，添加 categories 字段，屏蔽该页的评论功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-09-09 22:51:31</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>在 <code>_config.yml</code> 文件中，编辑menu字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home:/</span><br><span class="line">  archives: /archives</span><br><span class="line">  tags: /tags</span><br><span class="line">  categories: /categories</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-添加-about-页面"><a href="#4-添加-about-页面" class="headerlink" title="4. 添加 about 页面"></a>4. 添加 about 页面</h3><ol><li><p>在终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure></li><li><p>在生成的 about 目录下，编辑 index.md ，屏蔽该页的评论功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-09-09 22:51:31</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-设置-‘阅读全文’"><a href="#5-设置-‘阅读全文’" class="headerlink" title="5. 设置 ‘阅读全文’"></a>5. 设置 ‘阅读全文’</h3><p>效果：在首页提供文章的部分内容，并提供一个链接跳转到全文页面。<br>在 NextT 中提供了三种方式，我比较喜欢它推荐的那种，也是 Hexo 提供的方式：<br>在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断。</p><h3 id="6-配置博客文档模版"><a href="#6-配置博客文档模版" class="headerlink" title="6. 配置博客文档模版"></a>6. 配置博客文档模版</h3><p>hexo 中，运行 <code>hexo new &quot;xxx&quot;</code> 是调用了 <code>scaffolds</code> 目录下的 <code>post.md</code> 文件作为模版来创建的。<br>所以修改这个模版，就可以达到每次创建文档可以使用自己习惯的模版了。<br>默认模版是没有 categories 的，我需要这个字段，所以在模版中加上了这个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: </span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何修改git中已经提交的内容</title>
      <link href="/2018/09/11/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9git%E4%B8%AD%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E7%9A%84%E5%86%85%E5%AE%B9/"/>
      <url>/2018/09/11/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9git%E4%B8%AD%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BA%A4%E7%9A%84%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在git上提交代码的时候，不小心在 commit message 中打了几个错别字，merge、push 完了才发现。。 由于我的完美主义加强迫症比较严重，那几个错别字越看越不顺眼，寻思着把它们给改过来。查了资料，加上实验，终于搞定。</p></blockquote><p>只需五步，方法如下：</p><h2 id="修改某次提交的-commit-message"><a href="#修改某次提交的-commit-message" class="headerlink" title="修改某次提交的 commit message"></a>修改某次提交的 commit message</h2><p>需要注意的是：如果提交次数超过2次，则没有办法修改第1次的提交信息，第2次以后的信息都可以通过此方法修改。</p><h3 id="1-查看提交的-commit-id-SHA值"><a href="#1-查看提交的-commit-id-SHA值" class="headerlink" title="1. 查看提交的 commit id (SHA值)"></a>1. 查看提交的 commit id (SHA值)</h3><p>如果 push 过，可以在git托管平台（比如 github、gitlab)上的 commits 里面看到（那串40位的编码就是了），只需要其前7位。<br>或者直接通过 <code>git log</code> 命令查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure></p><p>在展示的结果上每条 log 记录的前面的字段就是我们需要的 SHA 值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">b8b2df7 (HEAD -&gt; master, origin/master) 中文</span><br><span class="line">dd09519 di sici tijiao</span><br><span class="line">f1d9380 english only modify again..</span><br><span class="line">ea8a3b5 nonono correct message</span><br><span class="line">66a4488 need to be changed message</span><br></pre></td></tr></table></figure></p><p>比如我要修改的那条 commit 的 SHA 为：dd09519<br>那我需要的是这一条之前的一条 commit 的 SHA ：f1d9380</p><h3 id="2-通过-git-rebase-命令回到要修改提交的上一次提交的基础上"><a href="#2-通过-git-rebase-命令回到要修改提交的上一次提交的基础上" class="headerlink" title="2. 通过 git rebase 命令回到要修改提交的上一次提交的基础上"></a>2. 通过 <code>git rebase</code> 命令回到要修改提交的上一次提交的基础上</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i f1d9380</span><br></pre></td></tr></table></figure><p>等待一会，然后会打开 vim 编辑器，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pick dd09519 di sici tijiao</span><br><span class="line">pick b8b2df7 中文</span><br><span class="line"></span><br><span class="line"># Rebase f1d9380..f52c471 onto f1d9380 (2 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span><br><span class="line"># d, drop &lt;commit&gt; = remove commit</span><br><span class="line"># l, label &lt;label&gt; = label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; = reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&apos;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line">#       However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure></p><p>在编辑器中找到你要修改的那个提交信息，用 <code>i</code> 命令进入编辑，<br>将那一行开头的 <code>pick</code> 改为 <code>edit</code>: <code>pick dd09519 di sici tijiao</code> -&gt; <code>edit dd09519 di sici tijiao</code><br>然后 <code>esc</code> -&gt; <code>:</code> -&gt; <code>wq</code>, 保存退出。</p><p>然后界面显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i f1d9380</span><br><span class="line">Stopped at dd09519...  di sici tijiao</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --continue</span><br></pre></td></tr></table></figure></p><h3 id="3-修改-commit-message："><a href="#3-修改-commit-message：" class="headerlink" title="3. 修改 commit message："></a>3. 修改 commit message：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>再次进入 vim 编辑器，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">di sici tijiao</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># Date:      Tue Sep 11 18:49:29 2018 +0800</span><br><span class="line">#</span><br><span class="line"># interactive rebase in progress; onto f1d9380</span><br><span class="line"># Last command done (1 command done):</span><br><span class="line">#    edit 4df3762 中文信息 sici tijiao</span><br><span class="line"># Next command to do (1 remaining command):</span><br><span class="line">#    pick f52c471 中文</span><br><span class="line"># You are currently editing a commit while rebasing branch &apos;master&apos; on &apos;f1d9380&apos;.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       modified:   README.md</span><br><span class="line">#</span><br></pre></td></tr></table></figure></p><p>可以看到第一行就是要修改的 commit message。<br>同样的通过 vim 命令 进入编辑模式，修改提交信息: <code>di sici tijiao</code> -&gt; <code>中文信息 sici tijiao</code><br>然后<code>:wq</code> 保存退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br><span class="line">[detached HEAD 4df3762] 中文信息 sici tijiao</span><br><span class="line"> Date: Tue Sep 11 18:49:29 2018 +0800</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure></p><h3 id="4-完成-rebase："><a href="#4-完成-rebase：" class="headerlink" title="4. 完成 rebase："></a>4. 完成 rebase：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>等待一会，然后出现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --continue</span><br><span class="line">Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure></p><p>表明操作成功。</p><h3 id="5-将修改后的变动-push-到远程"><a href="#5-将修改后的变动-push-到远程" class="headerlink" title="5. 将修改后的变动 push 到远程"></a>5. 将修改后的变动 push 到远程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master -f</span><br></pre></td></tr></table></figure><p>注意一定要使用 <code>-f</code> 参数，表示强制推送。<br>因为我们没有产生新的 commit（用 <code>git status</code> 可以看出），直接 push 不会发送任何东西。</p><h3 id="6-现在我们去远程仓库刷新下-commit-记录，可以看到-commit-信息就已经修改了。"><a href="#6-现在我们去远程仓库刷新下-commit-记录，可以看到-commit-信息就已经修改了。" class="headerlink" title="6. 现在我们去远程仓库刷新下 commit 记录，可以看到 commit 信息就已经修改了。"></a>6. 现在我们去远程仓库刷新下 commit 记录，可以看到 commit 信息就已经修改了。</h3><h3 id="最后，我们再来看下我们的日志信息"><a href="#最后，我们再来看下我们的日志信息" class="headerlink" title="最后，我们再来看下我们的日志信息"></a>最后，我们再来看下我们的日志信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>细心点就会发现，从我们修改的那条 commit 起，之后的所有的 commit 的 commit id 都发生了变化！我修改的那条，由 <code>dd09519</code> 变成了 <code>4df3762</code>; 而它之后的那条记录也由 <code>b8b2df7</code> 变成了 <code>f52c471</code> 虽然我没由修改这条 commit 信息。<br><figure class="highlight plain"><figcaption><span>git log --oneline</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f52c471 (HEAD -&gt; master, origin/master) 中文</span><br><span class="line">4df3762 中文信息 sici tijiao</span><br><span class="line">f1d9380 english only modify again..</span><br><span class="line">ea8a3b5 nonono correct message</span><br><span class="line">66a4488 need to be changed message</span><br></pre></td></tr></table></figure></p><h2 id="BTW-还要说一个要注意的"><a href="#BTW-还要说一个要注意的" class="headerlink" title="BTW 还要说一个要注意的"></a>BTW 还要说一个要注意的</h2><p> 就是如果 commit 信息要输入中文，记得用 git bash。因为我是在 IDE（webstorm）上进行的 commit，用的中文（要不怎么有错别字呢），那在修改 commit 信息的时候，我仍想用中文，我用 cmd、powerShell、Cmder，都试了，没法在 vim 里面敲中文，直接乱码，查资料改配置（quotepath = false、[gui] encoding = utf8）等等都没用，最后怀着绝望的心情，试了下 git bash， 居然中文支持的非常好！真是。。</p><blockquote><h2 id="另外，在查资料的过程中，还顺便-get-到几个-git-的高级技能。总结如下："><a href="#另外，在查资料的过程中，还顺便-get-到几个-git-的高级技能。总结如下：" class="headerlink" title="另外，在查资料的过程中，还顺便 get 到几个 git 的高级技能。总结如下："></a>另外，在查资料的过程中，还顺便 get 到几个 git 的高级技能。总结如下：</h2><h3 id="1-修改最近一次的提交"><a href="#1-修改最近一次的提交" class="headerlink" title="1. 修改最近一次的提交"></a>1. 修改最近一次的提交</h3><h4 id="方法一：commit-–amend"><a href="#方法一：commit-–amend" class="headerlink" title="方法一：commit –amend"></a>方法一：commit –amend</h4><p>这种方法不仅可以修改 commit message，也可以修改提交内容。这种方式在还没有推送到远端的情况下，可以保持原有的 Change-Id（commit id）。若已经推送到远端，Change-Id 则会修改掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改需要修改的项目代码(如果只需要修改 commit message 就不用做)</span><br><span class="line">git add . #如果只需要修改 commit message 就不用做</span><br><span class="line">git commit --amend</span><br><span class="line"># 在出现的 vim 编辑器中修改 commit message，保存退出。</span><br><span class="line">git push &lt;remote&gt; &lt;branch&gt; -f #若还没有推送到远端，就不用做</span><br></pre></td></tr></table></figure></p><h4 id="方法二：reset"><a href="#方法二：reset" class="headerlink" title="方法二：reset"></a>方法二：reset</h4><p>这种方法也可以修改条内容和 commit message。这种方式在还没有推送到远端的情况下，也可以保持原有的 Change-Id（commit id）。若已经推送到远端，Change-Id 则会修改掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^</span><br><span class="line"># 修改需要修改的项目代码(如果只需要修改 commit message 就不用做)</span><br><span class="line">git add . # 如果只需要修改 commit message 就不用做</span><br><span class="line">git commit -m “new commit message”</span><br><span class="line">git push &lt;remote&gt; &lt;branch&gt; -f # 若还没有推送到远端，就不用做</span><br></pre></td></tr></table></figure></p><h3 id="2-提交到了错误的分支上的处理"><a href="#2-提交到了错误的分支上的处理" class="headerlink" title="2. 提交到了错误的分支上的处理"></a>2. 提交到了错误的分支上的处理</h3><h4 id="方法一：reset-stash"><a href="#方法一：reset-stash" class="headerlink" title="方法一：reset + stash"></a>方法一：reset + stash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 取消最新的提交， 然后保留现场原状</span><br><span class="line">git reset HEAD~ --soft</span><br><span class="line">git stash</span><br><span class="line"># 切换到正确的分支</span><br><span class="line">git checkout name-of-correct-branch</span><br><span class="line">git stash pop</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;new commit message&quot;</span><br><span class="line"># 现在你已经提交到正确的分支上了</span><br></pre></td></tr></table></figure><h4 id="方法二：cherry-pick-摘樱桃"><a href="#方法二：cherry-pick-摘樱桃" class="headerlink" title="方法二：cherry-pick 摘樱桃"></a>方法二：cherry-pick 摘樱桃</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout name-of-correct-branch</span><br><span class="line"># 把主分支上的最新提交摘过来～</span><br><span class="line">git cherry-pick master</span><br><span class="line"># 再删掉主分支上的最新提交</span><br><span class="line">git checkout master</span><br><span class="line">git reset HEAD~ --hard</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> rebase </tag>
            
            <tag> amend </tag>
            
            <tag> cherry-pick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用express/koa快速起一个node服务</title>
      <link href="/2018/09/11/%E4%BD%BF%E7%94%A8express-koa%E5%BF%AB%E9%80%9F%E8%B5%B7%E4%B8%80%E4%B8%AAnode%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/09/11/%E4%BD%BF%E7%94%A8express-koa%E5%BF%AB%E9%80%9F%E8%B5%B7%E4%B8%80%E4%B8%AAnode%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><p>express 导出的是一个函数。</p><h4 id="1-最简单的服务"><a href="#1-最简单的服务" class="headerlink" title="1. 最简单的服务"></a>1. 最简单的服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// www.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">res.end(&apos;server by express&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure><h4 id="2-使用-express-generator"><a href="#2-使用-express-generator" class="headerlink" title="2. 使用 express-generator"></a>2. 使用 express-generator</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i express</span><br><span class="line">npx express-generator //需要nodejs8.2及以上</span><br><span class="line">//nodejs8.2以下：</span><br><span class="line">//npm i -g express-generator</span><br><span class="line">//express --view=ejs myproject</span><br></pre></td></tr></table></figure><p>会在当前目录下生成一个项目，7个文件夹，9个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|--app.js</span><br><span class="line">|--bin/</span><br><span class="line">|    |-- www.js</span><br><span class="line">|--package.json</span><br><span class="line">|--public/</span><br><span class="line">|    |-- images/</span><br><span class="line">|    |-- javascript/</span><br><span class="line">|    |-- stylesheets/</span><br><span class="line">|            |--  style.css</span><br><span class="line">|--routes/</span><br><span class="line">|    |-- index.js</span><br><span class="line">|    |-- users.js</span><br><span class="line">|--views/</span><br><span class="line">     |-- error.jade</span><br><span class="line">     |-- index.jade</span><br><span class="line">     |-- layout.jade</span><br></pre></td></tr></table></figure></p><p>然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line">DEBUGE=projectname:* npm start</span><br><span class="line">//在windows下这样：</span><br><span class="line">//set DEBUG=projectname:* npm start</span><br></pre></td></tr></table></figure></p><h3 id="koa"><a href="#koa" class="headerlink" title="koa"></a>koa</h3><p>koa导出的是一个对象。</p><h4 id="最简单的服务"><a href="#最简单的服务" class="headerlink" title="最简单的服务"></a>最简单的服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i koa</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// www.js</span><br><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">cnost app = new Koa();</span><br><span class="line"></span><br><span class="line">app.use((ctx) =&gt; &#123;</span><br><span class="line">ctx.body = &apos;server by koa&apos;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> express </tag>
            
            <tag> koa </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git错误：HTTP Basic: Access denied</title>
      <link href="/2018/09/10/git%E9%94%99%E8%AF%AF%EF%BC%9AHTTP-Basic-Access-denied/"/>
      <url>/2018/09/10/git%E9%94%99%E8%AF%AF%EF%BC%9AHTTP-Basic-Access-denied/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上周五修改了gitlab的用户密码，今天发现操作git远程仓库都报错拒绝，错误信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remote: HTTP Basic: Access denied</span><br><span class="line">fatal: Athentication failed for &apos;https://************&apos;</span><br></pre></td></tr></table></figure></p></blockquote><p>直觉告诉我，是改密码引起。网上查了资料，确实 git 会把第一次输入过的用户名密码存储起来，再次使用 git 命令的时候，会使用存储的用户名密码，然而当 git 的密码修改后，原来存储的密码肯定匹配不了，于是直接报没有权限终止操作。网上类似的帖子很多，但是不是都有效，在多次尝试后，终于解决，解决办法如下：</p><p>首先我因为有两台电脑，一台 win7，一台 win10，不同操作系统解决方式还不一样，也是坑了我很多时间。。。</p><h2 id="win-10-下的解决办法"><a href="#win-10-下的解决办法" class="headerlink" title="win 10 下的解决办法"></a>win 10 下的解决办法</h2><a id="more"></a><p>解决办法很简单，一句命令搞定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system -unset credentia.helper</span><br></pre></td></tr></table></figure></p><p>不过要注意的是在 win10 中，这个命令需要在管理员权限下运行，否则报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: could not lock config file C:/Program Files/Git/migw64/etc/gitconfig: Permission denied</span><br></pre></td></tr></table></figure></p><p>在 linux 下使用 <code>sudo</code> 可以切换到管理员权限，但是在 win10 上，只能先找到 cmd 的快捷方式，然后右键，以管理员身份运行。比如，在左下角windows符号上右键 -&gt; <code>Windows PowerShell(管理员)</code>。</p><p>运行后，命令的前面的路径会显示为：<code>PS C:\Windows\system32&gt;</code></p><h2 id="win-7-下的解决办法"><a href="#win-7-下的解决办法" class="headerlink" title="win 7 下的解决办法"></a>win 7 下的解决办法</h2><p>使用刚才在 win 10 上的解决办法，在 win 7 上尝试无效。。。<br>win 7 下采用的办法是直接修改凭据：</p><ol><li>进入 <code>控制面版 -&gt; 所有用户 -&gt; 凭据管理</code></li><li>在 <code>Windows 凭据</code> 下，找到 gitlab 对应的凭据</li><li>点 <code>编辑</code>，修改密码，保存。</li><li>done。</li></ol><p>然后执行下刚才的 <code>git pull</code> 命令，妥妥滴拉下来。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> access denied </tag>
            
            <tag> authentication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码片段</title>
      <link href="/2018/09/06/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
      <url>/2018/09/06/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="1-文字截断"><a href="#1-文字截断" class="headerlink" title="1. 文字截断"></a>1. 文字截断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.ellipsis &#123;</span><br><span class="line">overflow: hidden;</span><br><span class="line">white-space: nowrap;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-清除浮动"><a href="#2-清除浮动" class="headerlink" title="2. 清除浮动"></a>2. 清除浮动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123;</span><br><span class="line">zoom: 1;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">clear:both;</span><br><span class="line">content: &quot;&quot;;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-javascript-生成-img-标签的3种方式"><a href="#3-javascript-生成-img-标签的3种方式" class="headerlink" title="3. javascript 生成 img 标签的3种方式"></a>3. javascript 生成 <code>img</code> 标签的3种方式</h3><p>方式1: 使用 createElement 方法</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img = document.createElement(&apos;img&apos;);</span><br><span class="line">img.src = &apos;https://www.baidu.com/img/bd_logo1.png&apos;</span><br><span class="line">document.body.appendChild(img);</span><br></pre></td></tr></table></figure><p>方式2: 使用 innerHTML 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var imgHtml = &apos;&lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; &gt;&apos;;</span><br><span class="line">document.body.innerHTML = imgHtml;</span><br></pre></td></tr></table></figure></p><p>方式3: 使用 new image() 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var img = new image();</span><br><span class="line">img.src = &apos;https://www.baidu.com/img/bd_logo1.png&apos;;</span><br><span class="line">document.body.appendChild(img);</span><br></pre></td></tr></table></figure></p><h3 id="4-js-添加、删除-class"><a href="#4-js-添加、删除-class" class="headerlink" title="4. js 添加、删除 class"></a>4. js 添加、删除 class</h3><p>方法1: 比较传统的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var classVal = docment.getElementById(&apos;id&apos;).getAttribute(&apos;class&apos;);</span><br><span class="line">// 删除某个class</span><br><span class="line">var classVal = classVal.replace(&apos;someclassname&apos;, &apos;&apos;);</span><br><span class="line">document.getElementById.setAttribute(&apos;class&apos;, classVal);</span><br><span class="line"></span><br><span class="line">// 添加class</span><br><span class="line">var classVal = classVal.concat(&apos;newclassname&apos;);</span><br><span class="line">document.getElementById.setAttribute(&apos;class&apos;, classVal);</span><br><span class="line"></span><br><span class="line">// 替换class</span><br><span class="line">var classVal = classVal.replace(&apos;someclassname&apos;, &apos;newclassname&apos;);</span><br><span class="line">document.getElementById.setAttribute(&apos;class&apos;, classVal);</span><br></pre></td></tr></table></figure></p><p>方法2: HTML5中添加了classList<br>classList 属性返回元素的雷鸣，作为DOMTokenList对象。<br>classList 属性是只读的，但是可以使用 add() 和 remove() 方法修改它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 增加</span><br><span class="line">document.getElementById(&apos;id&apos;).classList.add(&apos;class1&apos;, &apos;class2&apos;, &apos;class3&apos;);</span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">document.getElemtnById(&apos;id&apos;).classList.remove(&apos;class1&apos;);</span><br></pre></td></tr></table></figure></p><p>方法3: 正则匹配<br>…</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> front-end </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web端页面如何在移动端也获得较好体验</title>
      <link href="/2018/09/05/web%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B9%9F%E8%8E%B7%E5%BE%97%E8%BE%83%E5%A5%BD%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/09/05/web%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B9%9F%E8%8E%B7%E5%BE%97%E8%BE%83%E5%A5%BD%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>在网页的 <code>head</code> 标签里，加上对 <code>viewport</code> 的设置，就可以让页面在移动设备上可以以比较好的缩放和比例来呈现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; &gt;</span><br></pre></td></tr></table></figure></p><p>还可以加入更多设置，如缩放之类：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes&quot; &gt;</span><br></pre></td></tr></table></figure><p>参数解释：<br>width：可以控制 viewport 的大小，可以指定一个数值，或者一个特殊的值，比如 <code>device-width</code> 设备的宽度。<br>initial-scale：初始缩放比例，也即当前页面第一次load的时候缩放比例<br>minimum-scale：允许用户缩放到的最小比例。<br>maximum-scale：允许用户缩放到的最大比例。<br>user-scalable：用户是否可以手动缩放。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> viewport </tag>
            
            <tag> mobiles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设置IDE编辑器以配合自动实时编译</title>
      <link href="/2018/09/02/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEIDE%E7%BC%96%E8%BE%91%E5%99%A8%E4%BB%A5%E9%85%8D%E5%90%88%E8%87%AA%E5%8A%A8%E5%AE%9E%E6%97%B6%E7%BC%96%E8%AF%91/"/>
      <url>/2018/09/02/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEIDE%E7%BC%96%E8%BE%91%E5%99%A8%E4%BB%A5%E9%85%8D%E5%90%88%E8%87%AA%E5%8A%A8%E5%AE%9E%E6%97%B6%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在前端开发过程中，通过webpack配置了即时监听并自动编译，实现保存文件触发编译。但是有的编辑器有 “安全写入” 的机制（就是在编辑器保存文件后不直接写入硬盘，而是先保存在编辑器内部的缓存里面，到一定时间后再写入硬盘），这会造成触发编译不那么实时，很影响开发效率。</p></blockquote><p>以下是针对几款常见编辑器，如何禁用安全写入的设置办法：</p><h3 id="JetBrains-IDEs（e-g-WebStorm"><a href="#JetBrains-IDEs（e-g-WebStorm" class="headerlink" title="JetBrains IDEs（e.g. WebStorm):"></a>JetBrains IDEs（e.g. WebStorm):</h3><a id="more"></a><p>在 <code>Preferences &gt; Appearance &amp; Behavior &gt; System Settings</code> 里面，去掉对 “Use safe write” 选项的勾选。即可。</p><h3 id="Sublime-Text3"><a href="#Sublime-Text3" class="headerlink" title="Sublime Text3:"></a>Sublime Text3:</h3><p>在 preferences-user 文件里，添加 <code>atomic_save: false</code>。即可。</p><h3 id="Vim："><a href="#Vim：" class="headerlink" title="Vim："></a>Vim：</h3><p>在 setting 文件里，添加 <code>:set backupcopy=yes</code> 。即可。</p>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webstorm </tag>
            
            <tag> sublime </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git冲突处理</title>
      <link href="/2018/08/30/git%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/"/>
      <url>/2018/08/30/git%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="git冲突处理"><a href="#git冲突处理" class="headerlink" title="git冲突处理"></a>git冲突处理</h1><blockquote><p>今天在merge分支的时候，由于记忆错位，导致merge了另一个分支到master（我原本是要把format分支合并到dev分支），造成了冲突。<br>看到几百个文件的modify想死的心都有，差点想重新clone重新来过。。。<br>好在理智战胜冲动，决定正面处理冲突，而不是消极回避。<br>而在处理完冲突之后，发现异常的简单，庆幸没有冲动乱来。</p></blockquote><p>言归正传。</p><p>我在merge的时候git的提示是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err： Your local changes to the following files would be overwritteen by merge:</span><br><span class="line">      bla bla bla</span><br><span class="line">Please commit your changes or stash them before you merge.</span><br><span class="line">Abording</span><br><span class="line">Updating xxxxxxx(some hashcode)</span><br></pre></td></tr></table></figure></p><h3 id="解决方案有三种："><a href="#解决方案有三种：" class="headerlink" title="解决方案有三种："></a>解决方案有三种：</h3><a id="more"></a><h4 id="第一种：-提交修改"><a href="#第一种：-提交修改" class="headerlink" title="第一种： 提交修改"></a>第一种： 提交修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;my message&quot;</span><br></pre></td></tr></table></figure><h4 id="第二种：-stash"><a href="#第二种：-stash" class="headerlink" title="第二种： stash"></a>第二种： stash</h4><p>备份当前工作区的内容，从最近的一次提交种读取相关内容，当工作去保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。然后执行merge，然后再从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git statsh</span><br></pre></td></tr></table></figure></p><p>然后执行之前未执行完的merge操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge xxx</span><br></pre></td></tr></table></figure></p><p>然后拉取stash：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></p><p>由于可能存在多个stash的内容，所有用栈来管理，pop会从最近的一个stash中读取内容并恢复。<br>可以用 <code>git stash list</code> 来查看Git栈内的所有备份，可以利用这个列表来决定从哪个地方恢复。<br><code>git stash clear</code> 可以清空Git栈。</p><h4 id="第三种：-忽略本地修改"><a href="#第三种：-忽略本地修改" class="headerlink" title="第三种： 忽略本地修改"></a>第三种： 忽略本地修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">// or</span><br><span class="line">git checkout -t -f remote/branch</span><br></pre></td></tr></table></figure><h3 id="Or-忽略只忽略特定的文件"><a href="#Or-忽略只忽略特定的文件" class="headerlink" title="Or 忽略只忽略特定的文件"></a>Or 忽略只忽略特定的文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout filename</span><br></pre></td></tr></table></figure><h2 id="我当然使用的是stash的方式。"><a href="#我当然使用的是stash的方式。" class="headerlink" title="我当然使用的是stash的方式。"></a>我当然使用的是stash的方式。</h2><ul><li>在 <code>master</code> 分支上使用 <code>git stash</code>,</li><li>然后 <code>git merge dev</code>, 成功merge！</li><li>然后恢复工作区 <code>git stash pop</code>, 然后多出了很多modify的文件，还有一个标红的文件（冲突），不过它已经帮你解决好，只需要在文件中选择你要保留哪一段代码就好。</li><li>修改完冲突文件后， <code>git add .</code>, <code>git commit -m &quot;conflict fixed&quot;</code>.</li><li>最后，赶紧把这个解决完冲突后的代码传上远程仓库, WOO，松了一口气。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> conflict </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>virtualbox如何挂载宿主机的文件夹</title>
      <link href="/2018/07/17/virtualbox%E5%A6%82%E4%BD%95%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
      <url>/2018/07/17/virtualbox%E5%A6%82%E4%BD%95%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<p>我的宿主机是一台windows操作系统的服务器。</p><p>虚拟机用的是virtualbox。</p><p>以前在 vmware 上面与宿主机的共享只需要在 wmware 上配置下共享文件夹就可以生效。但是在 virtualbox 上，除了配置共享文件夹，还要使用 <code>mount</code> 命令进行挂载才能与宿主机共享一个文件夹。</p><a id="more"></a><h2 id="1-在宿主机建立一个用于与virtualbox共享的文件夹，例如-myshared。并在里面新建一个空的文本-a-txt，用于检测最后挂载是否成功。"><a href="#1-在宿主机建立一个用于与virtualbox共享的文件夹，例如-myshared。并在里面新建一个空的文本-a-txt，用于检测最后挂载是否成功。" class="headerlink" title="1. 在宿主机建立一个用于与virtualbox共享的文件夹，例如 myshared。并在里面新建一个空的文本 a.txt，用于检测最后挂载是否成功。"></a>1. 在宿主机建立一个用于与virtualbox共享的文件夹，例如 <code>myshared</code>。并在里面新建一个空的文本 <code>a.txt</code>，用于检测最后挂载是否成功。</h2><h2 id="2-在virtualbox中选择-设备-gt-共享文件夹-gt-打开设置界面。"><a href="#2-在virtualbox中选择-设备-gt-共享文件夹-gt-打开设置界面。" class="headerlink" title="2. 在virtualbox中选择 设备 -&gt; 共享文件夹 -&gt; 打开设置界面。"></a>2. 在virtualbox中选择 设备 -&gt; 共享文件夹 -&gt; 打开设置界面。</h2><h2 id="3-点击右侧-号，添加共享文件夹，选择宿主机上之前建好的-myshared-文件夹，并勾选-固定分配-。"><a href="#3-点击右侧-号，添加共享文件夹，选择宿主机上之前建好的-myshared-文件夹，并勾选-固定分配-。" class="headerlink" title="3. 点击右侧 + 号，添加共享文件夹，选择宿主机上之前建好的 myshared 文件夹，并勾选 固定分配 。"></a>3. 点击右侧 <code>+</code> 号，添加共享文件夹，选择宿主机上之前建好的 <code>myshared</code> 文件夹，并勾选 <code>固定分配</code> 。</h2><h2 id="4-在linux虚拟机中，打开终端，在mnt目录下新建一个目录-shared："><a href="#4-在linux虚拟机中，打开终端，在mnt目录下新建一个目录-shared：" class="headerlink" title="4. 在linux虚拟机中，打开终端，在mnt目录下新建一个目录 shared："></a>4. 在linux虚拟机中，打开终端，在mnt目录下新建一个目录 <code>shared</code>：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/shared</span><br></pre></td></tr></table></figure><h2 id="5-执行挂载："><a href="#5-执行挂载：" class="headerlink" title="5. 执行挂载："></a>5. 执行挂载：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t vboxsf myshared /mnt/shared</span><br></pre></td></tr></table></figure><h2 id="6-挂载成功，进入shared目录，就可以看到a-txt文件了。"><a href="#6-挂载成功，进入shared目录，就可以看到a-txt文件了。" class="headerlink" title="6. 挂载成功，进入shared目录，就可以看到a.txt文件了。"></a>6. 挂载成功，进入shared目录，就可以看到a.txt文件了。</h2>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtualbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下如何切换到root用户</title>
      <link href="/2018/07/16/linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%88%B0root%E7%94%A8%E6%88%B7/"/>
      <url>/2018/07/16/linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E5%88%B0root%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<p>如果只是想要临时使用一下root权限，只需要在命令前面加上 <code>sudo</code> 就可以了。</p><p>如果想要一直使用root权限，需要通过su切换到root用户：</p><a id="more"></a><h2 id="首先要重设root用户的密码"><a href="#首先要重设root用户的密码" class="headerlink" title="首先要重设root用户的密码"></a>首先要重设root用户的密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>然后根据提示，输入新的root密码（可以是原来的root旧密码）</p><h2 id="然后就可以随时切换到root用户了"><a href="#然后就可以随时切换到root用户了" class="headerlink" title="然后就可以随时切换到root用户了"></a>然后就可以随时切换到root用户了</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure><p>输入root用户密码即可。</p><h2 id="回到用户权限"><a href="#回到用户权限" class="headerlink" title="回到用户权限"></a>回到用户权限</h2><p>使用 <code>su &quot;yc&quot;</code> 或者 <code>exit</code> 命令，即可回到用户权限。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2018/07/16/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/07/16/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="列出当前目录下每个文件的大小以及当前目录文件下所有文件大小总和。"><a href="#列出当前目录下每个文件的大小以及当前目录文件下所有文件大小总和。" class="headerlink" title="列出当前目录下每个文件的大小以及当前目录文件下所有文件大小总和。"></a>列出当前目录下每个文件的大小以及当前目录文件下所有文件大小总和。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lht</span><br></pre></td></tr></table></figure><p>与以下命令是同一个效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l -h -t</span><br></pre></td></tr></table></figure></p><p>ls是 list segment 的缩写，用于列出文件。</p><h2 id="ls的常用参数"><a href="#ls的常用参数" class="headerlink" title="ls的常用参数"></a>ls的常用参数</h2><p>常用参数：</p><a id="more"></a><p>-a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件</p><p>-A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。</p><p>-c  配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序</p><p>-C 每栏由上至下列出项目</p><p>–color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</p><p>-d, –directory 将目录象文件一样显示，而不是显示其下的文件。</p><p>-D, –dired 产生适合 Emacs 的 dired 模式使用的结果</p><p>-f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</p><p>-g 类似 -l,但不列出所有者</p><p>-G, –no-group 不列出任何有关组的信息</p><p>-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)</p><p>–si 类似 -h,但文件大小取 1000 的次方而不是 1024</p><p>-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地</p><p>–indicator-style=方式 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</p><p>-i, –inode 印出每个文件的 inode 号</p><p>-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目</p><p>-k 即 –block-size=1K,以 k 字节的形式表示文件的大小。</p><p>-l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</p><p>-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息</p><p>-m 所有项目以逗号分隔，并填满整行行宽</p><p>-o 类似 -l,显示文件的除组信息外的详细信息。   </p><p>-r, –reverse 依相反次序排列</p><p>-R, –recursive 同时列出所有子目录层</p><p>-s, –size 以块大小为单位列出所有文件的大小</p><p>-S 根据文件大小排序</p><p>–sort=WORD 以下是可选用的 WORD 和它们代表的相应选项：</p><ul><li>extension -X status -c</li><li>none -U time -t</li><li>size -S atime -u</li><li>time -t access -u</li><li>version -v use -u</li></ul><p>-t 以文件修改时间排序</p><p>-u ：</p><ul><li>配合 -lt:显示访问时间而且依访问时间排序</li><li>配合 -l:显示访问时间但根据名称排序</li><li>否则：根据访问时间排序</li></ul><p>-U 不进行排序;依文件系统原有的次序列出项目</p><p>-v 根据版本进行排序</p><p>-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值</p><p>-x 逐行列出项目而不是逐栏列出</p><p>-X 根据扩展名排序</p><p>-1 每行只列出一个文件</p><p>–help 显示此帮助信息并离开</p><p>–version 显示版本信息并离开</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何重置gitlab用户密码</title>
      <link href="/2018/07/15/%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEgitlab%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
      <url>/2018/07/15/%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEgitlab%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>之前有提到，我为我们部门搭建了一个gitlab，前几天有用户跟我反映，他忘记密码了，使用gitlab自带的找回密码功能无果，收不到邮件，估计跟公司内网有一些关系，也可能是我没有配置好邮件联动。anyway，现在去配置邮箱感觉花的时间有些来不及。想着作为管理员，应该有权限和办法去重置用户的密码的，于是查询了资料，果然不出所料。方法如下，只需4步：</p><a id="more"></a><h2 id="1-首先进入Ruby-on-Rails-console："><a href="#1-首先进入Ruby-on-Rails-console：" class="headerlink" title="1. 首先进入Ruby on Rails console："></a>1. 首先进入Ruby on Rails console：</h2><p>使用root权限进入gitlab所在的linux服务器，打开一个终端，输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; gitlab-rails console production</span><br></pre></td></tr></table></figure></p><p>然后等待ruby的console界面加载出来。</p><h3 id="2-然后你有好几种方法去查找用户。"><a href="#2-然后你有好几种方法去查找用户。" class="headerlink" title="2. 然后你有好几种方法去查找用户。"></a>2. 然后你有好几种方法去查找用户。</h3><p>方法一，使用id：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; user = User.where(id:[user&apos;s register index]).first</span><br></pre></td></tr></table></figure></p><p>方法二，使用邮箱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; user = User.where(email:[user&apos;s register email]).first</span><br></pre></td></tr></table></figure></p><p>方法三，使用用户名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; user = User.where(name:[user&apos;s register name]).first</span><br></pre></td></tr></table></figure></p><p>我这次使用的是邮箱<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; user=User.where(email:xxx@163.com).first</span><br></pre></td></tr></table></figure></p><h3 id="3-修改密码"><a href="#3-修改密码" class="headerlink" title="3. 修改密码"></a>3. 修改密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; user.password = &apos;newpassword&apos;</span><br><span class="line">&gt; user.password_confirmation = &apos;newpassword&apos;</span><br></pre></td></tr></table></figure><blockquote><p>注意最好是将 <code>password</code> 和 <code>password_confirmation</code> 都重置，以确保完全修改生效。</p></blockquote><h3 id="4-保存修改"><a href="#4-保存修改" class="headerlink" title="4. 保存修改"></a>4. 保存修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; user.save!</span><br></pre></td></tr></table></figure><blockquote><p>注意 <code>!</code> 号也很重要，不加的话，你的修改不会推送到数据库。</p></blockquote><h2 id="现在退出-console-使用新的密码登录试试，可以登录啦。"><a href="#现在退出-console-使用新的密码登录试试，可以登录啦。" class="headerlink" title="现在退出 console 使用新的密码登录试试，可以登录啦。"></a>现在退出 console 使用新的密码登录试试，可以登录啦。</h2>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何迁移git仓库</title>
      <link href="/2018/06/20/%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BBgit%E4%BB%93%E5%BA%93/"/>
      <url>/2018/06/20/%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BBgit%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>如果你想从别的git托管服务哪里复制一份源代码到新的Git托管服务器上，可以使用<br><code>git clone --mirror</code> / <code>git clone --bare</code> 和 <code>git push --mirror</code>命令。</p><p>普通 <code>git clone</code> 不能下载所有分支，想要简单的克隆所有分支，可以用镜像方法。</p><h1 id="做一个镜像仓库"><a href="#做一个镜像仓库" class="headerlink" title="做一个镜像仓库"></a>做一个镜像仓库</h1><p>只需3步：</p><a id="more"></a><ol><li><p>从原地址克隆一份裸版本库（假设在github）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare git://github.com/username/project.git</span><br><span class="line">or</span><br><span class="line">git clone --mirror git://github.com/username/project.git</span><br></pre></td></tr></table></figure><blockquote><p>这两种方式都只是将裸仓库克隆下来，不会在本地生成目录结构。</p></blockquote></li><li><p>在新的服务器上创建一个新项目。例如new-peoject。</p></li><li><p>以镜像推送的方式上传到新的git服务器上（假设在gitlab）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd prioject.git</span><br><span class="line">git push --mirror  git@gitlab.com/username/new-priject.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="done"><a href="#done" class="headerlink" title="done!"></a>done!</h2><blockquote><p>这种方式可以保留原版本远程仓库中的所有内容。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 删除已发布的包或者包的某个版本</title>
      <link href="/2018/06/08/npm-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%8F%91%E5%B8%83%E7%9A%84%E5%8C%85%E6%88%96%E8%80%85%E5%8C%85%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%88%E6%9C%AC/"/>
      <url>/2018/06/08/npm-%E5%88%A0%E9%99%A4%E5%B7%B2%E5%8F%91%E5%B8%83%E7%9A%84%E5%8C%85%E6%88%96%E8%80%85%E5%8C%85%E7%9A%84%E6%9F%90%E4%B8%AA%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="删除已发布的包的某个版本："><a href="#删除已发布的包的某个版本：" class="headerlink" title="删除已发布的包的某个版本："></a>删除已发布的包的某个版本：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unpublish xxx@x.x.x</span><br></pre></td></tr></table></figure><blockquote><p>删除这个版本后，<strong>不能再发布同版本的包</strong>，必须要大于这个版本号的包才行。</p></blockquote><h2 id="删除已发布的包："><a href="#删除已发布的包：" class="headerlink" title="删除已发布的包："></a>删除已发布的包：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unpublish xxx</span><br></pre></td></tr></table></figure><blockquote><p>删除这个包之后，<strong>不能再发布同名的包</strong>。</p></blockquote><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p><code>npm unpublish</code> <strong>仅在包发布后的24小时内有效</strong>。如果超过了24小时，则要联系npm官方去取消发布了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> unpublish </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过NPM安装私有模块</title>
      <link href="/2018/06/07/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87NPM%E5%AE%89%E8%A3%85%E7%A7%81%E6%9C%89%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/06/07/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87NPM%E5%AE%89%E8%A3%85%E7%A7%81%E6%9C%89%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="如何通过NPM安装私有模块"><a href="#如何通过NPM安装私有模块" class="headerlink" title="如何通过NPM安装私有模块"></a>如何通过NPM安装私有模块</h1><p>可以有3种方案：</p><a id="more"></a><h2 id="方案一：购买npm付费账号"><a href="#方案一：购买npm付费账号" class="headerlink" title="方案一：购买npm付费账号"></a>方案一：购买npm付费账号</h2><p>根据npm的价格方案，只要是付费用户，不论是哪一种，都可以下载和发布不限量的私有模块。所有的私有模块都是scoped package。scope是npm的新特性。如果一个模块的名字以 <code>@</code> 开头，那它就是一个scoped package:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@scope/project-name</span><br></pre></td></tr></table></figure></p><p>每一个npm用户都有拥有一个自己的scope：当前用户名username。</p><h3 id="初始化一个scoped-package"><a href="#初始化一个scoped-package" class="headerlink" title="初始化一个scoped-package"></a>初始化一个scoped-package</h3><p>通过在包名字前添加scope：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;@usernane/project-name&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以使用 <code>npm init</code> 命令自定义 <code>--scope</code> 选项来设置scope：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init --scope=username</span><br></pre></td></tr></table></figure></p><p>如果你在大多数时候使用的scope都是相同的，可以设置一个默认的scope，这样每次初始化的时候会自动使用该scope：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set scope &lt;your_scope&gt;</span><br></pre></td></tr></table></figure></p><p>发布scoped模块跟发布普通模块一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure></p><p>默认状态下scoped package包是私有的。然而，你可以把scoped package免费的发布为共有包。只需要在发布时配置 <code>--access</code> 选项即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --access=public</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>提醒：</strong>发布之前首先一定要确保使用的是npm官方镜像源。如果你使用了<code>nrm</code>来管理镜像，可以通过<code>nrm ls</code>来查看下当前使用的是什么源，如果不是npmjs官方镜像，比如taobao，那么使用<code>nrm use npm</code>切换过来。</p></blockquote><h2 id="方案二：自建npm私服"><a href="#方案二：自建npm私服" class="headerlink" title="方案二：自建npm私服"></a>方案二：自建npm私服</h2><p>如果连仓库都是私有的，模块自然是私有的。这个方案好处就是可以建在自己公司内部，访问速度自然是杠杠的，而且想怎么定制就怎么定制。不过构建成本也是有的，而且需要服务器。一般稍微大规模的团队和公司会采取这种办法。</p><h2 id="方案三：利用npm安装机制和git仓库"><a href="#方案三：利用npm安装机制和git仓库" class="headerlink" title="方案三：利用npm安装机制和git仓库"></a>方案三：利用npm安装机制和git仓库</h2><p>这个方案最经济实惠。<br>首先，<code>npm install</code> 支持 <code>npm install &lt;git remote url&gt;</code> ，其中 <code>git remote url</code> 的格式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;protocol&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:/]&lt;path&gt;[#&lt;commit-ish&gt;]</span><br></pre></td></tr></table></figure></p><p>即，如果你的代码托管在bitbucket中，可以通过如下命令安装模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install git+ssh://git@bitbucket.org/用户名／项目名.git#版本号</span><br></pre></td></tr></table></figure></p><p>这种方式唯一的不足的地方就是，你必须要确保安装这个私有模块的机器由访问这个私有模块git仓库的权限。也就是说这台机器的公钥必须添加到git仓库中。<br>如果你嫌添加公钥麻烦，也可以通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install git+https:username:password@bitbucket.org/用户名／项目名.git#版本号</span><br></pre></td></tr></table></figure></p><p>不过密码就暴露出来了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件版本命名规范</title>
      <link href="/2018/06/04/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/2018/06/04/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="软件版本阶段"><a href="#软件版本阶段" class="headerlink" title="软件版本阶段"></a>软件版本阶段</h3><h4 id="开发期"><a href="#开发期" class="headerlink" title="开发期"></a>开发期</h4><ul><li><p>Base版<br>此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是页面中的功能都没有做完成的实现，只是作为整体网站的一个基础架构。</p></li><li><p>Alpha版<br>软件的初级版本，此版本表示软件处于以实现软件功能为主的阶段，通常只在软件开发者内部交流，一般而言，该版本软件的bug较多，需要继续修改。测试人员条bug经开发人员修改确认后，发布到测试网址让测试人员测试，此时可将软件版本标注为alpha版。</p></li><li><p>Beta版<br>此版本相对于alpha版已有了很大的改进，消除了严重的错误，但还存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对象是软件的UI。</p></li></ul><a id="more"></a><ul><li>RC（Release Candidate）版<br>最终测试版，此版本已经相当成熟了，基本上不存在导致错误的bug，与即将发行的正式版相差无几。可能成为最终产品的候选版本，如果未出现问题，则可发布称为正式版本，多数开源软件会推出两个RC版本，卒后的RC2则称为正式版本。</li></ul><ul><li>Release版<br>此版本意味着“最终版本”，是最终交付用户使用的一个版本。该版本又是也称为标准版本。一般情况下Release不会以单词形式出现在软件封面上，取而代之的是符号（R）。</li></ul><h4 id="完成期"><a href="#完成期" class="headerlink" title="完成期"></a>完成期</h4><ul><li><p>stable<br>稳定版，来自于蓝版本修改修正完成。</p></li><li><p>GA（General Availability）<br>正式发布的版本，在国外都是用GA来说明release版本的。</p></li><li><p>RTM（Release to Manufacturing）<br>给生产商的release版本，RTM版本并不一定意味着创作者解决软件的所有问题，仍有可能在向公众发布前更新版本。<br>另外一种RTM的称呼是RTM（Release To Web），表示正式版本的软件发布到Web网站上供客户免费下载。</p></li><li><p>RTL（Retail）<br>零售版，是真正的正式版，正式降价零售版。</p></li></ul><h3 id="软件版本命名规范"><a href="#软件版本命名规范" class="headerlink" title="软件版本命名规范"></a>软件版本命名规范</h3><p>软件版本号由4部分组成：<br>主版本号.子版本号.阶段版本号.日期版本号加希腊字母版本号（希腊字母版本号共有5种：base、alpha、beta、RC、release）。<br>例如：1.1.1.180604_beta</p><h4 id="版本号修改规则"><a href="#版本号修改规则" class="headerlink" title="版本号修改规则"></a>版本号修改规则</h4><ul><li><p>主版本号：当功能模块有较大的变动，比如增加多个模块活着整体架构发生变化，此版本号有项目决定是否修改。</p></li><li><p>子版本号：当功能有一定的增加或变化。此版本由项目决定是否修改。</p></li><li><p>修订版本号：一般是bug修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的bug即可发布一个修订版。此版本由项目经理决定是否修改。</p></li><li><p>日期版本号：用于记录修改项目的当前日志，每天对项目的修改都需要更改日期版本号。此版本号由开发人员决定是否修改。</p></li><li><p>希腊字母版本号：此版本号用语标注当前版本的软件处于哪个开发阶段，当软件进入到另一个阶段时，需要修改此版本号。此版本号由项目决定是否修改。</p></li></ul><blockquote><p><code>注：上一级有变动时，下级要归零。</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何设置linux虚拟机网络</title>
      <link href="/2018/05/28/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AElinux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2018/05/28/%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AElinux%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何搭建自己的gitlab服务</title>
      <link href="/2018/05/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84gitlab%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/05/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84gitlab%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是gitlab"><a href="#什么是gitlab" class="headerlink" title="什么是gitlab"></a>什么是gitlab</h1><p>gitlab是一个开源的基于web的git仓库管理工具。gitlab拥有github拥有的一切，并且拥有更多。</p><h1 id="如何搭建一个gitlab服务"><a href="#如何搭建一个gitlab服务" class="headerlink" title="如何搭建一个gitlab服务"></a>如何搭建一个gitlab服务</h1><p>只需如下4步：</p><ol><li>安装linux</li><li>安装gitlab</li><li>配置gitlab</li><li>启动gitlab</li></ol><a id="more"></a><h2 id="安装linux"><a href="#安装linux" class="headerlink" title="安装linux"></a>安装linux</h2><p>gitlab必须安装在linux系统上，因此必须要有一个linux操作系统环境。<br>gitlab目前支持的linux操作系统有：</p><ul><li>Ubuntu</li><li>Debian</li><li>CentOs</li><li>openSUSE<br>等。</li></ul><ol><li><p>安装虚拟机<br>我的服务器不是linux系统，没有关系，可以使用虚拟机。<br>虚拟机可以是oracle的virtual box，也可以是vmware。我选用的是virtual box。</p></li><li><p>获取linux操作系统安装文件<br>我获取的是ubuntu 16.04 LTS desktop版（desktop/server都行）</p></li><li><p>在virtual box里安装ubuntu<br>我在安装过程中，给ubuntu虚拟机分配了100G的硬盘容量。应为要作为代码托管的服务，所以尽量给大一点。</p></li></ol><h2 id="安装gitlab"><a href="#安装gitlab" class="headerlink" title="安装gitlab"></a>安装gitlab</h2><p>gitlab是开源的，可以去gitlab官网 <code>https://about.gitlab.com/</code> 获取ubuntu版本的的安装镜像地址。<br>安装方式可以在官网找到。这里大致贴一下。<br>安装和配置依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y curl openssh-server ca-certificates</span><br></pre></td></tr></table></figure></p><p>添加gitlab包，并安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure></p><p>因为我当时所在的网络不能访问该镜像地址，所以我按照官网的方式并没有成功。我在网上找了很多解决方案，最终通过安装离线包的方式安装成功。<br>先将离线包下载下来，放到virtual box的共享目录<code>mnt/share</code><br>然后通过如下命令安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i /mnt/share/gitlab-ce_10.1.4-ce.0_amd64.deb</span><br></pre></td></tr></table></figure></p><p>安装成功后的终端信息显示如下：<br><img src="/images/gitlab-install-success.png" alt="gitlab 安装成功"></p><h2 id="配置gitlab"><a href="#配置gitlab" class="headerlink" title="配置gitlab"></a>配置gitlab</h2><p>要修改的配置都在／ect／gitlab/gitlab.rb这个文件里面。<br>我这里主要是修改url为我自己服务器的域名以及端口（我为我的linux虚拟机申请了域名，具体操作见 <a href="https://yc111.github.io/2018/05/28/如何设置linux虚拟机网络/" target="_blank" rel="noopener">如何设置linux网络</a>）：找到gitlab.rb文件中的 <code>EXTERNAL_URL</code> 字段，将其修改为我的域名，端口设为80。</p><p>这样你的项目clone的地址中酒会变成你设置的域名而不是ip地址了。</p><p>然后运行如下命令让修改生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></p><h2 id="启动gitlab"><a href="#启动gitlab" class="headerlink" title="启动gitlab"></a>启动gitlab</h2><p>最后通过如下命令启动gitlab<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure></p><p>查看一下gitlab各服务器状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl status</span><br></pre></td></tr></table></figure></p><p>最后可以在浏览器中输入localhost查看gitlab的界面了。<br>首次访问gitlab界面，会要求你设置root账号的密码。<br><img src="/images/gitlab-first-access.png" alt="首次访问gitlab界面"></p><p>使用刚才重制后的root账号登录进入gitlab的界面<br><img src="/images/gitlab-root-login.png" alt="使用刚才重制后的root账号登录进入gitlab的界面"></p><p>退出root账号的gitlab界面<br><img src="/images/gitlab-logout.png" alt="退出root账号的gitlab界面"></p><h2 id="至此，就完成了gitlab的整个搭建过程。"><a href="#至此，就完成了gitlab的整个搭建过程。" class="headerlink" title="至此，就完成了gitlab的整个搭建过程。"></a>至此，就完成了gitlab的整个搭建过程。</h2><p>可以愉快地在上面注册账号，创建项目，协作开发了！</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2018/04/25/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/04/25/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="2-用户名邮箱配置"><a href="#2-用户名邮箱配置" class="headerlink" title="2. 用户名邮箱配置"></a>2. 用户名邮箱配置</h3><p>设置全局用户属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;champyin&quot;</span><br><span class="line">git config --global user.email &quot;champyin@163.com&quot;</span><br></pre></td></tr></table></figure></p><blockquote><p>–global: 设置当前用户的全局属性，当你的 repository 没有设置项目的 user.name 和 user.email 的时候，会默认用这个。</p></blockquote><p>查看全局用户属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure></p><p>如何知道本地有没有设置属性：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br></pre></td></tr></table></figure><p>如何设置本地属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;champyin002&quot;</span><br><span class="line">gut config user.email &quot;champyin002@163.com&quot;</span><br></pre></td></tr></table></figure></p><h3 id="3-远程仓库设置"><a href="#3-远程仓库设置" class="headerlink" title="3. 远程仓库设置"></a>3. 远程仓库设置</h3><p>查看当前配置有哪些远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote </span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><blockquote><p><code>git remote</code> 列出每个远程仓库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程仓库<br><code>git remote -v</code> 显示对应的远程仓库地址。<code>-v</code> 为 <code>-verbose</code> 的简写。</p></blockquote><p>添加远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure></p><blockquote><p>[shortname]是自己为远程仓库取的一个简单的名字，便于以后引用。</p></blockquote><p>修改远程仓库协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:lovecoding/lovecoding.github.io.git</span><br></pre></td></tr></table></figure></p><blockquote><p>将远程仓库origin改为git协议的地址。</p></blockquote><p>查看远程仓库信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote-name]</span><br><span class="line">git remote show origin #查看所克隆的origin仓库</span><br></pre></td></tr></table></figure></p><p>重命名远程仓库（修改某个远程仓库在本地的简称）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename origin sam #把远程仓库 origin 重命名为 sam</span><br></pre></td></tr></table></figure></p><blockquote><p>对远程仓库的重命名，也会使对应的分支名称发生变化。原来的 origin／master 分支现在成为了 sam／master。</p></blockquote><p>本地移除对应的远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm sam</span><br></pre></td></tr></table></figure></p><h3 id="4-分支设置"><a href="#4-分支设置" class="headerlink" title="4. 分支设置"></a>4. 分支设置</h3><p>查看本地分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>查看各个分支最后一个提交对象的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure></p><p>查看远程分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></p><p>查看所有分支，包括本地和远程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></p><p>创建分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch mytest1</span><br></pre></td></tr></table></figure></p><p>切换分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout mytest1</span><br></pre></td></tr></table></figure></p><p>创建并切换到该分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b mytest2</span><br></pre></td></tr></table></figure></p><p>删除分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d mytest1</span><br></pre></td></tr></table></figure></p><p>删除远程分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete mytest1 //git v1.70 以上</span><br><span class="line">// or</span><br><span class="line">git pudh origin :mytest1 //git v1.5.0以上 推送一个空的分支到远程分支。</span><br></pre></td></tr></table></figure></p><h3 id="5-获取远程分支代码"><a href="#5-获取远程分支代码" class="headerlink" title="5. 获取远程分支代码"></a>5. 获取远程分支代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull [remote-name] [remote-branch-name]:[local-branch-name]</span><br><span class="line">git pull origin bugfix:master</span><br></pre></td></tr></table></figure><blockquote><p>注意，分支推送、拉取命令的写法规则是&lt;来源地&gt;:&lt;目的地&gt;。所以 git pull 是[remote-branch-name]:[local-branch-name]，git push 是[local-branch-name]:[remote-branch-name]。</p></blockquote><h3 id="6-上传代码到远程仓库"><a href="#6-上传代码到远程仓库" class="headerlink" title="6. 上传代码到远程仓库"></a>6. 上传代码到远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br><span class="line">git push origin master  #把本地的master分支推送到origin服务器上。</span><br></pre></td></tr></table></figure><h3 id="7-上传代码到远程仓库分支"><a href="#7-上传代码到远程仓库分支" class="headerlink" title="7. 上传代码到远程仓库分支"></a>7. 上传代码到远程仓库分支</h3><p>如果远程有一个 bugfix 分支，我想要有一份自己的 bugfix 来开发。<br>先将远程分支抓取下来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure></p><p>在远程分支的基础上分化一个新的本地分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b [local-branch-name] [remote-name]/[remote-branch-name]</span><br><span class="line">git chechout -b bugfix origin/bugfix</span><br></pre></td></tr></table></figure></p><blockquote><p>采用此命令建立的本地分支会自动和远程分支建立映射关系。</p></blockquote><p>修改完代码后，上传到远程 bugfix 分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br><span class="line">git push origin bugfix</span><br><span class="line"># or</span><br><span class="line">git push [remote-name] [local-branch-name]:[remote-branch-name]</span><br><span class="line">git push origin bugfix:bugfix #实现跟上一条命令同样的效果。</span><br></pre></td></tr></table></figure></p><blockquote><p><code>git push origin bugfix</code> 意思为取出在本地的 bugfix 分支，推送到远程仓库的 bugfix 分支中去。<br><code>git push orign bugfix:bugfix</code> 意思为上传完本地的bugfix分支到远程仓库中去，仍旧称它为 bugfix 分支。实现跟上一条命令相同的效果。通过此语法，可以把本地分支推送到某个命名不同的远程分支：例如使用<code>git push origin bugfix:hotfix</code> 来推送，如果远程分支 hotfix 不存在，则会在远程仓库被新建。当我的协作者再次从服务器上抓取数据时，他们将得到一个新的远程分支 origin／hotfix.</p></blockquote><h3 id="8-打tag"><a href="#8-打tag" class="headerlink" title="8. 打tag"></a>8. 打tag</h3><blockquote><p>注意：tag是打在commit上，不是分支上。</p></blockquote><p>轻量级标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0</span><br></pre></td></tr></table></figure></p><p>给历史提交打标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0 88aa731 #历史commit的id的前7位</span><br></pre></td></tr></table></figure></p><p>查看标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></p><p>搜索符合模式的tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l &apos;v0.1.*&apos;</span><br></pre></td></tr></table></figure></p><p>将本地标签同步到远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags #提交所有的tag</span><br><span class="line">git push origin v1.0.0 #提交单个tag</span><br></pre></td></tr></table></figure></p><p>切换到tag</p><blockquote><p>与切换到分支命令相同</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [tagname]</span><br></pre></td></tr></table></figure><p>查看tag信息</p><blockquote><p>用 <code>git show</code> 命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show v0.1.1</span><br></pre></td></tr></table></figure><p>删除本地标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1.0.0</span><br></pre></td></tr></table></figure></p><p>将删除标签同步到远程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v1.0.0 #推送空的同名版本到远程</span><br></pre></td></tr></table></figure></p><p>拉取某个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin tag v1.0.0</span><br></pre></td></tr></table></figure></p><h3 id="9-查看提交历史日志"><a href="#9-查看提交历史日志" class="headerlink" title="9. 查看提交历史日志"></a>9. 查看提交历史日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline --abbrev-commit #将commit id显示为缩写（前7位）</span><br></pre></td></tr></table></figure><p>退出查看日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure></p><h3 id="10-修改已经提交的信息"><a href="#10-修改已经提交的信息" class="headerlink" title="10. 修改已经提交的信息"></a>10. 修改已经提交的信息</h3><p>当你不小心写错了提交信息，理论上，SCM上是不应该修改历史信息的，但是在git中可以修改最后一次提交的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></p><p><code>amend</code> 参数提供了对最后一次commit的修改，对于历史提交，如果想修改，就必须使用 <code>rebase</code> 了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3  #表示要修改当前版本的倒数第三次状态。</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置git环境之设置SSH key</title>
      <link href="/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AESSH-key/"/>
      <url>/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AESSH-key/</url>
      
        <content type="html"><![CDATA[<h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><p>配置ssh秘钥，以及使用git协议，每次pull、push可以免去输入账号密码的麻烦。不过记得查看下远程仓库地址是不是https协议，如果是就要要改成git协议才可以不用输入密码。</p><p>配置过程很简单，只需2步：</p><a id="more"></a><h3 id="1-生成秘钥对"><a href="#1-生成秘钥对" class="headerlink" title="1. 生成秘钥对"></a>1. 生成秘钥对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;lovecoding@163.com&quot;</span><br></pre></td></tr></table></figure><p>提示输入文件，直接回车。<br>提示输入密码，直接回车。<br>得到公钥文件id_rsa.pub</p><h3 id="2-设置远程仓库上的秘钥"><a href="#2-设置远程仓库上的秘钥" class="headerlink" title="2. 设置远程仓库上的秘钥"></a>2. 设置远程仓库上的秘钥</h3><p>查看公钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p><p>复制公钥内容，进入github，在setting里，新建SHH key，将公钥内容填进去。</p><h3 id="验证key是否正常工作："><a href="#验证key是否正常工作：" class="headerlink" title="验证key是否正常工作："></a>验证key是否正常工作：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果看到”Hi lovecoding！ you’ve successfully authenticated, but GitHub does not provide shell access.说明设置成功。</p><h3 id="3-将远程仓库地址设置为git协议"><a href="#3-将远程仓库地址设置为git协议" class="headerlink" title="3. 将远程仓库地址设置为git协议"></a>3. 将远程仓库地址设置为git协议</h3><p>查看reomte<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><p>如果发现是https协议的，修改remote<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url remotename git@github.com:useraccount/reponame.git</span><br></pre></td></tr></table></figure></p><h3 id="4-如果到了这一步，提交还提示输入账号密码，那就还要修改下项目配置中的git提交地址"><a href="#4-如果到了这一步，提交还提示输入账号密码，那就还要修改下项目配置中的git提交地址" class="headerlink" title="4. 如果到了这一步，提交还提示输入账号密码，那就还要修改下项目配置中的git提交地址"></a>4. 如果到了这一步，提交还提示输入账号密码，那就还要修改下项目配置中的git提交地址</h3><p>查看项目git配置信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></p><p>此时remote.origin.url的值应该还是https的那个地址。我们需要将它改成git协议的repo地址。<br>这个配置文件在当前项目下的.git目录下的config文件里，我们编辑它，修改remote.origin.url即可。</p><p>这个时候，再来push更新，一定不会再要你输入账号密码了。</p><h3 id="完美！"><a href="#完美！" class="headerlink" title="完美！"></a>完美！</h3>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置git环境之设置remote url的传输协议</title>
      <link href="/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AEremote-url%E7%9A%84%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AEremote-url%E7%9A%84%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="把git的remote-url改为git协议。"><a href="#把git的remote-url改为git协议。" class="headerlink" title="把git的remote url改为git协议。"></a>把git的remote url改为git协议。</h2><p>查看当前remote url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><p>如果是https开头，使用set-url来调整：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:lovecoding/lovecoding.github.io.git</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置git环境之设置用户名和邮箱</title>
      <link href="/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1/"/>
      <url>/2018/04/07/%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E9%82%AE%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="设置用户名邮箱"><a href="#设置用户名邮箱" class="headerlink" title="设置用户名邮箱"></a>设置用户名邮箱</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;lovecoding@163.com&quot;</span><br><span class="line">git config --global user.name &quot;lovecoding&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶(一)：下载hexo主题，配置博客界面</title>
      <link href="/2018/04/07/%E8%BF%9B%E9%98%B6-%E4%B8%80-%EF%BC%9A%E4%B8%8B%E8%BD%BDhexo%E4%B8%BB%E9%A2%98%EF%BC%8C%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E7%95%8C%E9%9D%A2/"/>
      <url>/2018/04/07/%E8%BF%9B%E9%98%B6-%E4%B8%80-%EF%BC%9A%E4%B8%8B%E8%BD%BDhexo%E4%B8%BB%E9%A2%98%EF%BC%8C%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="进阶：下载hexo主题，配置博客界面"><a href="#进阶：下载hexo主题，配置博客界面" class="headerlink" title="进阶：下载hexo主题，配置博客界面"></a>进阶：下载hexo主题，配置博客界面</h2><h3 id="1-下载安装hexo主题"><a href="#1-下载安装hexo主题" class="headerlink" title="1. 下载安装hexo主题"></a>1. 下载安装hexo主题</h3><p>经筛选，我选择NexT主题作为我的博客主题。<br>进入blog目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="2-启用NexT主题"><a href="#2-启用NexT主题" class="headerlink" title="2. 启用NexT主题"></a>2. 启用NexT主题</h3><p>打开blog根目录下的_config.yml，找到theme字段，将其修改为next。</p><h3 id="3-验证主题"><a href="#3-验证主题" class="headerlink" title="3. 验证主题"></a>3. 验证主题</h3><p>启动hexo本地站点，并启动调试模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure></p><p>当出现“INFO Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.”说明启动成功。<br>在浏览器访问localhost:4000，检查主题是否生效。</p><h3 id="4-将新的博客主题部署到github-io"><a href="#4-将新的博客主题部署到github-io" class="headerlink" title="4. 将新的博客主题部署到github.io"></a>4. 将新的博客主题部署到github.io</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>出现done: git后，刷新lovecoding.github.io，可以看到主题已经变成了next主题。</p><p>更多的关于hexo和next配置，可以参考如下链接。<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo文档</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用hexo+github建立自己的博客</title>
      <link href="/2018/04/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo-github%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/04/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo-github%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>利用hexo和github搭建自己的博客网站并不复杂，只需follow以下3个steps：</p><ol><li>创建github.io page</li><li>搭建本地hexo环境</li><li>将github.io page与hexo关联起来</li></ol><a id="more"></a><h2 id="一、创建github-io-page"><a href="#一、创建github-io-page" class="headerlink" title="一、创建github.io page"></a>一、创建github.io page</h2><h3 id="1-首先要有github账号，没有的话去github-com注册一个。"><a href="#1-首先要有github账号，没有的话去github-com注册一个。" class="headerlink" title="1. 首先要有github账号，没有的话去github.com注册一个。"></a>1. 首先要有github账号，没有的话去github.com注册一个。</h3><p>github是一个基于git的web协作社区。<br>为描述方便，假设注册好的github账号名为：lovecoding。</p><h3 id="2-在github上创建一个名为lovecoding-github-io的repository。"><a href="#2-在github上创建一个名为lovecoding-github-io的repository。" class="headerlink" title="2. 在github上创建一个名为lovecoding.github.io的repository。"></a>2. 在github上创建一个名为lovecoding.github.io的repository。</h3><p>注意：一定要是你的github账号名加.github.io作为repository的名字，不能是其他名字，否则不会生成github.io根域名的page。这一点在<a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="noopener">User, Organization, and Project Pages</a>上有详细解释。</p><h3 id="3-向lovecoding-github-io仓库上传一份文件。"><a href="#3-向lovecoding-github-io仓库上传一份文件。" class="headerlink" title="3. 向lovecoding.github.io仓库上传一份文件。"></a>3. 向lovecoding.github.io仓库上传一份文件。</h3><p>比如上传一份README.md文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd newRepository</span><br><span class="line">echo &quot;# my github.io page&quot; &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commint&quot;</span><br><span class="line">git remote add origin git@github.com:lovecoding/lovecoding.github.io.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>如果是首次使用github，需要先<a href="https://yc111.github.io/2018/04/07/配置git环境之设置用户名和邮箱/" target="_blank" rel="noopener">设置一下用户名和邮箱</a>，以及<a href="https://yc111.github.io/2018/04/07/配置git环境之设置SSH-key/" target="_blank" rel="noopener">配置SSH key</a>，最好再<a href="https://yc111.github.io/2018/04/07/配置git环境之设置remote-url的传输协议/" target="_blank" rel="noopener">将传输协议设置为git协议</a>。如果是github老用户，忽略这三步。</p><h3 id="4-验证github-io-page是否创建成功"><a href="#4-验证github-io-page是否创建成功" class="headerlink" title="4. 验证github.io page是否创建成功"></a>4. 验证github.io page是否创建成功</h3><p>进入github中该repository的settings页面，滚动到Github Page处，可以看到“your site is published at <a href="https://lovecoding.github.io/" target="_blank" rel="noopener">https://lovecoding.github.io/</a><br>进入浏览器，输入lovecoding.github.io，页面出来了，显示“my github.io page”。<br>说明github.io page创建成功。</p><h2 id="二、搭建本地hexo环境"><a href="#二、搭建本地hexo环境" class="headerlink" title="二、搭建本地hexo环境"></a>二、搭建本地hexo环境</h2><p>Hexo是一个高效的静态网站生成框架。通过hexo，可以轻松使用markdown编辑文章。</p><h3 id="1-Hexo是基于node-js的，所以首先要安装node-js。"><a href="#1-Hexo是基于node-js的，所以首先要安装node-js。" class="headerlink" title="1. Hexo是基于node.js的，所以首先要安装node.js。"></a>1. Hexo是基于node.js的，所以首先要安装node.js。</h3><p>去<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">node官网</a>下载最新版，然后安装。</p><h3 id="2-在本地创建一个文件夹，用于存放hexo工程。"><a href="#2-在本地创建一个文件夹，用于存放hexo工程。" class="headerlink" title="2. 在本地创建一个文件夹，用于存放hexo工程。"></a>2. 在本地创建一个文件夹，用于存放hexo工程。</h3><p>为便于描述，假设创建的文件夹命名为：blog。</p><h3 id="3-安装hexo（全局安装）。"><a href="#3-安装hexo（全局安装）。" class="headerlink" title="3. 安装hexo（全局安装）。"></a>3. 安装hexo（全局安装）。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><h3 id="4-初始化hexo。"><a href="#4-初始化hexo。" class="headerlink" title="4. 初始化hexo。"></a>4. 初始化hexo。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h3 id="5-生成静态页面"><a href="#5-生成静态页面" class="headerlink" title="5. 生成静态页面"></a>5. 生成静态页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><h3 id="6-本地启动"><a href="#6-本地启动" class="headerlink" title="6. 本地启动"></a>6. 本地启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>如果看到“INFO Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>. Press Ctrl+C to stop.”，说明启动成功。</p><h3 id="7-打开本地博客网址，验证hexo环境。"><a href="#7-打开本地博客网址，验证hexo环境。" class="headerlink" title="7. 打开本地博客网址，验证hexo环境。"></a>7. 打开本地博客网址，验证hexo环境。</h3><p>在浏览器打开localhost:4000 ，可以看到hexo自动生成的hello world页面，hexo环境搭建成功！</p><h2 id="三、将github-io-page与hexo关联起来"><a href="#三、将github-io-page与hexo关联起来" class="headerlink" title="三、将github.io page与hexo关联起来"></a>三、将github.io page与hexo关联起来</h2><p>在blog目录下有一个_config.yml文件，它是hexo的站点配置文件，要将github.io与hexo关联起来，首先要配置_config.yml里的deploy字段。</p><h3 id="1-编辑-config-yml配置deploy字段。"><a href="#1-编辑-config-yml配置deploy字段。" class="headerlink" title="1. 编辑_config.yml配置deploy字段。"></a>1. 编辑_config.yml配置deploy字段。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><p>翻到最下面，将deploy字段的值配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:lovecoding/lovecoding.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>注：vim进入编辑的命令为i，退出编辑模式的方法为按ESC键，按:号进入命令模式，保存并退出命令为wq。</p><h3 id="2-安装hexo的deploy工具。"><a href="#2-安装hexo的deploy工具。" class="headerlink" title="2. 安装hexo的deploy工具。"></a>2. 安装hexo的deploy工具。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deploy-git --save</span><br></pre></td></tr></table></figure><h3 id="3-将本地hexo静态网页部署到github上。"><a href="#3-将本地hexo静态网页部署到github上。" class="headerlink" title="3. 将本地hexo静态网页部署到github上。"></a>3. 将本地hexo静态网页部署到github上。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>当出现“INFO Deploy done：git”的时候，说明部署完毕。</p><h3 id="4-验证部署结果"><a href="#4-验证部署结果" class="headerlink" title="4. 验证部署结果"></a>4. 验证部署结果</h3><p>在浏览器打开lovecoding.github.io<br>可以看到本地的hexo博客出现在了github.io网站上。<br>同时，名为lovecoding.github.io的repository下可以看到被上传了文件和代码（hexo工程blog目录下的public目录）<br>说明github.io page与hexo关联成功！。</p><h3 id="一些hexo的常用命令"><a href="#一些hexo的常用命令" class="headerlink" title="一些hexo的常用命令"></a>一些hexo的常用命令</h3><p>以后要部署新的文章，只需按以下步骤：<br>hexo clean  #清除缓存，避免一些奇怪的问题<br>hexo generate<br>hexo deploy</p><p>其他常用命令：<br>hexo new “newArticleTitle”  #创建文章 可以简写为hexo n<br>hexo new page “newPageName”  #创建页面<br>hexo generate  #生成静态页面至public目录 可以简写为hexo g<br>hexo deploy  #将public目录部署到github 可以简写为hexo d<br>hexo server  #启动本地服务 可以简写为hexo s<br>hexo help  #hexo帮助<br>hexo version  #查看版本信息</p><p>组合命令：<br>hexo s -g  #生成页面并启动本地服务<br>hexo d -g  #生成页面并部署到github</p><h3 id="至此，就完成了一个博客网站的搭建。"><a href="#至此，就完成了一个博客网站的搭建。" class="headerlink" title="至此，就完成了一个博客网站的搭建。"></a>至此，就完成了一个博客网站的搭建。</h3>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-widows</title>
      <link href="/2018/04/06/node-widows/"/>
      <url>/2018/04/06/node-widows/</url>
      
        <content type="html"><![CDATA[<h2 id="使用node-windows-将node服务变成windows服务进行管理"><a href="#使用node-windows-将node服务变成windows服务进行管理" class="headerlink" title="使用node-windows 将node服务变成windows服务进行管理"></a>使用node-windows 将node服务变成windows服务进行管理</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
